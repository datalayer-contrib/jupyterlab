
diff --git a/packages/docmanager/src/manager.ts b/packages/docmanager/src/manager.ts
index 11536a493db..ef588edf1ba 100644
--- a/packages/docmanager/src/manager.ts
+++ b/packages/docmanager/src/manager.ts
@@ -13,6 +13,8 @@ import {
   IDocumentWidget
 } from '@jupyterlab/docregistry';
 
+import { IModelDB } from '@jupyterlab/observables';
+
 import { Contents, Kernel, ServiceManager } from '@jupyterlab/services';
 
 import { ArrayExt, find } from '@phosphor/algorithm';
@@ -452,7 +454,8 @@ export class DocumentManager implements IDisposable {
   private _createContext(
     path: string,
     factory: DocumentRegistry.ModelFactory,
-    kernelPreference: IClientSession.IKernelPreference
+    kernelPreference: IClientSession.IKernelPreference,
+    modelDBFactory: IModelDB.IFactory
   ): Private.IContext {
     // TODO: Make it impossible to open two different contexts for the same
     // path. Or at least prompt the closing of all widgets associated with the
@@ -469,8 +472,6 @@ export class DocumentManager implements IDisposable {
       this._widgetManager.adoptWidget(context, widget);
       this._opener.open(widget, options);
     };
-    let modelDBFactory =
-      this.services.contents.getModelDBFactory(path) || undefined;
     let context = new Context({
       opener: adopter,
       manager: this.services,
@@ -523,6 +524,10 @@ export class DocumentManager implements IDisposable {
     return registry.getWidgetFactory(widgetName);
   }
 
+  private _modelDBFactoryFor(path: string): IModelDB.IFactory {
+    return this.registry.getModelDBFactory(path);
+  }
+
   /**
    * Creates a new document, or loads one from disk, depending on the `which` argument.
    * If `which==='create'`, then it creates a new document. If `which==='open'`,
@@ -548,6 +553,8 @@ export class DocumentManager implements IDisposable {
       return undefined;
     }
 
+    let dbFactory = this._modelDBFactoryFor(path);
+
     // Handle the kernel pereference.
     let preference = this.registry.getKernelPreference(
       path,
@@ -563,13 +570,13 @@ export class DocumentManager implements IDisposable {
       // Use an existing context if available.
       context = this._findContext(path, factory.name) || null;
       if (!context) {
-        context = this._createContext(path, factory, preference);
+        context = this._createContext(path, factory, preference, dbFactory);
         // Populate the model, either from disk or a
         // model backend.
         ready = this._when.then(() => context.initialize(false));
       }
     } else if (which === 'create') {
-      context = this._createContext(path, factory, preference);
+      context = this._createContext(path, factory, preference, dbFactory);
       // Immediately save the contents to disk.
       ready = this._when.then(() => context.initialize(true));
     }
diff --git a/packages/docmanager/tsconfig.json b/packages/docmanager/tsconfig.json
index b4feba7cbf1..7756343f94c 100644
--- a/packages/docmanager/tsconfig.json
+++ b/packages/docmanager/tsconfig.json
@@ -20,6 +20,9 @@
     },
     {
       "path": "../statusbar"
+    },
+    {
+      "path": "../observables"
     }
   ]
 }

diff --git a/packages/docregistry/src/context.ts b/packages/docregistry/src/context.ts
index 9b7dd76b6b9..0ad27cc3d0a 100644
--- a/packages/docregistry/src/context.ts
+++ b/packages/docregistry/src/context.ts
@@ -24,7 +24,7 @@ import {
 
 import { PathExt } from '@jupyterlab/coreutils';
 
-import { IModelDB, ModelDB } from '@jupyterlab/observables';
+import { IModelDB } from '@jupyterlab/observables';
 
 import { RenderMimeRegistry } from '@jupyterlab/rendermime';
 
@@ -53,7 +53,7 @@ export class Context<T extends DocumentRegistry.IModel>
     let dbFactory = options.modelDBFactory;
     if (dbFactory) {
       const localPath = manager.contents.localPath(this._path);
-      this._modelDB = dbFactory.createNew(localPath);
+      this._modelDB = dbFactory.createNew(localPath, this._factory.schemas);
       this._model = this._factory.createNew(lang, this._modelDB);
     } else {
       this._model = this._factory.createNew(lang);
@@ -815,7 +815,7 @@ export namespace Context {
     /**
      * An IModelDB factory method which may be used for the document.
      */
-    modelDBFactory?: ModelDB.IFactory;
+    modelDBFactory?: IModelDB.IFactory;
 
     /**
      * An optional callback for opening sibling widgets.
diff --git a/packages/docregistry/src/default.ts b/packages/docregistry/src/default.ts
index b4054124986..c37c07ebd2f 100644
--- a/packages/docregistry/src/default.ts
+++ b/packages/docregistry/src/default.ts
@@ -7,6 +7,10 @@ import { Contents } from '@jupyterlab/services';
 
 import { JSONValue } from '@phosphor/coreutils';
 
+import { Schema, Fields } from '@phosphor/datastore';
+
+import { IDisposable } from '@phosphor/disposable';
+
 import { ISignal, Signal } from '@phosphor/signaling';
 
 import { Widget } from '@phosphor/widgets';
@@ -17,25 +21,37 @@ import { CodeEditor } from '@jupyterlab/codeeditor';
 
 import { IChangedArgs, PathExt } from '@jupyterlab/coreutils';
 
-import { IModelDB } from '@jupyterlab/observables';
+import {
+  IModelDB,
+  ModelDB,
+  IObservableString,
+  IObservableMap,
+  IObservableValue
+} from '@jupyterlab/observables';
 
 import { DocumentRegistry, IDocumentWidget } from './index';
 
 /**
  * The default implementation of a document model.
  */
-export class DocumentModel extends CodeEditor.Model
-  implements DocumentRegistry.ICodeModel {
+export abstract class DocumentModel implements IDisposable {
   /**
    * Construct a new document model.
    */
-  constructor(languagePreference?: string, modelDB?: IModelDB) {
-    super({ modelDB });
+  constructor(
+    mimeType: string,
+    languagePreference?: string,
+    modelDB?: IModelDB
+  ) {
+    this.modelDB = modelDB || new ModelDB();
     this._defaultLang = languagePreference || '';
-    this.value.changed.connect(
-      this.triggerContentChange,
+
+    let mimeTypeObs = this.modelDB.createValue('mimeType');
+    mimeTypeObs.changed.connect(
+      this._onMimeTypeChanged,
       this
     );
+    this._defaultMimeType = mimeType;
   }
 
   /**
@@ -103,28 +119,43 @@ export class DocumentModel extends CodeEditor.Model
   }
 
   /**
-   * Serialize the model to a string.
+   * A signal emitted when a mimetype changes.
    */
-  toString(): string {
-    return this.value.text;
+  get mimeTypeChanged(): ISignal<this, IChangedArgs<string>> {
+    return this._mimeTypeChanged;
   }
 
+  /**
+   * A mime type of the model.
+   */
+  get mimeType(): string {
+    return this.modelDB.getValue('mimeType') as string;
+  }
+  set mimeType(newValue: string) {
+    const oldValue = this.mimeType;
+    if (oldValue === newValue) {
+      return;
+    }
+    this.modelDB.setValue('mimeType', newValue);
+  }
+
+  /**
+   * Serialize the model to a string.
+   */
+  abstract toString(): string;
+
   /**
    * Deserialize the model from a string.
    *
    * #### Notes
    * Should emit a [contentChanged] signal.
    */
-  fromString(value: string): void {
-    this.value.text = value;
-  }
+  abstract fromString(value: string): void;
 
   /**
    * Serialize the model to JSON.
    */
-  toJSON(): JSONValue {
-    return JSON.parse(this.value.text || 'null');
-  }
+  abstract toJSON(): JSONValue;
 
   /**
    * Deserialize the model from JSON.
@@ -132,17 +163,40 @@ export class DocumentModel extends CodeEditor.Model
    * #### Notes
    * Should emit a [contentChanged] signal.
    */
-  fromJSON(value: JSONValue): void {
-    this.fromString(JSON.stringify(value));
-  }
+  abstract fromJSON(value: JSONValue): void;
 
   /**
    * Initialize the model with its current state.
    */
   initialize(): void {
-    return;
+    const mimeType = this.modelDB.get('mimeType') as IObservableValue;
+    mimeType.set(mimeType.get() || this._defaultMimeType || 'text/plain');
   }
 
+  /**
+   * Whether the model is disposed.
+   */
+  get isDisposed(): boolean {
+    return this._isDisposed;
+  }
+
+  /**
+   * Dispose of the resources used by the model.
+   */
+  dispose(): void {
+    if (this._isDisposed) {
+      return;
+    }
+    this._isDisposed = true;
+    Signal.clearData(this);
+  }
+
+  /**
+   * The underlying `IModelDB` instance in which model
+   * data is stored.
+   */
+  readonly modelDB: IModelDB;
+
   /**
    * Trigger a state change signal.
    */
@@ -158,13 +212,129 @@ export class DocumentModel extends CodeEditor.Model
     this.dirty = true;
   }
 
+  private _onMimeTypeChanged(
+    mimeType: IObservableValue,
+    args: IObservableValue.IChangedArgs
+  ): void {
+    this._mimeTypeChanged.emit({
+      name: 'mimeType',
+      oldValue: args.oldValue as string,
+      newValue: args.newValue as string
+    });
+  }
+
   private _defaultLang = '';
   private _dirty = false;
+  private _isDisposed = false;
   private _readOnly = false;
+  private _defaultMimeType: string;
   private _contentChanged = new Signal<this, void>(this);
+  private _mimeTypeChanged = new Signal<this, IChangedArgs<string>>(this);
   private _stateChanged = new Signal<this, IChangedArgs<any>>(this);
 }
 
+/**
+ *
+ */
+export class TextModel extends DocumentModel
+  implements DocumentRegistry.ICodeModel {
+  /**
+   *
+   */
+  constructor(languagePreference?: string, modelDB?: IModelDB) {
+    super('text/plain', languagePreference, modelDB);
+    let value = this.modelDB.createString('value');
+    value.changed.connect(
+      this.triggerContentChange,
+      this
+    );
+  }
+
+  /**
+   * Get the value of the model.
+   */
+  get value(): IObservableString {
+    return this.modelDB.get('value') as IObservableString;
+  }
+
+  /**
+   * Get the selections for the model.
+   */
+  get selections(): IObservableMap<CodeEditor.ITextSelection[]> {
+    return this.modelDB.get('selections') as IObservableMap<
+      CodeEditor.ITextSelection[]
+    >;
+  }
+
+  toString(): string {
+    return this.value.text;
+  }
+
+  fromString(value: string): void {
+    this.value.text = value;
+  }
+
+  toJSON(): JSONValue {
+    return JSON.parse(this.value.text || 'null');
+  }
+
+  fromJSON(value: JSONValue): void {
+    this.fromString(JSON.stringify(value));
+  }
+
+  initialize(): void {
+    super.initialize();
+    const value = this.value;
+    value.text = value.text || '';
+  }
+}
+
+/**
+ *
+ */
+export class Base64Model extends DocumentModel {
+  /**
+   *
+   */
+  constructor(languagePreference?: string, modelDB?: IModelDB) {
+    super('text/plain', languagePreference, modelDB);
+    let value = this.modelDB.createValue('value');
+    value.changed.connect(
+      this.triggerContentChange,
+      this
+    );
+  }
+
+  /**
+   * Get the value of the model.
+   */
+  get value(): IObservableValue {
+    return this.modelDB.get('value') as IObservableValue;
+  }
+
+  toString(): string {
+    return this.value.get() as string;
+  }
+
+  fromString(value: string): void {
+    this.value.set(value);
+  }
+
+  toJSON(): JSONValue {
+    return JSON.parse(this.value.toString() || 'null');
+  }
+
+  fromJSON(value: JSONValue): void {
+    this.fromString(JSON.stringify(value));
+  }
+
+  initialize(): void {
+    super.initialize();
+    const value = this.value;
+    value.set(value.get() || '');
+  }
+}
+
 /**
  * An implementation of a model factory for text files.
  */
@@ -223,7 +393,7 @@ export class TextModelFactory implements DocumentRegistry.CodeModelFactory {
     languagePreference?: string,
     modelDB?: IModelDB
   ): DocumentRegistry.ICodeModel {
-    return new DocumentModel(languagePreference, modelDB);
+    return new TextModel(languagePreference, modelDB);
   }
 
   /**
@@ -234,13 +404,34 @@ export class TextModelFactory implements DocumentRegistry.CodeModelFactory {
     return mode && mode.mode;
   }
 
+  /**
+   * The schemas for the datastore.
+   */
+  get schemas(): ReadonlyArray<Schema> {
+    return [
+      {
+        id: 'TextModelSchema.v1',
+        fields: {
+          value: Fields.Text({ description: 'The text value of the model' }),
+          mimeType: Fields.String({
+            value: 'text/plain',
+            description: 'The MIME type of the text'
+          }),
+          selections: Fields.Map({
+            description: 'A map of all text selections for all users'
+          })
+        }
+      }
+    ];
+  }
+
   private _isDisposed = false;
 }
 
 /**
  * An implementation of a model factory for base64 files.
  */
-export class Base64ModelFactory extends TextModelFactory {
+export class Base64ModelFactory implements DocumentRegistry.ModelFactory {
   /**
    * The name of the model type.
    *
@@ -269,6 +460,60 @@ export class Base64ModelFactory extends TextModelFactory {
   get fileFormat(): Contents.FileFormat {
     return 'base64';
   }
+
+  /**
+   * Get whether the model factory has been disposed.
+   */
+  get isDisposed(): boolean {
+    return this._isDisposed;
+  }
+
+  /**
+   * Dispose of the resources held by the model factory.
+   */
+  dispose(): void {
+    this._isDisposed = true;
+  }
+
+  /**
+   * Create a new model.
+   *
+   * @param languagePreference - An optional kernel language preference.
+   *
+   * @returns A new document model.
+   */
+  createNew(
+    languagePreference?: string,
+    modelDB?: IModelDB
+  ): DocumentRegistry.IModel {
+    return new Base64Model(languagePreference, modelDB);
+  }
+
+  /**
+   * Get the preferred kernel language given a file path.
+   */
+  preferredLanguage(path: string): string {
+    let mode = Mode.findByFileName(path);
+    return mode && mode.mode;
+  }
+
+  /**
+   * The schemas for the datastore.
+   */
+  get schemas(): ReadonlyArray<Schema> {
+    return [
+      {
+        id: 'Base64ModelSchema.v1',
+        fields: {
+          value: Fields.String({
+            description: 'The value of the model'
+          })
+        }
+      }
+    ];
+  }
+
+  private _isDisposed = false;
 }
 
 /**
diff --git a/packages/docregistry/src/registry.ts b/packages/docregistry/src/registry.ts
index a0ee53a030f..25ca4826817 100644
--- a/packages/docregistry/src/registry.ts
+++ b/packages/docregistry/src/registry.ts
@@ -15,6 +15,8 @@ import {
 
 import { JSONValue } from '@phosphor/coreutils';
 
+import { Schema } from '@phosphor/datastore';
+
 import { IDisposable, DisposableDelegate } from '@phosphor/disposable';
 
 import { ISignal, Signal } from '@phosphor/signaling';
@@ -209,6 +211,13 @@ export class DocumentRegistry implements IDisposable {
     });
   }
 
+  addModelDBFactory(name: string, factory: IModelDB.IFactory): IDisposable {
+    this._modelDbFactories[name] = factory;
+    return new DisposableDelegate(() => {
+      delete this._modelDbFactories[name];
+    });
+  }
+
   /**
    * Add a widget extension to the registry.
    *
@@ -407,6 +416,20 @@ export class DocumentRegistry implements IDisposable {
     return this.preferredWidgetFactories(path)[0];
   }
 
+  /**
+   * Get the preferred model DB factory for a path.
+   *
+   * @param path - The path to for which to find a model DB factory.
+   *
+   * @returns The model DB factory for the path.
+   */
+  getModelDBFactory(path: string): IModelDB.IFactory {
+    // TODO: Use some resolution to pick DB factory
+    for (let key in this._modelDbFactories) {
+      return this._modelDbFactories[key];
+    }
+  }
+
   /**
    * Create an iterator over the widget factories that have been registered.
    *
@@ -596,6 +619,9 @@ export class DocumentRegistry implements IDisposable {
     return fts;
   }
 
+  private _modelDbFactories: {
+    [key: string]: IModelDB.IFactory;
+  } = Object.create(null);
   private _modelFactories: {
     [key: string]: DocumentRegistry.ModelFactory;
   } = Object.create(null);
@@ -1042,6 +1068,11 @@ export namespace DocumentRegistry {
      * Get the preferred kernel language given a file path.
      */
     preferredLanguage(path: string): string;
+
+    /**
+     * The schemas for the datastore.
+     */
+    readonly schemas: ReadonlyArray<Schema>;
   }
 
   /**



--- a/packages/notebook/src/celllist.ts
+++ b/packages/notebook/src/celllist.ts
@@ -15,8 +15,6 @@ import { ISignal, Signal } from '@phosphor/signaling';
 import { ICellModel } from '@jupyterlab/cells';
 
 import {
-  IObservableMap,
-  ObservableMap,
   IObservableList,
   IObservableUndoableList,
   IModelDB
@@ -34,7 +32,7 @@ export class CellList implements IObservableUndoableList<ICellModel> {
   constructor(modelDB: IModelDB, factory: NotebookModel.IContentFactory) {
     this._factory = factory;
     this._cellOrder = modelDB.createList<string>('cellOrder');
-    this._cellMap = new ObservableMap<ICellModel>();
+    this._cellMap = new Map();
 
     this._cellOrder.changed.connect(
       this._onOrderChanged,
@@ -126,7 +124,7 @@ export class CellList implements IObservableUndoableList<ICellModel> {
     for (let cell of this._cellMap.values()) {
       cell.dispose();
     }
-    this._cellMap.dispose();
+    this._cellMap.clear();
     this._cellOrder.dispose();
   }
 
@@ -474,8 +472,8 @@ export class CellList implements IObservableUndoableList<ICellModel> {
     if (change.type === 'add' || change.type === 'set') {
       each(change.newValues, id => {
         if (!this._cellMap.has(id)) {
-          let cellDB = this._factory.modelDB;
-          let cellType = cellDB.createValue(id + '.type');
+          let cellDB = this._factory.modelDB.view(id);
+          let cellType = cellDB.createValue('type');
           let cell: ICellModel;
           switch (cellType.get()) {
             case 'code':
@@ -511,7 +509,7 @@ export class CellList implements IObservableUndoableList<ICellModel> {
 
   private _isDisposed: boolean = false;
   private _cellOrder: IObservableUndoableList<string> = null;
-  private _cellMap: IObservableMap<ICellModel> = null;
+  private _cellMap: Map<string, ICellModel> = null;
   private _changed = new Signal<this, IObservableList.IChangedArgs<ICellModel>>(
     this
   );
diff --git a/packages/notebook/src/model.ts b/packages/notebook/src/model.ts
index f472c7b9404..f118b934156 100644
--- a/packages/notebook/src/model.ts
+++ b/packages/notebook/src/model.ts
@@ -69,14 +69,15 @@ export class NotebookModel extends DocumentModel implements INotebookModel {
    * Construct a new notebook model.
    */
   constructor(options: NotebookModel.IOptions = {}) {
-    super(options.languagePreference, options.modelDB);
-    let factory = options.contentFactory || NotebookModel.defaultContentFactory;
+    super(
+      'application/x-ipynb+json',
+      options.languagePreference,
+      options.modelDB
+    );
+    const factory =
+      options.contentFactory || NotebookModel.defaultContentFactory;
     this.contentFactory = factory.clone(this.modelDB.view('cells'));
     this._cells = new CellList(this.modelDB, this.contentFactory);
-    // Add an initial code cell by default.
-    if (!this._cells.length) {
-      this._cells.push(factory.createCodeCell({}));
-    }
     this._cells.changed.connect(
       this._onCellsChanged,
       this
@@ -84,11 +85,6 @@ export class NotebookModel extends DocumentModel implements INotebookModel {
 
     // Handle initial metadata.
     let metadata = this.modelDB.createMap('metadata');
-    if (!metadata.has('language_info')) {
-      let name = options.languagePreference || '';
-      metadata.set('language_info', { name });
-    }
-    this._ensureMetadata();
     metadata.changed.connect(
       this.triggerContentChange,
       this
@@ -212,54 +208,59 @@ export class NotebookModel extends DocumentModel implements INotebookModel {
    * Should emit a [contentChanged] signal.
    */
   fromJSON(value: nbformat.INotebookContent): void {
-    let cells: ICellModel[] = [];
-    let factory = this.contentFactory;
-    for (let cell of value.cells) {
-      switch (cell.cell_type) {
-        case 'code':
-          cells.push(factory.createCodeCell({ cell }));
-          break;
-        case 'markdown':
-          cells.push(factory.createMarkdownCell({ cell }));
-          break;
-        case 'raw':
-          cells.push(factory.createRawCell({ cell }));
-          break;
-        default:
+    this.modelDB.withTransaction(() => {
+      let oldValue = 0;
+      let newValue = 0;
+      this._nbformatMinor = nbformat.MINOR_VERSION;
+      this._nbformat = nbformat.MAJOR_VERSION;
+
+      if (value.nbformat !== this._nbformat) {
+        oldValue = this._nbformat;
+        this._nbformat = newValue = value.nbformat;
+        this.triggerStateChange({ name: 'nbformat', oldValue, newValue });
+      }
+      if (value.nbformat_minor > this._nbformatMinor) {
+        oldValue = this._nbformatMinor;
+        this._nbformatMinor = newValue = value.nbformat_minor;
+        this.triggerStateChange({ name: 'nbformatMinor', oldValue, newValue });
+      }
+      // Update the metadata.
+      this.metadata.clear();
+      let metadata = value.metadata;
+      for (let key in metadata) {
+        // orig_nbformat is not intended to be stored per spec.
+        if (key === 'orig_nbformat') {
           continue;
+        }
+        this.metadata.set(key, metadata[key]);
       }
-    }
-    this.cells.beginCompoundOperation();
-    this.cells.clear();
-    this.cells.pushAll(cells);
-    this.cells.endCompoundOperation();
-
-    let oldValue = 0;
-    let newValue = 0;
-    this._nbformatMinor = nbformat.MINOR_VERSION;
-    this._nbformat = nbformat.MAJOR_VERSION;
-
-    if (value.nbformat !== this._nbformat) {
-      oldValue = this._nbformat;
-      this._nbformat = newValue = value.nbformat;
-      this.triggerStateChange({ name: 'nbformat', oldValue, newValue });
-    }
-    if (value.nbformat_minor > this._nbformatMinor) {
-      oldValue = this._nbformatMinor;
-      this._nbformatMinor = newValue = value.nbformat_minor;
-      this.triggerStateChange({ name: 'nbformatMinor', oldValue, newValue });
-    }
-    // Update the metadata.
-    this.metadata.clear();
-    let metadata = value.metadata;
-    for (let key in metadata) {
-      // orig_nbformat is not intended to be stored per spec.
-      if (key === 'orig_nbformat') {
-        continue;
+      this._ensureMetadata();
+    });
+
+    let cells: ICellModel[] = [];
+    this.modelDB.withTransaction((transactionId?: string) => {
+      let factory = this.contentFactory;
+      for (let cell of value.cells) {
+        switch (cell.cell_type) {
+          case 'code':
+            cells.push(factory.createCodeCell({ cell }));
+            break;
+          case 'markdown':
+            cells.push(factory.createMarkdownCell({ cell }));
+            break;
+          case 'raw':
+            cells.push(factory.createRawCell({ cell }));
+            break;
+          default:
+            continue;
+        }
       }
-      this.metadata.set(key, metadata[key]);
-    }
-    this._ensureMetadata();
+
+      this.cells.beginCompoundOperation();
+      this.cells.clear();
+      this.cells.pushAll(cells);
+      this.cells.endCompoundOperation();
+    });
     this.dirty = true;
   }
 
@@ -267,8 +268,21 @@ export class NotebookModel extends DocumentModel implements INotebookModel {
    * Initialize the model with its current state.
    */
   initialize(): void {
-    super.initialize();
-    this.cells.clearUndo();
+    this.modelDB.withTransaction(() => {
+      super.initialize();
+      // Add an initial code cell by default.
+      if (!this._cells.length && !this.modelDB.isPrepopulated) {
+        this._cells.push(this.contentFactory.createCodeCell({}));
+      }
+
+      const metadata = this.metadata;
+      if (!metadata.has('language_info')) {
+        const name = this.defaultKernelLanguage;
+        metadata.set('language_info', { name });
+      }
+      this._ensureMetadata();
+      this.cells.clearUndo();
+    });
   }
 
   /**
@@ -307,7 +321,9 @@ export class NotebookModel extends DocumentModel implements INotebookModel {
       // cell changed event during the handling of this signal.
       requestAnimationFrame(() => {
         if (!this.isDisposed && !this.cells.length) {
-          this.cells.push(factory.createCodeCell({}));
+          this.modelDB.withTransaction(() => {
+            this.cells.push(factory.createCodeCell({}));
+          });
         }
       });
     }
@@ -443,7 +459,7 @@ export namespace NotebookModel {
      *   `codeCellContentFactory` will be used.
      */
     createCodeCell(options: CodeCellModel.IOptions): ICodeCellModel {
-      if (options.contentFactory) {
+      if (!options.contentFactory) {
         options.contentFactory = this.codeCellContentFactory;
       }
       if (this.modelDB) {
@@ -451,6 +467,11 @@ export namespace NotebookModel {
           options.id = UUID.uuid4();
         }
         options.modelDB = this.modelDB.view(options.id);
+        let cell;
+        this.modelDB.withTransaction(() => {
+          cell = new CodeCellModel(options);
+        });
+        return cell;
       }
       return new CodeCellModel(options);
     }
@@ -469,6 +490,11 @@ export namespace NotebookModel {
           options.id = UUID.uuid4();
         }
         options.modelDB = this.modelDB.view(options.id);
+        let cell;
+        this.modelDB.withTransaction(() => {
+          cell = new MarkdownCellModel(options);
+        });
+        return cell;
       }
       return new MarkdownCellModel(options);
     }
@@ -487,6 +513,11 @@ export namespace NotebookModel {
           options.id = UUID.uuid4();
         }
         options.modelDB = this.modelDB.view(options.id);
+        let cell;
+        this.modelDB.withTransaction(() => {
+          cell = new RawCellModel(options);
+        });
+        return cell;
       }
       return new RawCellModel(options);
     }
diff --git a/packages/notebook/src/modelfactory.ts b/packages/notebook/src/modelfactory.ts
index 8f4c395d05f..bde15e9fd1c 100644
--- a/packages/notebook/src/modelfactory.ts
+++ b/packages/notebook/src/modelfactory.ts
@@ -1,6 +1,8 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
+import { Schema, Fields } from '@phosphor/datastore';
+
 import { CodeCellModel } from '@jupyterlab/cells';
 
 import { DocumentRegistry } from '@jupyterlab/docregistry';
@@ -85,6 +87,47 @@ export class NotebookModelFactory
     return '';
   }
 
+  get schemas(): ReadonlyArray<Schema> {
+    return [
+      {
+        id: 'NotebookModelSchema.v1',
+        fields: {
+          mimeType: Fields.String(),
+          metadata: Fields.Map(),
+          cellOrder: Fields.List<string>()
+        }
+      },
+      {
+        id: 'NotebookModelSchema.v1.cells',
+        fields: {
+          // General fields for cells:
+          type: Fields.String(),
+          metadata: Fields.Map(),
+          trusted: Fields.Boolean(),
+
+          // Fields for editable models:
+          value: Fields.Text({
+            description: 'The text value of the model'
+          }),
+          mimeType: Fields.String({
+            value: 'text/plain',
+            description: 'The MIME type of the text'
+          }),
+          selections: Fields.Map({
+            description: 'A map of all text selections for all users'
+          }),
+
+          // Code cell specific:
+          executionCount: Fields.Register<number | null>({ value: null }),
+          outputs: Fields.String(),
+
+          // Cells with attachments (md/raw):
+          attachments: Fields.String()
+        }
+      }
+    ];
+  }
+
   private _disposed = false;
 }
 
diff --git a/packages/notebook/src/widget.ts b/packages/notebook/src/widget.ts
index cce6c4b279d..de01d9a7cbf 100644
--- a/packages/notebook/src/widget.ts
+++ b/packages/notebook/src/widget.ts
@@ -217,6 +217,9 @@ export class StaticNotebook extends Widget {
 
     if (oldValue && oldValue.modelDB.isCollaborative) {
       oldValue.modelDB.connected.then(() => {
+        if (!oldValue.modelDB.collaborators) {
+          return;
+        }
         oldValue.modelDB.collaborators.changed.disconnect(
           this._onCollaboratorsChanged,
           this
@@ -225,6 +228,9 @@ export class StaticNotebook extends Widget {
     }
     if (newValue && newValue.modelDB.isCollaborative) {
       newValue.modelDB.connected.then(() => {
+        if (!newValue.modelDB.collaborators) {
+          return;
+        }
         newValue.modelDB.collaborators.changed.connect(
           this._onCollaboratorsChanged,
           this
@@ -1403,7 +1409,7 @@ export class Notebook extends StaticNotebook {
     if (this.model && this.model.modelDB.isCollaborative) {
       let modelDB = this.model.modelDB;
       modelDB.connected.then(() => {
-        if (!cell.isDisposed) {
+        if (!cell.isDisposed && modelDB.collaborators) {
           // Setup the selection style for collaborators.
           let localCollaborator = modelDB.collaborators.localCollaborator;
           cell.editor.uuid = localCollaborator.sessionId;


diff --git a/packages/observables/src/modeldb.ts b/packages/observables/src/modeldb.ts
index 2593339fe7f..e026d2f1594 100644
--- a/packages/observables/src/modeldb.ts
+++ b/packages/observables/src/modeldb.ts
@@ -3,9 +3,11 @@
 
 import { IDisposable, DisposableSet } from '@phosphor/disposable';
 
+import { Schema } from '@phosphor/datastore';
+
 import { ISignal, Signal } from '@phosphor/signaling';
 
-import { JSONExt, JSONValue, JSONObject } from '@phosphor/coreutils';
+import { JSONExt, JSONObject, ReadonlyJSONValue } from '@phosphor/coreutils';
 
 import { ObservableMap } from './observablemap';
 
@@ -49,17 +51,37 @@ export interface IObservableValue extends IObservable {
   /**
    * The changed signal.
    */
-  readonly changed: ISignal<IObservableValue, ObservableValue.IChangedArgs>;
+  readonly changed: ISignal<IObservableValue, IObservableValue.IChangedArgs>;
 
   /**
    * Get the current value, or `undefined` if it has not been set.
    */
-  get(): JSONValue | undefined;
+  get(): ReadonlyJSONValue | undefined;
 
   /**
    * Set the value.
    */
-  set(value: JSONValue): void;
+  set(value: ReadonlyJSONValue): void;
+}
+
+/**
+ * The namespace for the `ObservableValue` class statics.
+ */
+export namespace IObservableValue {
+  /**
+   * The changed args object emitted by the `IObservableValue`.
+   */
+  export class IChangedArgs {
+    /**
+     * The old value.
+     */
+    oldValue: ReadonlyJSONValue | undefined;
+
+    /**
+     * The new value.
+     */
+    newValue: ReadonlyJSONValue | undefined;
+  }
 }
 
 /**
@@ -188,7 +210,9 @@ export interface IModelDB extends IDisposable {
    * The list can only store objects that are simple
    * JSON Objects and primitives.
    */
-  createList<T extends JSONValue>(path: string): IObservableUndoableList<T>;
+  createList<T extends ReadonlyJSONValue>(
+    path: string
+  ): IObservableUndoableList<T>;
 
   /**
    * Create a map and insert it in the database.
@@ -218,7 +242,7 @@ export interface IModelDB extends IDisposable {
    *
    * @param path: the path for the value.
    */
-  getValue(path: string): JSONValue | undefined;
+  getValue(path: string): ReadonlyJSONValue | undefined;
 
   /**
    * Set a value at a path. That value must already have
@@ -228,7 +252,7 @@ export interface IModelDB extends IDisposable {
    *
    * @param value: the new value.
    */
-  setValue(path: string, value: JSONValue): void;
+  setValue(path: string, value: ReadonlyJSONValue): void;
 
   /**
    * Create a view onto a subtree of the model database.
@@ -240,12 +264,34 @@ export interface IModelDB extends IDisposable {
    */
   view(basePath: string): IModelDB;
 
+  /**
+   * Run a funcion where all changes become part of a transaction.
+   * @param fn: the function to run. It recevies the transaction id
+   *            as an argument.
+   */
+  withTransaction(fn: (transactionId?: string) => void): void;
+
   /**
    * Dispose of the resources held by the database.
    */
   dispose(): void;
 }
 
+/**
+ * A namespace for the `IModelDB` interface.
+ */
+export namespace IModelDB {
+  /**
+   * A factory interface for creating `IModelDB` objects.
+   */
+  export interface IFactory {
+    /**
+     * Create a new `IModelDB` instance.
+     */
+    createNew(path: string, schemas: ReadonlyArray<Schema>): IModelDB;
+  }
+}
+
 /**
  * A concrete implementation of an `IObservableValue`.
  */
@@ -255,7 +301,7 @@ export class ObservableValue implements IObservableValue {
    *
    * @param initialValue: the starting value for the `ObservableValue`.
    */
-  constructor(initialValue: JSONValue = null) {
+  constructor(initialValue: ReadonlyJSONValue = null) {
     this._value = initialValue;
   }
 
@@ -276,21 +322,21 @@ export class ObservableValue implements IObservableValue {
   /**
    * The changed signal.
    */
-  get changed(): ISignal<this, ObservableValue.IChangedArgs> {
+  get changed(): ISignal<this, IObservableValue.IChangedArgs> {
     return this._changed;
   }
 
   /**
    * Get the current value, or `undefined` if it has not been set.
    */
-  get(): JSONValue {
+  get(): ReadonlyJSONValue {
     return this._value;
   }
 
   /**
    * Set the current value.
    */
-  set(value: JSONValue): void {
+  set(value: ReadonlyJSONValue): void {
     let oldValue = this._value;
     if (JSONExt.deepEqual(oldValue, value)) {
       return;
@@ -314,31 +360,11 @@ export class ObservableValue implements IObservableValue {
     this._value = null;
   }
 
-  private _value: JSONValue = null;
-  private _changed = new Signal<this, ObservableValue.IChangedArgs>(this);
+  private _value: ReadonlyJSONValue = null;
+  private _changed = new Signal<this, IObservableValue.IChangedArgs>(this);
   private _isDisposed = false;
 }
 
-/**
- * The namespace for the `ObservableValue` class statics.
- */
-export namespace ObservableValue {
-  /**
-   * The changed args object emitted by the `IObservableValue`.
-   */
-  export class IChangedArgs {
-    /**
-     * The old value.
-     */
-    oldValue: JSONValue | undefined;
-
-    /**
-     * The new value.
-     */
-    newValue: JSONValue | undefined;
-  }
-}
-
 /**
  * A concrete implementation of an `IModelDB`.
  */
@@ -437,7 +463,9 @@ export class ModelDB implements IModelDB {
    * The list can only store objects that are simple
    * JSON Objects and primitives.
    */
-  createList<T extends JSONValue>(path: string): IObservableUndoableList<T> {
+  createList<T extends ReadonlyJSONValue>(
+    path: string
+  ): IObservableUndoableList<T> {
     let vec = new ObservableUndoableList<T>(
       new ObservableUndoableList.IdentitySerializer<T>()
     );
@@ -484,7 +512,7 @@ export class ModelDB implements IModelDB {
    *
    * @param path: the path for the value.
    */
-  getValue(path: string): JSONValue | undefined {
+  getValue(path: string): ReadonlyJSONValue | undefined {
     let val = this.get(path);
     if (!val || val.type !== 'Value') {
       throw Error('Can only call getValue for an ObservableValue');
@@ -500,7 +528,7 @@ export class ModelDB implements IModelDB {
    *
    * @param value: the new value.
    */
-  setValue(path: string, value: JSONValue): void {
+  setValue(path: string, value: ReadonlyJSONValue): void {
     let val = this.get(path);
     if (!val || val.type !== 'Value') {
       throw Error('Can only call setValue on an ObservableValue');
@@ -535,6 +563,15 @@ export class ModelDB implements IModelDB {
     this._db.set(this._resolvePath(path), value);
   }
 
+  /**
+   * Run a funcion where all changes become part of a transaction.
+   * @param fn: the function to run. It recevies the transaction id
+   *            as an argument.
+   */
+  withTransaction(fn: (transactionId?: string) => void): void {
+    fn();
+  }
+
   /**
    * Dispose of the resources held by the database.
    */
@@ -585,14 +622,4 @@ export namespace ModelDB {
      */
     baseDB?: ModelDB;
   }
-
-  /**
-   * A factory interface for creating `IModelDB` objects.
-   */
-  export interface IFactory {
-    /**
-     * Create a new `IModelDB` instance.
-     */
-    createNew(path: string): IModelDB;
-  }
 }
diff --git a/packages/observables/src/observablelist.ts b/packages/observables/src/observablelist.ts
index e1aed85b7ba..97e9af95ef3 100644
--- a/packages/observables/src/observablelist.ts
+++ b/packages/observables/src/observablelist.ts
@@ -285,7 +285,7 @@ export namespace IObservableList {
      * #### Notes
      * The values will be contiguous starting at the `newIndex`.
      */
-    newValues: T[];
+    newValues: ReadonlyArray<T>;
 
     /**
      * The old index associated with the change.
@@ -298,7 +298,7 @@ export namespace IObservableList {
      * #### Notes
      * The values will be contiguous starting at the `oldIndex`.
      */
-    oldValues: T[];
+    oldValues: ReadonlyArray<T>;
   }
 }
 
diff --git a/packages/observables/src/observablestring.ts b/packages/observables/src/observablestring.ts
index 19ed4a08e21..f3134759258 100644
--- a/packages/observables/src/observablestring.ts
+++ b/packages/observables/src/observablestring.ts
@@ -24,7 +24,7 @@ export interface IObservableString extends IDisposable, IObservable {
   /**
    * The value of the string.
    */
-  text: string;
+  text: string | undefined;
 
   /**
    * Insert a substring.
diff --git a/packages/observables/src/undoablelist.ts b/packages/observables/src/undoablelist.ts
index 99d3a525cf3..6346039776a 100644
--- a/packages/observables/src/undoablelist.ts
+++ b/packages/observables/src/undoablelist.ts
@@ -1,7 +1,7 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { JSONValue } from '@phosphor/coreutils';
+import { ReadonlyJSONValue } from '@phosphor/coreutils';
 
 import { each } from '@phosphor/algorithm';
 
@@ -15,12 +15,12 @@ export interface ISerializer<T> {
   /**
    * Convert the object to JSON.
    */
-  toJSON(value: T): JSONValue;
+  toJSON(value: T): ReadonlyJSONValue;
 
   /**
    * Deserialize the object from JSON.
    */
-  fromJSON(value: JSONValue): T;
+  fromJSON(value: ReadonlyJSONValue): T;
 }
 
 /**
@@ -193,7 +193,9 @@ export class ObservableUndoableList<T> extends ObservableList<T>
   /**
    * Undo a change event.
    */
-  private _undoChange(change: IObservableList.IChangedArgs<JSONValue>): void {
+  private _undoChange(
+    change: IObservableList.IChangedArgs<ReadonlyJSONValue>
+  ): void {
     let index = 0;
     let serializer = this._serializer;
     switch (change.type) {
@@ -225,7 +227,9 @@ export class ObservableUndoableList<T> extends ObservableList<T>
   /**
    * Redo a change event.
    */
-  private _redoChange(change: IObservableList.IChangedArgs<JSONValue>): void {
+  private _redoChange(
+    change: IObservableList.IChangedArgs<ReadonlyJSONValue>
+  ): void {
     let index = 0;
     let serializer = this._serializer;
     switch (change.type) {
@@ -259,12 +263,12 @@ export class ObservableUndoableList<T> extends ObservableList<T>
    */
   private _copyChange(
     change: IObservableList.IChangedArgs<T>
-  ): IObservableList.IChangedArgs<JSONValue> {
-    let oldValues: JSONValue[] = [];
+  ): IObservableList.IChangedArgs<ReadonlyJSONValue> {
+    let oldValues: ReadonlyJSONValue[] = [];
     each(change.oldValues, value => {
       oldValues.push(this._serializer.toJSON(value));
     });
-    let newValues: JSONValue[] = [];
+    let newValues: ReadonlyJSONValue[] = [];
     each(change.newValues, value => {
       newValues.push(this._serializer.toJSON(value));
     });
@@ -281,7 +285,7 @@ export class ObservableUndoableList<T> extends ObservableList<T>
   private _isUndoable = true;
   private _madeCompoundChange = false;
   private _index = -1;
-  private _stack: IObservableList.IChangedArgs<JSONValue>[][] = [];
+  private _stack: IObservableList.IChangedArgs<ReadonlyJSONValue>[][] = [];
   private _serializer: ISerializer<T>;
 }
 
@@ -292,19 +296,19 @@ export namespace ObservableUndoableList {
   /**
    * A default, identity serializer.
    */
-  export class IdentitySerializer<T extends JSONValue>
+  export class IdentitySerializer<T extends ReadonlyJSONValue>
     implements ISerializer<T> {
     /**
      * Identity serialize.
      */
-    toJSON(value: T): JSONValue {
+    toJSON(value: T): ReadonlyJSONValue {
       return value;
     }
 
     /**
      * Identity deserialize.
      */
-    fromJSON(value: JSONValue): T {
+    fromJSON(value: ReadonlyJSONValue): T {
       return value as T;
     }
   }
diff --git a/packages/outputarea/src/model.ts b/packages/outputarea/src/model.ts
index 2f41453fc15..a5fb0d9c81d 100644
--- a/packages/outputarea/src/model.ts
+++ b/packages/outputarea/src/model.ts
@@ -13,7 +13,6 @@ import {
   IObservableList,
   ObservableList,
   IObservableValue,
-  ObservableValue,
   IModelDB
 } from '@jupyterlab/observables';
 
@@ -449,7 +448,7 @@ export class OutputAreaModel implements IOutputAreaModel {
    */
   private _onSerializedChanged(
     sender: IObservableValue,
-    args: ObservableValue.IChangedArgs
+    args: IObservableValue.IChangedArgs
   ) {
     if (!this._changeGuard) {
       this._changeGuard = true;
diff --git a/packages/services/src/contents/index.ts b/packages/services/src/contents/index.ts
index 758795ce674..7fe530efc92 100644
--- a/packages/services/src/contents/index.ts
+++ b/packages/services/src/contents/index.ts
@@ -3,8 +3,6 @@
 
 import { URLExt, PathExt } from '@jupyterlab/coreutils';
 
-import { ModelDB } from '@jupyterlab/observables';
-
 import { JSONObject } from '@phosphor/coreutils';
 
 import { each } from '@phosphor/algorithm';
@@ -242,13 +240,6 @@ export namespace Contents {
      */
     driveName(path: string): string;
 
-    /**
-     * Given a path, get a ModelDB.IFactory from the
-     * relevant backend. Returns `null` if the backend
-     * does not provide one.
-     */
-    getModelDBFactory(path: string): ModelDB.IFactory | null;
-
     /**
      * Get a file or directory.
      *
@@ -382,12 +373,6 @@ export namespace Contents {
      */
     readonly serverSettings: ServerConnection.ISettings;
 
-    /**
-     * An optional ModelDB.IFactory instance for the
-     * drive.
-     */
-    readonly modelDBFactory?: ModelDB.IFactory;
-
     /**
      * A signal emitted when a file operation takes place.
      */
@@ -576,16 +561,6 @@ export class ContentsManager implements Contents.IManager {
     );
   }
 
-  /**
-   * Given a path, get a ModelDB.IFactory from the
-   * relevant backend. Returns `null` if the backend
-   * does not provide one.
-   */
-  getModelDBFactory(path: string): ModelDB.IFactory | null {
-    let [drive] = this._driveForPath(path);
-    return (drive && drive.modelDBFactory) || null;
-  }
-
   /**
    * Given a path of the form `drive:local/portion/of/it.txt`
    * get the local part of it.

