diff --git a/dev_mode/package.json b/dev_mode/package.json
index 4d5ce9e0352..2c9fb50bc77 100644
--- a/dev_mode/package.json
+++ b/dev_mode/package.json
@@ -28,6 +28,8 @@
     "@jupyterlab/coreutils": "^3.0.0-alpha.3",
     "@jupyterlab/csvviewer": "^1.0.0-alpha.3",
     "@jupyterlab/csvviewer-extension": "^1.0.0-alpha.3",
+    "@jupyterlab/datastore": "^1.0.0-alpha.3",
+    "@jupyterlab/datastore-extension": "^1.0.0-alpha.3",
     "@jupyterlab/docmanager": "^1.0.0-alpha.3",
     "@jupyterlab/docmanager-extension": "^1.0.0-alpha.3",
     "@jupyterlab/docregistry": "^1.0.0-alpha.3",
@@ -148,6 +150,7 @@
       "@jupyterlab/completer-extension": "",
       "@jupyterlab/console-extension": "",
       "@jupyterlab/csvviewer-extension": "",
+      "@jupyterlab/datastore-extension": "",
       "@jupyterlab/docmanager-extension": "",
       "@jupyterlab/documentsearch-extension": "",
       "@jupyterlab/extensionmanager-extension": "",
@@ -251,6 +254,8 @@
       "@jupyterlab/coreutils": "../packages/coreutils",
       "@jupyterlab/csvviewer": "../packages/csvviewer",
       "@jupyterlab/csvviewer-extension": "../packages/csvviewer-extension",
+      "@jupyterlab/datastore": "../packages/datastore",
+      "@jupyterlab/datastore-extension": "../packages/datastore-extension",
       "@jupyterlab/docmanager": "../packages/docmanager",
       "@jupyterlab/docmanager-extension": "../packages/docmanager-extension",
       "@jupyterlab/docregistry": "../packages/docregistry",
diff --git a/jupyterlab/commands.py b/jupyterlab/commands.py
index 812fcaec627..b346b20a912 100644
--- a/jupyterlab/commands.py
+++ b/jupyterlab/commands.py
@@ -1396,8 +1396,8 @@ def sort_key(key_value):
         with TemporaryDirectory() as tempdir:
             ret = self._run([which('npm'), 'pack'] + keys, cwd=tempdir, quiet=True)
             if ret != 0:
-                msg = '"%s" is not a valid npm package'
-                raise ValueError(msg % keys)
+                msg = 'One or more packages is not a valid npm package: %r'
+                raise ValueError(msg % (keys,))
 
             for key in keys:
                 fname = key[0].replace('@', '') + key[1:].replace('@', '-').replace('/', '-') + '.tgz'
diff --git a/jupyterlab/datastore/__init__.py b/jupyterlab/datastore/__init__.py
new file mode 100644
index 00000000000..a7b14434476
--- /dev/null
+++ b/jupyterlab/datastore/__init__.py
@@ -0,0 +1,5 @@
+
+from .handler import (
+    CollaborationHandler, collaboration_path,
+    CollaborationsManagerHandler, datastore_rest_path
+)
diff --git a/jupyterlab/datastore/collaboration.py b/jupyterlab/datastore/collaboration.py
new file mode 100644
index 00000000000..98c98d6ed66
--- /dev/null
+++ b/jupyterlab/datastore/collaboration.py
@@ -0,0 +1,88 @@
+
+import collections
+import json
+
+from tornado.ioloop import IOLoop
+
+from .db import DatastoreDB
+from .messages import (
+    create_transaction_broadcast,
+    create_stable_state_broadcast
+)
+
+
+class Collaboration:
+
+    def __init__(self, collaboration_id, db_file, friendly_name=None):
+        self.id = collaboration_id
+        self.db = DatastoreDB(f'collab-{collaboration_id}', db_file)
+        self.friendly_name = friendly_name or collaboration_id
+
+        self.last_serial = None
+
+        self._store_id_serial = 0
+        self._lastStable = -1
+
+        self._handlers = {}
+        self._dangling_handlers = {}
+        self._serials = collections.defaultdict(lambda: -1)
+
+    def add_client(self, handler):
+        self._store_id_serial += 1
+        store_id = self._store_id_serial
+        self._handlers[store_id] = handler
+        return store_id
+
+    def remove_client(self, handler):
+        store_id = handler.store_id
+        del self._handlers[store_id]
+        del self._serials[store_id]
+
+    @property
+    def has_clients(self):
+        return bool(self._handlers)
+
+    def close(self):
+        self.db.close()
+        for h in self._handlers.values():
+            h.close(1001)
+        self._handlers = {}
+
+    def broadcast_transactions(self, source, transactions, serials):
+        message = create_transaction_broadcast(transactions, serials)
+        self.broadcast_message(message, source)
+        self.last_serial = max(serials.values())
+        self.update_serial(source.store_id, self.last_serial)
+
+    def broadcast_message(self, message, exclude_handler=None):
+        for handler in self._handlers.values():
+            if handler is exclude_handler or not handler.history_inited:
+                continue
+            handler.write_message(json.dumps(message))
+
+    def mark_dangling(self, store_id, timeout, callback):
+        loop = IOLoop.current()
+        timer = loop.add_timeout(loop.time() + timeout, callback)
+        self._dangling_handlers[store_id] = timer
+
+    def forget_dangling(self, store_id):
+        timer = self._dangling_handlers.pop(store_id)
+        loop = IOLoop.current()
+        loop.remove_timeout(timer)
+
+    def is_dangling(self, store_id):
+        return store_id in self._dangling_handlers
+
+    def update_serial(self, store_id, serial):
+        # We can never go back:
+        self._serials[store_id] = max(serial, self._serials[store_id])
+        stable = min(
+            self._serials[handler.store_id]
+            for handler in self._handlers.values()
+            if handler.history_inited
+        )
+        if stable > self._lastStable:
+            if len(self._serials) > 1:
+                msg = create_stable_state_broadcast(stable)
+                self.broadcast_message(msg)
+            self._lastStable = stable
diff --git a/jupyterlab/datastore/db.py b/jupyterlab/datastore/db.py
new file mode 100644
index 00000000000..3726cdd9254
--- /dev/null
+++ b/jupyterlab/datastore/db.py
@@ -0,0 +1,241 @@
+
+import collections
+from itertools import chain
+import json
+import sqlite3
+import re
+
+
+sqlite3.enable_callback_tracebacks(True)
+
+def serialized(transactions):
+    for t in transactions:
+        yield (
+            t['id'],
+            t['storeId'],
+            json.dumps(t['patch']).encode('ascii'),
+            t['version'],
+        )
+
+def deserialized(rows):
+    for r in rows:
+        yield dict(
+            id=r[0],
+            storeId=r[1],
+            patch=json.loads(r[2], encoding='ascii'),
+            version=r[3],
+            serial=r[4],
+        )
+
+def decode_serials(rows):
+    for r in rows:
+        yield r[0:2]
+
+
+History = collections.namedtuple('History', ('state', 'transactions'))
+
+
+_table_name_re = re.compile(r'[a-zA-Z][a-zA-Z0-9_\-]*')
+
+def validate_table_name(name):
+    if _table_name_re.fullmatch(name) is None or name.startswith('checkpoints'):
+        raise ValueError('Invalid table name %r' % (name,))
+
+
+class DatastoreDB:
+
+    def __init__(self, table_name, db_file=None):
+        # first, validate table name
+        validate_table_name(table_name)
+        self._table_name = table_name
+        self._transactions = []
+        self._conn = sqlite3.connect(
+            db_file or ':memory:',
+            detect_types=sqlite3.PARSE_DECLTYPES
+        )
+        self.checkpoint_id = 0
+        self._setup_db()
+
+    def close(self):
+        """Clean up resources"""
+        self._conn.close()
+
+    def _setup_db(self):
+        """Set up the database tables and constraints"""
+        c = self._conn
+
+        with c:
+            # Create table for transactions
+            c.execute('''
+                CREATE TABLE IF NOT EXISTS
+                [{0}] (
+                    id text NOT NULL UNIQUE ON CONFLICT IGNORE,
+                    storeId integer,
+                    patch json,
+                    version integer
+                )
+                '''.format(self._table_name)
+            )
+            # Create table for checkpoints
+            c.execute('''
+                CREATE TABLE IF NOT EXISTS
+                [checkpoints-{0}] (
+                    id integer PRIMARY KEY ON CONFLICT REPLACE,
+                    state text,
+                    serial integer
+                )
+                '''.format(self._table_name)
+            )
+
+    def add_transactions(self, transactions):
+        """Add a sequence of transactions to the store.
+
+        Returns a dictionary mapping the ids of the passed transactions
+        to their serial numbers.
+
+        Note: Any transactions with ids already present in the store
+        will be ignored. Their existing serial number will still be present
+        in the returned dictionary.
+        """
+        c = self._conn
+        with c:
+            # Use executemany with dict lookup to insert
+            # Note: The 'ON CONFLICT IGNORE' on the id assures
+            # that duplicate transactions are discarded.
+            c.executemany(
+                '''
+                    INSERT INTO [{0}](id, storeId, patch, version)
+                    VALUES(?, ?, ?, ?)
+                '''.format(self._table_name),
+                serialized(transactions)
+            )
+
+            ids = [t['id'] for t in transactions]
+            subst = ','.join('?' * len(ids))
+
+            return dict(decode_serials(
+                c.execute(
+                    '''
+                        SELECT id, rowid
+                        FROM [{0}]
+                        WHERE id IN ({1})
+                    '''.format(self._table_name, subst),
+                    ids
+                )
+            ))
+
+    def get_transactions(self, ids):
+        """Get the transactions with the given ids.
+
+        Yields transactions in the store that match the given ids. Note that
+        any missing ids will simply not be included in the result.
+        """
+        subst = ','.join('?' * len(ids))
+        statement = '''
+            SELECT id, storeId, patch, version, rowid
+            FROM (
+                SELECT *
+                FROM [{0}]
+                WHERE id IN ({1})
+                ORDER BY rowid
+            )
+        '''.format(self._table_name, subst)
+
+        yield from deserialized(
+            self._conn.execute(statement, ids)
+        )
+
+    def get_serials(self, serials):
+        """Get the transactions with the given serials.
+
+        Yields transactions in the store that match the given serials. Note
+        that any missing serials will simply not be included in the result.
+        """
+        subst = ','.join('?' * len(serials))
+        statement = '''
+            SELECT id, storeId, patch, version, rowid
+            FROM (
+                SELECT *
+                FROM [{0}]
+                WHERE rowid IN ({1})
+                ORDER BY rowid
+            )
+        '''.format(self._table_name, subst)
+
+        yield from deserialized(
+            self._conn.execute(statement, serials)
+        )
+
+    def has_transactions(self, ids):
+        """Whether the transactions with the given ids exist in the db.
+
+        Returns a generator of booleans indicating the prescence of the
+        given ids.
+        """
+        ids = tuple(ids)
+        subst = ','.join('?' * len(ids))
+        statement = '''
+            SELECT id
+            FROM [{0}]
+            WHERE id IN ({1})
+        '''.format(self._table_name, subst)
+
+        present = set(r[0] for r in self._conn.execute(statement, ids))
+        return (i in present for i in ids)
+
+    def make_checkpoint(self, state, serial):
+        """Make a checkpoint in the transaction history.
+
+        This creates a new checkpoint after the given serial
+        with the given serialized state.
+        """
+
+        # Insert the base for the new checkpoint into the checkpoint table
+        self._conn.execute(
+            '''
+                INSERT INTO [checkpoints-{0}](id, state, serial)
+                VALUES(?, ?)
+            '''.format(self._table_name),
+            (self.checkpoint_id, state, serial)
+        )
+        self.checkpoint_id += 1
+
+    def history(self, checkpoint_id=None):
+        """Get the history for the given checkpoint id (in order).
+
+        If the checkpoint id is not given, returns the full history
+        since the start.
+
+        Returns a namedtuple (state, transactions), with tranascations
+        being an iterator of the transactions.
+        """
+        if checkpoint_id is None:
+            serial = -1
+            state = None
+        else:
+            serial, state = tuple(next(self._conn.execute(
+                '''
+                    SELECT serial, state, id
+                    FROM [checkpoints-{0}]
+                    WHERE id = ?
+                    LIMIT 1
+                '''.format(self._table_name),
+                (checkpoint_id,)
+            ), (-1, None)))[0:2]
+
+        transactions = deserialized(
+            self._conn.execute(
+                '''
+                    SELECT id, storeId, patch, version, rowid
+                    FROM [{0}]
+                    WHERE rowid > ?
+                    ORDER BY rowid
+                '''.format(self._table_name),
+                (serial,)
+            )
+        )
+
+        return History(state, transactions)
+
+
+__all__ = ['DatastoreDB']
diff --git a/jupyterlab/datastore/handler.py b/jupyterlab/datastore/handler.py
new file mode 100644
index 00000000000..f29ffbb0460
--- /dev/null
+++ b/jupyterlab/datastore/handler.py
@@ -0,0 +1,330 @@
+
+from itertools import tee
+import json
+import os
+import uuid
+
+from notebook.base.handlers import IPythonHandler
+from notebook.base.zmqhandlers import WebSocketMixin
+from tornado import gen, web
+from tornado.concurrent import Future
+from tornado.ioloop import IOLoop
+from tornado.websocket import WebSocketHandler
+
+from .messages import (
+    create_error_reply,
+    create_history_reply,
+    create_permissions_reply,
+    create_serial_reply,
+    create_storeid_reply,
+    create_transaction_reply,
+    create_transactions_ack
+)
+from .collaboration import Collaboration
+
+
+def filter_duplicates(transactions, is_duplicate):
+    for (t, d) in zip(transactions, is_duplicate):
+        if not d:
+            yield t
+
+
+
+class DefaultDatastoreAuth:
+    """Default implementation of a datastore authenticator."""
+
+    def check_permissions(self, user, collaboration_id, action):
+        """Whether a specific user can perform an action for a given collaboration.
+
+        This default implementation always returns True.
+        """
+        return True
+
+
+class DatastoreHandler(IPythonHandler):
+
+    @property
+    def auth(self):
+        return self.settings.setdefault('auth', DefaultDatastoreAuth())
+
+    collaborations = {} # map of collaboration id -> collaboration
+
+
+class CollaborationsManagerHandler(DatastoreHandler):
+
+    @web.authenticated
+    def get(self, *args, **kwargs):
+        # For unqualified GET, list current sessions we have read access to
+        collaborations = {
+            (key, dict(
+                id=key,
+                friendlyName=c.friendly_name
+            ))
+            for key, c in self.collaborations.items()
+            if self.auth.check_permissions(self.current_user, key, 'r')
+        }
+        self.finish(json.dumps(dict(collaborations=collaborations)))
+
+
+class WSBaseHandler(WebSocketMixin, WebSocketHandler, DatastoreHandler):
+    """Base class for websockets reusing jupyter code"""
+
+    def set_default_headers(self):
+        """Undo the set_default_headers in IPythonHandler
+
+        which doesn't make sense for websockets
+        """
+        pass
+
+    def pre_get(self):
+        """Run before finishing the GET request
+
+        Extend this method to add logic that should fire before
+        the websocket finishes completing.
+        """
+        # authenticate the request before opening the websocket
+        if self.get_current_user() is None:
+            self.log.warning("Couldn't authenticate WebSocket connection")
+            raise web.HTTPError(403)
+
+    @gen.coroutine
+    def get(self, *args, **kwargs):
+        # pre_get can be a coroutine in subclasses
+        # assign and yield in two step to avoid tornado 3 issues
+        res = self.pre_get()
+        yield gen.maybe_future(res)
+        yield super(WSBaseHandler, self).get(*args, **kwargs)
+
+    def get_compression_options(self):
+        return self.settings.get('websocket_compression_options', None)
+
+
+class CollaborationHandler(WSBaseHandler):
+    """Request handler for the datastore API"""
+
+    def initialize(self):
+        self.log.info("Initializing datastore connection %s", self.request.path)
+        self.collaboration = None
+        self.collaboration_id = None
+        self.store_id = None
+        self.store_transaction_serial = -1
+        self.history_inited = False
+
+    @property
+    def datastore_file(self):
+        return self.settings.setdefault('datastore_file', ':memory:')
+
+    @property
+    def rtc_recovery_timeout(self):
+        return self.settings.get('rtc_recovery_timeout', 120)
+
+    @gen.coroutine
+    def pre_get(self):
+        # authenticate first
+        super(CollaborationHandler, self).pre_get()
+
+        self.store_id = self.get_query_argument('storeId', None)
+        # TODO: Check if store id supplied, if so, check if already open
+        if self.store_id is not None:
+            # TODO: Temporary minimal reaction:
+            self.log.warning("Trying to reopen store that is already connected")
+            raise web.HTTPError(400)
+
+            # Unmark for cleanup
+            self.session.forget_dangling(self.store_id)
+
+            # Give the message loop time to process any
+            # transactions that were sent before disconnect,
+            # before attempting recovery.
+            #
+            # TODO: Make a future that can be resolved on close
+            future = None
+            def give_up():
+                """Don't wait forever for close event"""
+                if future.done():
+                    return
+                future.set_result({})
+            loop = IOLoop.current()
+            loop.add_timeout(loop.time() + self.rtc_recovery_wait, give_up)
+            # actually wait for it
+            yield future
+
+    def open(self, collaboration_id=None):
+        self.log.info('Datastore open called...')
+
+        if collaboration_id is None:
+            self.log.warning("No collaboration id specified")
+            collaboration_id = uuid.uuid4()
+        self.collaboration_id = collaboration_id
+
+        if self.collaborations.get(self.collaboration_id, None) is None:
+            self.collaborations[self.collaboration_id] = Collaboration(self.collaboration_id, self.datastore_file)
+        self.collaboration = self.collaborations[self.collaboration_id]
+
+        self.store_id = self.collaboration.add_client(self)
+
+        super(CollaborationHandler, self).open()
+        self.log.info('Opened datastore websocket')
+
+    def cleanup_closed(self):
+        """Cleanup after clean close, or after recovery timeout on unclean close.
+        """
+        # Unmark as dangling if needed:
+        try:
+            self.collaboration.forget_dangling(self.store_id)
+        except KeyError:
+            pass
+
+        if self.datastore_file != ':memory:' and not self.collaboration.has_clients:
+            self.collaboration.close()
+            self.collaboration = None
+            del self.collaborations[self.collaboration_id]
+
+    def on_close(self):
+        clean_close = self.close_code in (1000, 1001)
+        self.collaboration.remove_client(self)
+        if clean_close:
+            self.cleanup_closed()
+        elif self.store_id:
+            # Un-clean close after a store was established
+            self.collaboration.mark_dangling(
+                self.store_id, self.rtc_recovery_timeout, self.cleanup_closed)
+
+        super(CollaborationHandler, self).on_close()
+        self.log.info('Closed datastore websocket')
+
+    def send_error_reply(self, parent_msg_id, reason):
+        msg = create_error_reply(parent_msg_id, reason)
+        self.log.error(reason)
+        self.write_message(json.dumps(msg))
+
+    def check_permissions(self, action):
+        return self.auth.check_permissions(self.current_user, self.collaboration_id, action)
+
+    def on_message(self, message):
+        msg = json.loads(message)
+        msg_type = msg.pop('msgType', None)
+        msg_id = msg.pop('msgId', None)
+        reply = None
+
+        self.log.info('Received datastore message %s: \n%s' % (
+            msg_type,
+            json.dumps(msg, indent=2)
+        ))
+
+        if msg_type == 'transaction-broadcast':
+            if not self.check_permissions('w'):
+                return self.send_error_reply(
+                    msg_id,
+                    'Permisson error: Cannot write transactions to current collaboration.'
+                )
+
+            # Get the transactions:
+            content = msg.pop('content', None)
+            if content is None:
+                self.log.warning('Malformed transaction broadcast message received')
+                return
+            transactions = content.pop('transactions', None)
+            if transactions is None:
+                self.log.warning('Malformed transaction broadcast message received')
+                return
+
+            # Ensure that transaction serials increment as expected:
+            for t in transactions:
+                if t['serial'] != self.store_transaction_serial + 1:
+                    # TODO: ! Missing a transaction, recover !
+                    raise ValueError('Missing transaction %d from %r' % (
+                        self.store_transaction_serial, self.store_id
+                    ))
+                self.store_transaction_serial += 1
+
+            # Check for any duplicates before adding
+            is_duplicate = self.collaboration.db.has_transactions(t['id'] for t in transactions)
+
+            # Add to transaction store, generating a central serial for each
+            serials = self.collaboration.db.add_transactions(transactions)
+
+            # Create an acknowledgment message to the source
+            reply = create_transactions_ack(msg_id, transactions, serials)
+            self.write_message(json.dumps(reply))
+
+            # Broadcast the tranasctions to all other stores
+            # First, filter away duplicates
+            filtered = filter_duplicates(transactions, is_duplicate)
+            self.collaboration.broadcast_transactions(self, filtered, serials)
+
+        elif msg_type == 'storeid-request':
+            if not self.check_permissions('r'):
+                return self.send_error_reply(
+                    msg_id,
+                    'Permisson error: Cannot access collaboration: %s' % (self.collaboration_id,)
+                )
+            reply = create_storeid_reply(msg_id, self.store_id)
+            self.write_message(json.dumps(reply))
+
+        elif msg_type == 'history-request':
+            if not self.check_permissions('r'):
+                return self.send_error_reply(
+                    msg_id,
+                    'Permisson error: Cannot access collaboration: %s' % (self.collaboration_id,)
+                )
+            content = msg.pop('content', {})
+            checkpoint_id = content.pop('checkpointId', None)
+            history = self.collaboration.db.history(checkpoint_id)
+            reply = create_history_reply(
+                msg_id,
+                tuple(history.transactions),
+                history.state
+            )
+            self.write_message(json.dumps(reply))
+            self.history_inited = True
+
+        elif msg_type == 'transaction-request':
+            if not self.check_permissions('r'):
+                return self.send_error_reply(
+                    msg_id,
+                    'Permisson error: Cannot access collaboration: %s' % (self.collaboration_id,)
+                )
+            content = msg.pop('content', None)
+            if content is None:
+                return
+            transactionIds = content.pop('transactionIds', [])
+            transactions = tuple(self.collaboration.db.get_transactions(transactionIds))
+            reply = create_transaction_reply(msg_id, transactions)
+            self.write_message(json.dumps(reply))
+
+        elif msg_type == 'serial-request':
+            if not self.check_permissions('r'):
+                return self.send_error_reply(
+                    msg_id,
+                    'Permisson error: Cannot access collaboration: %s' % (self.collaboration_id,)
+                )
+            content = msg.pop('content', None)
+            if content is None:
+                return
+            serials = content.pop('serials', [])
+            transactions = tuple(self.collaboration.db.get_serials(serials))
+            reply = create_serial_reply(msg_id, transactions)
+            self.write_message(json.dumps(reply))
+
+        elif msg_type == 'permissions-request':
+            reply = create_permissions_reply(
+                msg_id,
+                self.check_permissions('r'),
+                self.check_permissions('w')
+            )
+            self.write_message(json.dumps(reply))
+
+        elif msg_type == 'serial-update':
+            content = msg.pop('content', None)
+            if content is None:
+                return
+            serial = content.pop('serial', None)
+            if serial is not None:
+                self.collaboration.update_serial(self.store_id, serial)
+
+
+# The path for lab build.
+# TODO: Is this a reasonable path?
+collaboration_path = r"/lab/api/datastore/(?P<collaboration_id>[a-zA-Z0-9\-]+)"
+datastore_rest_path = r"/lab/api/datastore/?"
diff --git a/jupyterlab/datastore/messages.py b/jupyterlab/datastore/messages.py
new file mode 100644
index 00000000000..3e8fb822a4c
--- /dev/null
+++ b/jupyterlab/datastore/messages.py
@@ -0,0 +1,94 @@
+
+import uuid
+
+def create_storeid_reply(parent_id, store_id):
+    return dict(
+        msgId=str(uuid.uuid4()),
+        msgType='storeid-reply',
+        parentId=parent_id,
+        content=dict(
+            storeId=store_id
+        )
+    )
+
+def create_transactions_ack(parent_id, transactions, serials):
+    return dict(
+        msgId=str(uuid.uuid4()),
+        msgType='transaction-ack',
+        parentId=parent_id,
+        content=dict(
+            transactionIds=[t['id'] for t in transactions],
+            serials=[serials[t['id']] for t in transactions]
+        )
+    )
+
+def create_history_reply(parent_id, transactions, state=None):
+    return dict(
+        msgId=str(uuid.uuid4()),
+        msgType='history-reply',
+        parentId=parent_id,
+        content=dict(
+            state=state,
+            transactions=transactions
+        )
+    )
+
+def create_transaction_reply(parent_id, transactions):
+    return dict(
+        msgId=str(uuid.uuid4()),
+        msgType='transaction-reply',
+        parentId=parent_id,
+        content=dict(
+            transactions=transactions
+        )
+    )
+
+def create_serial_reply(parent_id, transactions):
+    return dict(
+        msgId=str(uuid.uuid4()),
+        msgType='serial-reply',
+        parentId=parent_id,
+        content=dict(
+            transactions=transactions
+        )
+    )
+
+def create_permissions_reply(parent_id, read, write):
+    return dict(
+        msgId=str(uuid.uuid4()),
+        msgType='permissions-reply',
+        parentId=parent_id,
+        content=dict(
+            read=read,
+            write=write
+        )
+    )
+
+def create_stable_state_broadcast(serial):
+    return dict(
+        msgId=str(uuid.uuid4()),
+        msgType='state-stable',
+        content=dict(
+            serial=serial
+        )
+    )
+
+def create_transaction_broadcast(transactions, serials):
+    rebranded = [ dict(t, serial=serials[t['id']]) for t in transactions ]
+    return dict(
+        msgId=str(uuid.uuid4()),
+        msgType='transaction-broadcast',
+        content=dict(
+            transactions=rebranded
+        )
+    )
+
+def create_error_reply(parent_id, reason):
+    return dict(
+        msgId=str(uuid.uuid4()),
+        msgType='error-reply',
+        parentId=parent_id,
+        content=dict(
+            reason=reason
+        )
+    )
diff --git a/jupyterlab/extension.py b/jupyterlab/extension.py
index 061c97e6cae..ca2e02da701 100644
--- a/jupyterlab/extension.py
+++ b/jupyterlab/extension.py
@@ -86,6 +86,10 @@ def load_jupyter_server_extension(nbapp):
     from .extension_manager_handler import (
         extensions_handler_path, ExtensionManager, ExtensionHandler
     )
+    from .datastore import (
+        CollaborationHandler, collaboration_path,
+        CollaborationsManagerHandler, datastore_rest_path
+    )
     from .commands import (
         DEV_DIR, HERE, ensure_core, ensure_dev, watch, watch_dev, get_app_dir
     )
@@ -184,10 +188,18 @@ def load_jupyter_server_extension(nbapp):
         config.cache_files = False
 
     base_url = web_app.settings['base_url']
+
     build_url = ujoin(base_url, build_path)
     builder = Builder(logger, core_mode, app_dir)
     build_handler = (build_url, BuildHandler, {'builder': builder})
-    handlers = [build_handler]
+
+    collaborations_url = ujoin(base_url, collaboration_path)
+    collaborations_handler = (collaborations_url, CollaborationHandler, {})
+
+    colab_manager_url = ujoin(base_url, datastore_rest_path)
+    colab_manager_handler = (colab_manager_url, CollaborationsManagerHandler, {})
+
+    handlers = [build_handler, collaborations_handler, colab_manager_handler]
 
     if not core_mode:
         ext_url = ujoin(base_url, extensions_handler_path)
diff --git a/packages/attachments/src/model.ts b/packages/attachments/src/model.ts
index 9df48ce006d..2eaa1736ce8 100644
--- a/packages/attachments/src/model.ts
+++ b/packages/attachments/src/model.ts
@@ -7,7 +7,6 @@ import {
   IObservableMap,
   ObservableMap,
   IObservableValue,
-  ObservableValue,
   IModelDB
 } from '@jupyterlab/observables';
 
@@ -133,7 +132,7 @@ export namespace IAttachmentsModel {
  */
 export class AttachmentsModel implements IAttachmentsModel {
   /**
-   * Construct a new observable outputs instance.
+   * Construct a new observable attachments instance.
    */
   constructor(options: IAttachmentsModel.IOptions = {}) {
     this.contentFactory =
@@ -304,12 +303,12 @@ export class AttachmentsModel implements IAttachmentsModel {
   }
 
   /**
-   * If the serialized version of the outputs have changed due to a remote
+   * If the serialized version of the attachments have changed due to a remote
    * action, then update the model accordingly.
    */
   private _onSerializedChanged(
     sender: IObservableValue,
-    args: ObservableValue.IChangedArgs
+    args: IObservableValue.IChangedArgs
   ) {
     if (!this._changeGuard) {
       this._changeGuard = true;
diff --git a/packages/cells/src/model.ts b/packages/cells/src/model.ts
index 696099cff30..a667567cbfd 100644
--- a/packages/cells/src/model.ts
+++ b/packages/cells/src/model.ts
@@ -18,8 +18,7 @@ import { UUID } from '@phosphor/coreutils';
 import {
   IObservableJSON,
   IModelDB,
-  IObservableValue,
-  ObservableValue
+  IObservableValue
 } from '@jupyterlab/observables';
 
 import { IOutputAreaModel, OutputAreaModel } from '@jupyterlab/outputarea';
@@ -276,7 +275,7 @@ export class CellModel extends CodeEditor.Model implements ICellModel {
    */
   onTrustedChanged(
     trusted: IObservableValue,
-    args: ObservableValue.IChangedArgs
+    args: IObservableValue.IChangedArgs
   ): void {
     /* no-op */
   }
@@ -549,7 +548,7 @@ export class CodeCellModel extends CellModel implements ICodeCellModel {
    */
   onTrustedChanged(
     trusted: IObservableValue,
-    args: ObservableValue.IChangedArgs
+    args: IObservableValue.IChangedArgs
   ): void {
     if (this._outputs) {
       this._outputs.trusted = args.newValue as boolean;
@@ -566,7 +565,7 @@ export class CodeCellModel extends CellModel implements ICodeCellModel {
    */
   private _onExecutionCountChanged(
     count: IObservableValue,
-    args: ObservableValue.IChangedArgs
+    args: IObservableValue.IChangedArgs
   ): void {
     this.contentChanged.emit(void 0);
     this.stateChanged.emit({
diff --git a/packages/codeeditor/src/editor.ts b/packages/codeeditor/src/editor.ts
index bedcf8f968c..c83b70a04d1 100644
--- a/packages/codeeditor/src/editor.ts
+++ b/packages/codeeditor/src/editor.ts
@@ -13,7 +13,6 @@ import {
   IModelDB,
   ModelDB,
   IObservableValue,
-  ObservableValue,
   IObservableMap,
   IObservableString
 } from '@jupyterlab/observables';
@@ -285,13 +284,13 @@ export namespace CodeEditor {
         return;
       }
       this._isDisposed = true;
-      this.value.text = '';
+      this.value.dispose();
       Signal.clearData(this);
     }
 
     private _onMimeTypeChanged(
       mimeType: IObservableValue,
-      args: ObservableValue.IChangedArgs
+      args: IObservableValue.IChangedArgs
     ): void {
       this._mimeTypeChanged.emit({
         name: 'mimeType',
diff --git a/packages/datastore-extension/package.json b/packages/datastore-extension/package.json
new file mode 100644
index 00000000000..dfd1ce4304c
--- /dev/null
+++ b/packages/datastore-extension/package.json
@@ -0,0 +1,53 @@
+{
+  "name": "@jupyterlab/datastore-extension",
+  "version": "1.0.0-alpha.3",
+  "description": "JupyterLab - Datastore Extension",
+  "homepage": "https://github.com/jupyterlab/jupyterlab",
+  "bugs": {
+    "url": "https://github.com/jupyterlab/jupyterlab/issues"
+  },
+  "license": "BSD-3-Clause",
+  "author": "Project Jupyter",
+  "files": [
+    "lib/*.d.ts",
+    "lib/*.js.map",
+    "lib/*.js",
+    "schema/*.json"
+  ],
+  "main": "lib/index.js",
+  "types": "lib/index.d.ts",
+  "directories": {
+    "lib": "lib/"
+  },
+  "repository": {
+    "type": "git",
+    "url": "https://github.com/jupyterlab/jupyterlab.git"
+  },
+  "scripts": {
+    "build": "tsc -b",
+    "clean": "rimraf lib",
+    "docs": "typedoc --options tdoptions.json --theme ../../typedoc-theme src",
+    "prepublishOnly": "npm run build",
+    "watch": "tsc -b --watch"
+  },
+  "dependencies": {
+    "@jupyterlab/application": "^1.0.0-alpha.3",
+    "@jupyterlab/datastore": "^1.0.0-alpha.3",
+    "@phosphor/datastore": "file:../../../phosphor/packages/datastore",
+    "@phosphor/messaging": "^1.2.2",
+    "@phosphor/widgets": "^1.6.0"
+  },
+  "devDependencies": {
+    "rimraf": "~2.6.2",
+    "typedoc": "^0.14.2",
+    "typescript": "~3.3.1"
+  },
+  "publishConfig": {
+    "access": "public"
+  },
+  "gitHead": "31f68f6d1717b58c344a5fb4f4baf3b123b7c75c",
+  "jupyterlab": {
+    "extension": true,
+    "schemaDir": "schema"
+  }
+}
diff --git a/packages/datastore-extension/src/index.ts b/packages/datastore-extension/src/index.ts
new file mode 100644
index 00000000000..e8c327d723d
--- /dev/null
+++ b/packages/datastore-extension/src/index.ts
@@ -0,0 +1,33 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import {
+  ILabShell,
+  JupyterFrontEnd,
+  JupyterFrontEndPlugin
+} from '@jupyterlab/application';
+
+import { DSModelDBFactory } from '@jupyterlab/datastore';
+
+const pluginId = '@jupyterlab/datastore-extension:plugin';
+
+/**
+ * The default document manager provider.
+ */
+const datastorePlugin: JupyterFrontEndPlugin<void> = {
+  id: pluginId,
+  requires: [],
+  optional: [ILabShell],
+  autoStart: true,
+  activate: (app: JupyterFrontEnd, labShell: ILabShell | null) => {
+    const registry = app.docRegistry;
+    const factory = new DSModelDBFactory();
+    registry.addModelDBFactory('phosphor-datastore', factory);
+  }
+};
+
+/**
+ * Export the plugins as default.
+ */
+const plugins: JupyterFrontEndPlugin<any>[] = [datastorePlugin];
+export default plugins;
diff --git a/packages/datastore-extension/tdoptions.json b/packages/datastore-extension/tdoptions.json
new file mode 100644
index 00000000000..aba75aa7c53
--- /dev/null
+++ b/packages/datastore-extension/tdoptions.json
@@ -0,0 +1,20 @@
+{
+  "excludeNotExported": true,
+  "mode": "file",
+  "target": "es5",
+  "module": "es5",
+  "lib": [
+    "lib.es2015.d.ts",
+    "lib.es2015.collection.d.ts",
+    "lib.es2015.promise.d.ts",
+    "lib.dom.d.ts"
+  ],
+  "out": "../../docs/api/datastore-extension",
+  "baseUrl": ".",
+  "paths": {
+    "@jupyterlab/*": ["../packages/*"]
+  },
+  "esModuleInterop": true,
+  "jsx": "react",
+  "types": []
+}
diff --git a/packages/datastore-extension/tsconfig.json b/packages/datastore-extension/tsconfig.json
new file mode 100644
index 00000000000..ef4df9245b4
--- /dev/null
+++ b/packages/datastore-extension/tsconfig.json
@@ -0,0 +1,16 @@
+{
+  "extends": "../../tsconfigbase",
+  "compilerOptions": {
+    "outDir": "lib",
+    "rootDir": "src"
+  },
+  "include": ["src/*"],
+  "references": [
+    {
+      "path": "../application"
+    },
+    {
+      "path": "../datastore"
+    }
+  ]
+}
diff --git a/packages/datastore/package.json b/packages/datastore/package.json
new file mode 100644
index 00000000000..45efb746772
--- /dev/null
+++ b/packages/datastore/package.json
@@ -0,0 +1,52 @@
+{
+  "name": "@jupyterlab/datastore",
+  "version": "1.0.0-alpha.3",
+  "description": "JupyterLab - Datastore",
+  "homepage": "https://github.com/jupyterlab/jupyterlab",
+  "bugs": {
+    "url": "https://github.com/jupyterlab/jupyterlab/issues"
+  },
+  "license": "BSD-3-Clause",
+  "author": "Project Jupyter",
+  "files": [
+    "lib/*.d.ts",
+    "lib/*.js.map",
+    "lib/*.js"
+  ],
+  "main": "lib/index.js",
+  "types": "lib/index.d.ts",
+  "directories": {
+    "lib": "lib/"
+  },
+  "repository": {
+    "type": "git",
+    "url": "https://github.com/jupyterlab/jupyterlab.git"
+  },
+  "scripts": {
+    "build": "tsc -b",
+    "clean": "rimraf lib",
+    "docs": "typedoc --options tdoptions.json --theme ../../typedoc-theme src",
+    "prepublishOnly": "npm run build",
+    "watch": "tsc -b --watch"
+  },
+  "dependencies": {
+    "@jupyterlab/coreutils": "^3.0.0-alpha.3",
+    "@jupyterlab/observables": "^2.2.0-alpha.3",
+    "@jupyterlab/services": "^4.0.0-alpha.3",
+    "@phosphor/algorithm": "^1.1.2",
+    "@phosphor/coreutils": "^1.3.0",
+    "@phosphor/datastore": "file:../../../phosphor/packages/datastore",
+    "@phosphor/disposable": "^1.1.2",
+    "@phosphor/messaging": "^1.2.2",
+    "@phosphor/signaling": "^1.2.2"
+  },
+  "devDependencies": {
+    "rimraf": "~2.6.2",
+    "typedoc": "^0.14.2",
+    "typescript": "~3.3.1"
+  },
+  "publishConfig": {
+    "access": "public"
+  },
+  "gitHead": "31f68f6d1717b58c344a5fb4f4baf3b123b7c75c"
+}
diff --git a/packages/datastore/src/client.ts b/packages/datastore/src/client.ts
new file mode 100644
index 00000000000..5fc615c526e
--- /dev/null
+++ b/packages/datastore/src/client.ts
@@ -0,0 +1,396 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import { URLExt } from '@jupyterlab/coreutils';
+
+import { PromiseDelegate } from '@phosphor/coreutils';
+
+import { Datastore } from '@phosphor/datastore';
+
+import { IMessageHandler, Message, MessageLoop } from '@phosphor/messaging';
+
+import { ServerConnection, WSConnection } from '@jupyterlab/services';
+
+import { Collaboration } from './wsmessages';
+
+/**
+ * The url for the datastore service.
+ */
+const DATASTORE_SERVICE_URL = 'lab/api/datastore';
+
+/**
+ * The default treshold for idle time, in seconds.
+ */
+const DEFAULT_IDLE_TIME = 3;
+
+/**
+ * A class that manages exchange of transactions with the collaboration server.
+ */
+export class CollaborationClient extends WSConnection<
+  Collaboration.Message,
+  Collaboration.Message
+> {
+  /**
+   * Create a new collaboration client connection.
+   */
+  constructor(options: CollaborationClient.IOptions = {}) {
+    super();
+    this.collaborationId = options.collaborationId;
+    this.handler = options.handler || null;
+    this._idleTreshold = 1000 * (options.idleTreshold || DEFAULT_IDLE_TIME);
+    this.serverSettings =
+      options.serverSettings || ServerConnection.makeSettings();
+    this._createSocket();
+  }
+
+  /**
+   * Create a new, unique store id.
+   *
+   * @returns {Promise<number>} A promise to the new store id.
+   */
+  get storeId(): Promise<number> {
+    if (this._storeId !== null) {
+      return Promise.resolve(this._storeId);
+    }
+    return this.ready.then(async () => {
+      const msg = Collaboration.createMessage('storeid-request', {});
+      const reply = await this._requestMessageReply(msg);
+      return (this._storeId = reply.content.storeId);
+    });
+  }
+
+  /**
+   * The permissions for the current use on the datastore session.
+   */
+  get permissions(): Promise<CollaborationClient.Permissions> {
+    return Promise.resolve().then(async () => {
+      await this.ready;
+      const msg = Collaboration.createMessage('permissions-request', {});
+      const reply = await this._requestMessageReply(msg);
+      return reply.content;
+    });
+  }
+
+  /**
+   * Broadcast transactions to all datastores.
+   *
+   * @param transactions - The transactions to broadcast.
+   * @returns An array of acknowledged transactionIds from the server.
+   */
+  broadcastTransactions(transactions: Datastore.Transaction[]): void {
+    // Brand outgoing transactions with our serial
+    const branded = [];
+    for (let t of transactions) {
+      const b = { ...t, serial: this._ourSerial++ };
+      branded.push(b);
+      this._pendingTransactions[b.id] = b;
+    }
+    this._resetIdleTimer();
+    const msg = Collaboration.createMessage('transaction-broadcast', {
+      transactions: branded
+    });
+    this._requestMessageReply(msg).then(
+      reply => {
+        const { serials, transactionIds } = reply.content;
+        for (let i = 0; i < serials.length; ++i) {
+          const serial = serials[i];
+          const id = transactionIds[i];
+          delete this._pendingTransactions[id];
+          if (serial !== this._serverSerial + 1) {
+            // Out of order serials!
+            // Something has gone wrong somewhere.
+            // TODO: Trigger recovery?
+            throw new Error(
+              'Critical! Out of order transactions in datastore.'
+            );
+          }
+          this._serverSerial = serial;
+        }
+        this._resetIdleTimer();
+      },
+      () => {
+        // TODO: Resend transactions
+      }
+    );
+  }
+
+  /**
+   * Request the complete history of the datastore.
+   *
+   * The transactions of the history will be sent to the set handler.
+   */
+  async replayHistory(checkpointId?: number): Promise<void> {
+    const msg = Collaboration.createMessage('history-request', {
+      checkpointId: checkpointId === undefined ? null : checkpointId
+    });
+    const reply = await this._requestMessageReply(msg);
+    const content = reply.content;
+    // TODO: Set initial state
+    if (this.handler !== null) {
+      const message = new CollaborationClient.InitialStateMessage(
+        content.state
+      );
+      MessageLoop.postMessage(this.handler, message);
+    }
+    this._handleTransactions(content.transactions);
+  }
+
+  /**
+   * The server settings for the session.
+   */
+  readonly serverSettings: ServerConnection.ISettings;
+
+  /**
+   * The id of the collaboration.
+   */
+  readonly collaborationId: string | undefined;
+
+  /**
+   * The message handler of any data messages.
+   */
+  handler: IMessageHandler | null;
+
+  /**
+   * Factory method for creating the web socket object.
+   */
+  protected wsFactory() {
+    const settings = this.serverSettings;
+    const token = this.serverSettings.token;
+    const queryParams = [];
+
+    let wsUrl;
+    if (this.collaborationId) {
+      wsUrl = URLExt.join(
+        settings.wsUrl,
+        DATASTORE_SERVICE_URL,
+        this.collaborationId
+      );
+    } else {
+      wsUrl = URLExt.join(settings.wsUrl, DATASTORE_SERVICE_URL);
+    }
+
+    if (token) {
+      queryParams.push(`token=${encodeURIComponent(token)}`);
+    }
+    if (this._storeId !== null) {
+      queryParams.push(
+        `storeId=${encodeURIComponent(this._storeId.toString(10))}`
+      );
+    }
+    if (queryParams) {
+      wsUrl = wsUrl + `?${queryParams.join('&')}`;
+    }
+
+    return new settings.WebSocket(wsUrl);
+  }
+
+  /**
+   * Handler for deserialized websocket messages.
+   */
+  protected handleMessage(
+    msg:
+      | Collaboration.RawReply
+      | Collaboration.TransactionBroadcast
+      | Collaboration.StableStateNotice
+  ): boolean {
+    try {
+      // TODO: Write a validator?
+      // validate.validateMessage(msg);
+    } catch (error) {
+      console.error(`Invalid message: ${error.message}`);
+      return false;
+    }
+
+    if (Collaboration.isReply(msg)) {
+      let delegate = this._delegates && this._delegates.get(msg.parentId!);
+      if (delegate) {
+        if (msg.msgType === 'error-reply') {
+          console.warn('Received datastore error from server', msg.content);
+          delegate.reject(msg.content.reason);
+        } else {
+          delegate.resolve(msg);
+        }
+        return true;
+      }
+    }
+    if (msg.msgType === 'transaction-broadcast') {
+      this._handleTransactions(msg.content.transactions);
+    } else if (msg.msgType === 'state-stable') {
+      if (this.handler !== null && this._serverSerial === msg.content.serial) {
+        MessageLoop.sendMessage(this.handler, new Datastore.GCChanceMessage());
+      }
+    } else {
+      return false;
+    }
+    return true;
+  }
+
+  /**
+   * Process transactions received over the websocket.
+   */
+  private _handleTransactions(
+    transactions: ReadonlyArray<Collaboration.SerialTransaction>
+  ) {
+    if (this.handler !== null) {
+      for (let t of transactions) {
+        if (t.serial !== this._serverSerial + 1) {
+          // Out of order serials!
+          // Something has gone wrong somewhere.
+          // TODO: Trigger recovery?
+          throw new Error('Critical! Out of order transactions in datastore.');
+        }
+        this._serverSerial = t.serial;
+        const message = new CollaborationClient.RemoteTransactionMessage(t);
+        MessageLoop.postMessage(this.handler, message);
+      }
+    }
+    this._resetIdleTimer();
+  }
+
+  /**
+   * Send a message to the server and resolve the reply message.
+   */
+  private _requestMessageReply<T extends Collaboration.Request>(
+    msg: T,
+    timeout = 0
+  ): Promise<Collaboration.IReplyMap[T['msgType']]> {
+    const delegate = new PromiseDelegate<Collaboration.Reply>();
+    this._delegates.set(msg.msgId, delegate);
+
+    // .finally(), delete from delegate map
+    const promise = delegate.promise.then(
+      reply => {
+        this._delegates.delete(msg.msgId);
+        return reply;
+      },
+      reason => {
+        this._delegates.delete(msg.msgId);
+        throw reason;
+      }
+    );
+
+    if (timeout > 0) {
+      setTimeout(() => {
+        delegate.reject('Timed out waiting for reply');
+      }, timeout);
+    }
+
+    this.sendMessage(msg);
+
+    return promise;
+  }
+
+  /**
+   * Callback called when idle after activity.
+   */
+  private _onIdle() {
+    const msg = Collaboration.createMessage('serial-update', {
+      serial: this._serverSerial
+    });
+    this.sendMessage(msg);
+    this._idleTimer = null;
+  }
+
+  /**
+   * Reset the idle timer.
+   */
+  private _resetIdleTimer() {
+    if (this._idleTimer !== null) {
+      clearTimeout(this._idleTimer);
+    }
+    this._idleTimer = setTimeout(this._onIdle.bind(this), this._idleTreshold);
+  }
+
+  private _delegates = new Map<string, PromiseDelegate<Collaboration.Reply>>();
+
+  private _ourSerial = 0;
+  private _serverSerial = 0;
+  private _pendingTransactions: Collaboration.SerialTransactionMap = {};
+
+  private _idleTreshold: number;
+  private _idleTimer: number | null = null;
+
+  private _storeId: number | null = null;
+}
+
+/**
+ *
+ */
+export namespace CollaborationClient {
+  export interface IOptions {
+    /**
+     * The id of the collaboration to connect to.
+     */
+    collaborationId?: string;
+
+    /**
+     * The server settings for the session.
+     */
+    serverSettings?: ServerConnection.ISettings;
+
+    /**
+     * The handler for any incoming data.
+     */
+    handler?: IMessageHandler;
+
+    /**
+     * How long to wait before the session is considered idle, in seconds.
+     */
+    idleTreshold?: number;
+  }
+
+  /**
+   * A message class for `'remote-transactions'` messages.
+   */
+  export class RemoteTransactionMessage extends Message {
+    /**
+     * Construct a new remote transactions message.
+     *
+     * @param transaction - The transaction object
+     */
+    constructor(transaction: Datastore.Transaction) {
+      super('remote-transactions');
+      this.transaction = transaction;
+    }
+
+    /**
+     * The patch object.
+     */
+    readonly transaction: Datastore.Transaction;
+  }
+
+  /**
+   * A message class for initial state messages.
+   */
+  export class InitialStateMessage extends Message {
+    /**
+     * Construct a new initial state message.
+     *
+     * @param state - he serialized state
+     */
+    constructor(state: string | null) {
+      super('initial-state');
+      this.state = state;
+    }
+
+    /**
+     * The serialized state.
+     */
+    readonly state: string | null;
+  }
+
+  /**
+   * Datastore permissions object.
+   */
+  export type Permissions = {
+    /**
+     * Whether the current user can read from the datastore session.
+     */
+    read: boolean;
+
+    /**
+     * Whether the current user can write to the datastore session.
+     */
+    write: boolean;
+  };
+}
diff --git a/packages/datastore/src/index.ts b/packages/datastore/src/index.ts
new file mode 100644
index 00000000000..296618966f6
--- /dev/null
+++ b/packages/datastore/src/index.ts
@@ -0,0 +1,8 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+export * from './client';
+export * from './manager';
+export * from './modeldb';
+export * from './observables';
+export * from './rest';
diff --git a/packages/datastore/src/manager.ts b/packages/datastore/src/manager.ts
new file mode 100644
index 00000000000..dbfa77cb9a4
--- /dev/null
+++ b/packages/datastore/src/manager.ts
@@ -0,0 +1,250 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import { IModelDB } from '@jupyterlab/observables';
+
+import { map, toArray } from '@phosphor/algorithm';
+
+import { UUID } from '@phosphor/coreutils';
+
+import { Schema, Datastore } from '@phosphor/datastore';
+
+import { IDisposable } from '@phosphor/disposable';
+
+import { Message, IMessageHandler, MessageLoop } from '@phosphor/messaging';
+
+import { Signal, ISignal } from '@phosphor/signaling';
+
+import { CollaborationClient } from './client';
+
+import { DSModelDB } from './modeldb';
+
+/**
+ *
+ */
+const LOCAL_DS_STORE_ID = -1;
+
+/**
+ *
+ */
+function cloneDS(
+  newId: number,
+  source: Datastore,
+  overrides?: Partial<Datastore.IOptions>
+): Datastore {
+  // Clone store object
+  const dest = Datastore.create({
+    broadcastHandler: source.broadcastHandler || undefined,
+    ...overrides,
+    id: newId,
+    schemas: toArray(map(source.iter(), table => table.schema)),
+    restoreState: source.toString()
+  });
+  return dest;
+}
+
+/**
+ * A manager for a single datastore.
+ */
+export class DatastoreManager implements IMessageHandler, IDisposable {
+  /**
+   *
+   */
+  constructor(
+    collaborationId: string,
+    schemas: ReadonlyArray<Schema>,
+    immediate: boolean
+  ) {
+    this.collaborationId = collaborationId;
+    this._schemas = schemas;
+    if (immediate) {
+      this._localDS = Datastore.create({
+        id: LOCAL_DS_STORE_ID,
+        schemas
+      });
+    } else {
+      this._localDS = null;
+    }
+
+    try {
+      this.connected = this.connectRemote();
+    } catch (err) {
+      console.error(err);
+      this.connected = new Promise(() => {
+        // never resolve
+      });
+    }
+  }
+
+  get isDisposed(): boolean {
+    return this._isDisposed;
+  }
+
+  dispose(): void {
+    if (this.isDisposed) {
+      return;
+    }
+    this._isDisposed = true;
+    if (this._localDS) {
+      this._localDS.dispose();
+      this._localDS = null;
+    }
+    if (this._remoteDS) {
+      this._remoteDS.dispose();
+      this._remoteDS = null;
+    }
+    if (this._client) {
+      this._client.dispose();
+      this._client = null;
+    }
+  }
+
+  /**
+   *
+   */
+  processMessage(msg: Message) {
+    if (this.isDisposed) {
+      return;
+    }
+    if (msg.type === 'remote-transactions') {
+      MessageLoop.sendMessage(
+        this._remoteDS || this._localDS!,
+        new Datastore.TransactionMessage(
+          (msg as CollaborationClient.RemoteTransactionMessage).transaction
+        )
+      );
+    } else if (msg.type === 'datastore-transaction') {
+      if (this._client) {
+        this._client.broadcastTransactions([
+          (msg as Datastore.TransactionMessage).transaction
+        ]);
+      }
+    } else if (msg.type === 'initial-state') {
+      const state = (msg as CollaborationClient.InitialStateMessage).state;
+
+      // Scenarios:
+      // 1. Immediate (has localDS), and state is null: Clone local.
+      // 2. Non-immediate, and state is null: Simple create of remote.
+      // 3. Non-immediate, and state is non-null: Recreate remote from state.
+      // 4. Immediate, and non-null state: Error!
+      // 5. Has remote already: Treat as non-immediate (recovery)
+
+      const immediate = this._localDS !== null && this._remoteDS === null;
+      if (!immediate) {
+        // 2. / 3.  ( 5.)
+        this._remoteDS = Datastore.create({
+          id: this._storeId!,
+          schemas: this._schemas,
+          broadcastHandler: this,
+          restoreState: state || undefined
+        });
+        if (state !== null) {
+          this._prepopulated = true;
+        }
+      } else if (state === null) {
+        // 1.
+        this._remoteDS = cloneDS(this._storeId!, this._localDS!, {
+          broadcastHandler: this
+        });
+      } else {
+        // 4.
+        throw new Error(
+          'Cannot replace the state of an immediate collaboration session!'
+        );
+      }
+
+      this._datastoreChanged.emit({ datastore: this._remoteDS });
+
+      if (this._localDS) {
+        this._localDS.dispose();
+        this._localDS = null;
+      }
+    } else if (msg.type === 'datastore-gc-chance') {
+      MessageLoop.sendMessage(this._remoteDS || this._localDS!, msg);
+    }
+  }
+
+  get datastore() {
+    return this._remoteDS || this._localDS;
+  }
+
+  get datastoreChanged(): ISignal<this, DatastoreManager.IChangedArgs> {
+    return this._datastoreChanged;
+  }
+
+  /**
+   *
+   */
+  readonly collaborationId: string;
+
+  readonly connected: Promise<void>;
+
+  get isPrepopulated(): boolean {
+    return this._prepopulated;
+  }
+
+  /**
+   *
+   */
+  protected async connectRemote(): Promise<void> {
+    if (this._client === null) {
+      this._client = new CollaborationClient({
+        collaborationId: this.collaborationId,
+        handler: this
+      });
+    }
+    this._storeId = await this._client.storeId;
+    if (this._storeId > 1) {
+      this._prepopulated = true;
+    }
+    return this._client.replayHistory();
+  }
+
+  private _schemas: ReadonlyArray<Schema>;
+
+  private _client: CollaborationClient | null = null;
+  private _localDS: Datastore | null;
+  private _remoteDS: Datastore | null = null;
+  private _storeId: number | null = null;
+  private _prepopulated = false;
+
+  private _isDisposed = false;
+  private _datastoreChanged = new Signal<this, DatastoreManager.IChangedArgs>(
+    this
+  );
+}
+
+export namespace DatastoreManager {
+  export interface IChangedArgs {
+    datastore: Datastore;
+  }
+}
+
+/**
+ *
+ */
+export class DSModelDBFactory implements IModelDB.IFactory {
+  /**
+   * Create a new DSModelDB instance.
+   *
+   * @param path - The path of the file to model.
+   * @param schemas - The schemas for the model.
+   */
+  createNew(path: string, schemas: ReadonlyArray<Schema>) {
+    // Set up session to server:
+    // TODO: Keep path, or use UUID?
+    // Note: We probably want to use a UUID, as paths are mutable (rename)
+    //       Then, we need a way to map and sync paths to UUIDs.
+    let collaborationId = UUID.uuid4();
+    collaborationId = path.replace(/[^0-9a-zA-Z_\-]/, '');
+
+    const manager = new DatastoreManager(collaborationId, schemas, true);
+
+    return new DSModelDB({
+      schemas,
+      manager,
+      recordId: collaborationId,
+      schemaId: schemas[0].id
+    });
+  }
+}
diff --git a/packages/datastore/src/modeldb.ts b/packages/datastore/src/modeldb.ts
new file mode 100644
index 00000000000..ae9f091db1d
--- /dev/null
+++ b/packages/datastore/src/modeldb.ts
@@ -0,0 +1,384 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import {
+  IModelDB,
+  ICollaboratorMap,
+  IObservable,
+  IObservableString,
+  IObservableUndoableList,
+  IObservableValue,
+  IObservableJSON
+} from '@jupyterlab/observables';
+
+import { toArray } from '@phosphor/algorithm';
+
+import { ReadonlyJSONValue } from '@phosphor/coreutils';
+
+import { Schema } from '@phosphor/datastore';
+
+import { DisposableSet } from '@phosphor/disposable';
+
+import {
+  ObservableJSON,
+  ObservableString,
+  ObservableUndoableList,
+  ObservableValue
+} from './observables';
+
+import { iterValues } from './objiter';
+
+import { DatastoreManager } from './manager';
+
+/**
+ *
+ */
+export class DSModelDB implements IModelDB {
+  /**
+   *
+   */
+  constructor(options: DSModelDB.ICreateOptions) {
+    this._schemaId = options.schemaId;
+    if (options.baseDB) {
+      this._baseDB = options.baseDB;
+    } else {
+      this._baseDB = new Map<string, IObservable>();
+      this._toDispose = true;
+    }
+    this._schemas = {};
+    this._recordId = options.recordId;
+    for (let s of options.schemas) {
+      this._schemas[s.id] = s;
+    }
+    if (options.baseDB) {
+      this.manager = options.baseDB.manager;
+    } else {
+      this.manager = options.manager;
+    }
+    this.connected = this.manager.connected;
+  }
+
+  /**
+   * Get a value for a path.
+   *
+   * @param path: the path for the object.
+   *
+   * @returns an `IObservable`.
+   */
+  get(path: string, resolved = false): IObservable | undefined {
+    if (!resolved) {
+      path = this._resolvePath(path);
+    }
+    return this._baseDB.get(path, true);
+  }
+
+  /**
+   * Whether the `IModelDB` has an object at this path.
+   *
+   * @param path: the path for the object.
+   *
+   * @returns a boolean for whether an object is at `path`.
+   */
+  has(path: string, resolved = false): boolean {
+    if (!resolved) {
+      path = this._resolvePath(path);
+    }
+    return this._baseDB.has(path, true);
+  }
+
+  /**
+   * Create a string and insert it in the database.
+   *
+   * @param path: the path for the string.
+   *
+   * @returns the string that was created.
+   */
+  createString(path: string): IObservableString {
+    const schema = this._schemas[this._schemaId];
+    const field = schema.fields[path];
+    if (!field || field.type !== 'text') {
+      throw new Error(
+        `Cannot create a string for path '${path}', incompatible with schema.`
+      );
+    }
+    let str = new ObservableString(this.manager, schema, this._recordId, path);
+    this._disposables.add(str);
+    this.set(path, str);
+    return str;
+  }
+
+  /**
+   * Create an undoable list and insert it in the database.
+   *
+   * @param path: the path for the list.
+   *
+   * @returns the list that was created.
+   *
+   * #### Notes
+   * The list can only store objects that are simple
+   * JSON Objects and primitives.
+   */
+  createList<T extends ReadonlyJSONValue>(
+    path: string
+  ): IObservableUndoableList<T> {
+    const schema = this._schemas[this._schemaId];
+    const field = schema.fields[path];
+    if (!field || field.type !== 'list') {
+      throw new Error(
+        `Cannot create a list for path '${path}', incompatible with schema.`
+      );
+    }
+    let vec = new ObservableUndoableList(
+      this.manager,
+      schema,
+      this._recordId,
+      path,
+      new ObservableUndoableList.IdentitySerializer<T>()
+    );
+    this._disposables.add(vec);
+    this.set(path, vec);
+    return vec;
+  }
+
+  /**
+   * Create a map and insert it in the database.
+   *
+   * @param path: the path for the map.
+   *
+   * @returns the map that was created.
+   *
+   * #### Notes
+   * The map can only store objects that are simple
+   * JSON Objects and primitives.
+   */
+  createMap(path: string): IObservableJSON {
+    const schema = this._schemas[this._schemaId];
+    const field = schema.fields[path];
+    if (!field || field.type !== 'map') {
+      throw new Error(
+        `Cannot create a map for path '${path}', incompatible with schema.`
+      );
+    }
+    let map = new ObservableJSON(this.manager, schema, this._recordId, path);
+    this._disposables.add(map);
+    this.set(path, map);
+    return map;
+  }
+
+  /**
+   * Create an opaque value and insert it in the database.
+   *
+   * @param path: the path for the value.
+   *
+   * @returns the value that was created.
+   */
+  createValue(path: string): IObservableValue {
+    const schema = this._schemas[this._schemaId];
+    const field = schema.fields[path];
+    if (!field || field.type !== 'register') {
+      throw new Error(
+        `Cannot create a value for path '${path}', incompatible with schema.`
+      );
+    }
+    let val = new ObservableValue(this.manager, schema, this._recordId, path);
+    this._disposables.add(val);
+    this.set(path, val);
+    return val;
+  }
+
+  /**
+   * Get a value at a path, or `undefined` if it has not been set
+   * That value must already have been created using `createValue`.
+   *
+   * @param path: the path for the value.
+   */
+  getValue(path: string): ReadonlyJSONValue | undefined {
+    const ds = this.manager.datastore;
+    if (!ds) {
+      throw new Error('Cannot use model db before connection completed!');
+    }
+    const schema = this._schemas[this._schemaId];
+    const record = ds.get(schema).get(this._recordId);
+    return record && record[path];
+  }
+
+  /**
+   * Set a value at a path. That value must already have
+   * been created using `createValue`.
+   *
+   * @param path: the path for the value.
+   *
+   * @param value: the new value.
+   */
+  setValue(path: string, value: ReadonlyJSONValue): void {
+    const ds = this.manager.datastore;
+    if (!ds) {
+      throw new Error('Cannot use model db before connection completed!');
+    }
+    const table = ds.get(this._schemas[this._schemaId]);
+    this.withTransaction(() => {
+      table.update({
+        [this._recordId]: {
+          [path]: value
+        }
+      } as any);
+    });
+  }
+
+  /**
+   * Create a view onto a subtree of the model database.
+   *
+   * @param path: the path for the root of the subtree.
+   *
+   * @returns an `IModelDB` with a view onto the original
+   *   `IModelDB`, with `basePath` prepended to all paths.
+   */
+  view(path: string): IModelDB {
+    // If path does not resolve to a schema name
+    // append it to the recordId instead
+    let resolved = this._resolvePath(path, false);
+    let recordId = this._recordId;
+    if (this._schemas[resolved] === undefined) {
+      resolved = this._schemaId;
+      recordId = `${this._recordId}.${path}`;
+    }
+    const schemas = toArray(iterValues(this._schemas));
+    const manager = this.manager;
+    // TODO: resolve path?
+    return new DSModelDB({
+      schemas,
+      manager,
+      schemaId: resolved,
+      baseDB: this,
+      recordId: recordId
+    });
+  }
+
+  withTransaction(fn: (transactionId?: string) => void): void {
+    const ds = this.manager.datastore;
+    if (!ds) {
+      throw new Error('Cannot use model db before connection completed!');
+    }
+    if (ds.inTransaction) {
+      return fn();
+    }
+    const transactionId = ds.beginTransaction();
+    try {
+      fn(transactionId);
+    } finally {
+      ds.endTransaction();
+    }
+  }
+
+  /**
+   * Set a value at a path. Not intended to
+   * be called by user code, instead use the
+   * `create*` factory methods.
+   *
+   * @param path: the path to set the value at.
+   *
+   * @param value: the value to set at the path.
+   */
+  set(path: string, value: IObservable, resolved = false): void {
+    if (!resolved) {
+      path = this._resolvePath(path);
+    }
+    this._baseDB.set(path, value, true);
+  }
+
+  /**
+   * Dispose of the resources held by the database.
+   */
+  dispose(): void {
+    if (this.isDisposed) {
+      return;
+    }
+    this._isDisposed = true;
+    if (this._toDispose) {
+      (this._baseDB as Map<any, any>).clear();
+    }
+    this._disposables.dispose();
+  }
+
+  /**
+   * The base path for the `IModelDB`. This is prepended
+   * to all the paths that are passed in to the member
+   * functions of the object.
+   */
+  get basePath(): string {
+    return this._schemaId;
+  }
+
+  /**
+   * Whether the database has been disposed.
+   */
+  get isDisposed(): boolean {
+    return this._isDisposed;
+  }
+
+  /**
+   * Whether the database has been populated
+   * with model values prior to connection.
+   */
+  get isPrepopulated(): boolean {
+    return this.manager.isPrepopulated;
+  }
+
+  /**
+   * Whether the database is collaborative.
+   */
+  get isCollaborative(): boolean {
+    return true;
+  }
+
+  /**
+   * A promise that resolves when the database
+   * has connected to its backend, if any.
+   */
+  readonly connected: Promise<void>;
+
+  /**
+   * A map of the currently active collaborators
+   * for the database, including the local user.
+   */
+  collaborators: ICollaboratorMap;
+
+  /**
+   * The underlying datastore manager.
+   */
+  readonly manager: DatastoreManager;
+
+  /**
+   * Compute the fully resolved path for a path argument.
+   */
+  private _resolvePath(path: string, includeRecord = true): string {
+    if (this._schemaId) {
+      path = `${this._schemaId}.${path}`;
+    }
+    if (includeRecord && this._recordId) {
+      path = `${path}:${this._recordId}`;
+    }
+    return path;
+  }
+
+  private _schemaId: string;
+  private _baseDB: DSModelDB | Map<string, IObservable>;
+  private _schemas: { [key: string]: Schema };
+  private _recordId: string;
+  private _toDispose = false;
+  private _isDisposed = false;
+  private _disposables = new DisposableSet();
+}
+
+/**
+ *
+ */
+export namespace DSModelDB {
+  export interface ICreateOptions {
+    manager: DatastoreManager;
+    schemas: ReadonlyArray<Schema>;
+    schemaId: string;
+    recordId: string;
+    baseDB?: DSModelDB;
+  }
+}
diff --git a/packages/datastore/src/objiter.ts b/packages/datastore/src/objiter.ts
new file mode 100644
index 00000000000..ce955b9def9
--- /dev/null
+++ b/packages/datastore/src/objiter.ts
@@ -0,0 +1,273 @@
+/*-----------------------------------------------------------------------------
+| Copyright (c) 2014-2017, PhosphorJS Contributors
+|
+| Distributed under the terms of the BSD 3-Clause License.
+|
+| The full license is in the file LICENSE, distributed with this software.
+|----------------------------------------------------------------------------*/
+
+import { IIterator } from '@phosphor/algorithm';
+
+/**
+ * Create an iterator for the keys in an object.
+ *
+ * @param object - The object of interest.
+ *
+ * @returns A new iterator for the keys in the given object.
+ *
+ * #### Complexity
+ * Linear.
+ *
+ * #### Example
+ * ```typescript
+ * import { each, keys } from '@phosphor/algorithm';
+ *
+ * let data = { one: 1, two: 2, three: 3 };
+ *
+ * each(keys(data), key => { console.log(key); }); // 'one', 'two', 'three'
+ * ```
+ */
+export function iterKeys<T>(object: {
+  readonly [key: string]: T;
+}): IIterator<string> {
+  return new KeyIterator(object);
+}
+
+/**
+ * Create an iterator for the values in an object.
+ *
+ * @param object - The object of interest.
+ *
+ * @returns A new iterator for the values in the given object.
+ *
+ * #### Complexity
+ * Linear.
+ *
+ * #### Example
+ * ```typescript
+ * import { each, values } from '@phosphor/algorithm';
+ *
+ * let data = { one: 1, two: 2, three: 3 };
+ *
+ * each(values(data), value => { console.log(value); }); // 1, 2, 3
+ * ```
+ */
+export function iterValues<T>(object: {
+  readonly [key: string]: T;
+}): IIterator<T> {
+  return new ValueIterator<T>(object);
+}
+
+/**
+ * Create an iterator for the items in an object.
+ *
+ * @param object - The object of interest.
+ *
+ * @returns A new iterator for the items in the given object.
+ *
+ * #### Complexity
+ * Linear.
+ *
+ * #### Example
+ * ```typescript
+ * import { each, items } from '@phosphor/algorithm';
+ *
+ * let data = { one: 1, two: 2, three: 3 };
+ *
+ * each(items(data), value => { console.log(value); }); // ['one', 1], ['two', 2], ['three', 3]
+ * ```
+ */
+export function iterItems<T>(object: {
+  readonly [key: string]: T;
+}): IIterator<[string, T]> {
+  return new ItemIterator<T>(object);
+}
+
+/**
+ * An iterator for the keys in an object.
+ *
+ * #### Notes
+ * This iterator can be used for any JS object.
+ */
+export class KeyIterator implements IIterator<string> {
+  /**
+   * Construct a new key iterator.
+   *
+   * @param source - The object of interest.
+   *
+   * @param keys - The keys to iterate, if known.
+   */
+  constructor(
+    source: { readonly [key: string]: any },
+    keys = Object.keys(source)
+  ) {
+    this._source = source;
+    this._keys = keys;
+  }
+
+  /**
+   * Get an iterator over the object's values.
+   *
+   * @returns An iterator which yields the object's values.
+   */
+  iter(): IIterator<string> {
+    return this;
+  }
+
+  /**
+   * Create an independent clone of the iterator.
+   *
+   * @returns A new independent clone of the iterator.
+   */
+  clone(): IIterator<string> {
+    let result = new KeyIterator(this._source, this._keys);
+    result._index = this._index;
+    return result;
+  }
+
+  /**
+   * Get the next value from the iterator.
+   *
+   * @returns The next value from the iterator, or `undefined`.
+   */
+  next(): string | undefined {
+    if (this._index >= this._keys.length) {
+      return undefined;
+    }
+    let key = this._keys[this._index++];
+    if (key in this._source) {
+      return key;
+    }
+    return this.next();
+  }
+
+  private _index = 0;
+  private _keys: string[];
+  private _source: { readonly [key: string]: any };
+}
+
+/**
+ * An iterator for the values in an object.
+ *
+ * #### Notes
+ * This iterator can be used for any JS object.
+ */
+export class ValueIterator<T> implements IIterator<T> {
+  /**
+   * Construct a new value iterator.
+   *
+   * @param source - The object of interest.
+   *
+   * @param keys - The keys to iterate, if known.
+   */
+  constructor(
+    source: { readonly [key: string]: T },
+    keys = Object.keys(source)
+  ) {
+    this._source = source;
+    this._keys = keys;
+  }
+
+  /**
+   * Get an iterator over the object's values.
+   *
+   * @returns An iterator which yields the object's values.
+   */
+  iter(): IIterator<T> {
+    return this;
+  }
+
+  /**
+   * Create an independent clone of the iterator.
+   *
+   * @returns A new independent clone of the iterator.
+   */
+  clone(): IIterator<T> {
+    let result = new ValueIterator<T>(this._source, this._keys);
+    result._index = this._index;
+    return result;
+  }
+
+  /**
+   * Get the next value from the iterator.
+   *
+   * @returns The next value from the iterator, or `undefined`.
+   */
+  next(): T | undefined {
+    if (this._index >= this._keys.length) {
+      return undefined;
+    }
+    let key = this._keys[this._index++];
+    if (key in this._source) {
+      return this._source[key];
+    }
+    return this.next();
+  }
+
+  private _index = 0;
+  private _keys: string[];
+  private _source: { readonly [key: string]: T };
+}
+
+/**
+ * An iterator for the items in an object.
+ *
+ * #### Notes
+ * This iterator can be used for any JS object.
+ */
+export class ItemIterator<T> implements IIterator<[string, T]> {
+  /**
+   * Construct a new item iterator.
+   *
+   * @param source - The object of interest.
+   *
+   * @param keys - The keys to iterate, if known.
+   */
+  constructor(
+    source: { readonly [key: string]: T },
+    keys = Object.keys(source)
+  ) {
+    this._source = source;
+    this._keys = keys;
+  }
+
+  /**
+   * Get an iterator over the object's values.
+   *
+   * @returns An iterator which yields the object's values.
+   */
+  iter(): IIterator<[string, T]> {
+    return this;
+  }
+
+  /**
+   * Create an independent clone of the iterator.
+   *
+   * @returns A new independent clone of the iterator.
+   */
+  clone(): IIterator<[string, T]> {
+    let result = new ItemIterator<T>(this._source, this._keys);
+    result._index = this._index;
+    return result;
+  }
+
+  /**
+   * Get the next value from the iterator.
+   *
+   * @returns The next value from the iterator, or `undefined`.
+   */
+  next(): [string, T] | undefined {
+    if (this._index >= this._keys.length) {
+      return undefined;
+    }
+    let key = this._keys[this._index++];
+    if (key in this._source) {
+      return [key, this._source[key]];
+    }
+    return this.next();
+  }
+
+  private _index = 0;
+  private _keys: string[];
+  private _source: { readonly [key: string]: T };
+}
diff --git a/packages/datastore/src/observables/base.ts b/packages/datastore/src/observables/base.ts
new file mode 100644
index 00000000000..e9efc844b2e
--- /dev/null
+++ b/packages/datastore/src/observables/base.ts
@@ -0,0 +1,136 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import { Signal } from '@phosphor/signaling';
+
+import { Datastore, Schema } from '@phosphor/datastore';
+
+import { ReadonlyJSONValue } from '@phosphor/coreutils';
+
+import { DatastoreManager } from '../manager';
+
+/**
+ *
+ */
+export abstract class ObservableBase<T extends ReadonlyJSONValue> {
+  /**
+   *
+   */
+  constructor(
+    manager: DatastoreManager,
+    schema: Schema,
+    recordId: string,
+    fieldId: string
+  ) {
+    this.manager = manager;
+    this.schema = schema;
+    this.fieldId = fieldId;
+    this.recordID = recordId;
+    this.ds = manager.datastore;
+    manager.datastoreChanged.connect(
+      this._onDsChange,
+      this
+    );
+    const ds = this.ds;
+    if (ds) {
+      ds.changed.connect(
+        this._onChange,
+        this
+      );
+    }
+  }
+
+  /**
+   * Dispose of the resources held by the string.
+   */
+  dispose(): void {
+    if (this._isDisposed) {
+      return;
+    }
+    if (this.manager) {
+      this.manager = undefined!;
+    }
+    this._isDisposed = true;
+    Signal.clearData(this);
+  }
+
+  /**
+   * Test whether the object has been disposed.
+   *
+   * #### Notes
+   * This property is always safe to access.
+   */
+  get isDisposed(): boolean {
+    return this._isDisposed;
+  }
+
+  protected ensureBackend(): void {
+    if (this.ds === null) {
+      throw new Error('Cannot use model db before connection completed!');
+    }
+  }
+
+  protected abstract onChange(change: T): void;
+
+  private _onDsChange(
+    manager: DatastoreManager,
+    args: DatastoreManager.IChangedArgs
+  ) {
+    this.ds = args.datastore;
+    this.ds.changed.connect(
+      this._onChange,
+      this
+    );
+  }
+
+  private _onChange(ds: Datastore, args: Datastore.IChangedArgs) {
+    const local = Private.getLocalChange<T>(
+      ds,
+      this.schema,
+      this.recordID,
+      this.fieldId,
+      args.change
+    );
+    if (local !== undefined) {
+      this.onChange(local);
+    }
+  }
+
+  protected withTransaction(fn: () => void): void {
+    this.ensureBackend();
+    if (this.ds!.inTransaction) {
+      return fn();
+    }
+    this.ds!.beginTransaction();
+    try {
+      fn();
+    } finally {
+      this.ds!.endTransaction();
+    }
+  }
+
+  protected manager: DatastoreManager;
+  protected schema: Schema;
+  protected fieldId: string;
+  protected recordID: string;
+  protected ds: Datastore | null;
+  private _isDisposed = false;
+}
+
+namespace Private {
+  export function getLocalChange<T>(
+    ds: Datastore,
+    schema: Schema,
+    recordId: string,
+    fieldId: string,
+    change: Datastore.Change
+  ): T | undefined {
+    if (
+      change[schema.id] === undefined ||
+      change[schema.id][recordId] === undefined
+    ) {
+      return undefined;
+    }
+    return change[schema.id][recordId][fieldId] as T | undefined;
+  }
+}
diff --git a/packages/datastore/src/observables/index.ts b/packages/datastore/src/observables/index.ts
new file mode 100644
index 00000000000..b7d9ae6c5d3
--- /dev/null
+++ b/packages/datastore/src/observables/index.ts
@@ -0,0 +1,9 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+export * from './json';
+export * from './list';
+export * from './map';
+export * from './string';
+export * from './undoablelist';
+export * from './value';
diff --git a/packages/datastore/src/observables/json.ts b/packages/datastore/src/observables/json.ts
new file mode 100644
index 00000000000..09ef1ad9672
--- /dev/null
+++ b/packages/datastore/src/observables/json.ts
@@ -0,0 +1,79 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import { IObservableJSON } from '@jupyterlab/observables';
+
+import { JSONExt, JSONObject, JSONValue } from '@phosphor/coreutils';
+
+import { Schema } from '@phosphor/datastore';
+
+import { Message } from '@phosphor/messaging';
+
+import { ObservableMap } from './map';
+
+import { DatastoreManager } from '../manager';
+
+/**
+ * A concrete Observable map for JSON data.
+ */
+export class ObservableJSON extends ObservableMap<JSONValue> {
+  /**
+   * Construct a new observable JSON object.
+   */
+  constructor(
+    manager: DatastoreManager,
+    schema: Schema,
+    recordId: string,
+    fieldId: string,
+    options: ObservableJSON.IOptions = {}
+  ) {
+    super(manager, schema, recordId, fieldId, {
+      itemCmp: JSONExt.deepEqual
+    });
+  }
+
+  /**
+   * Serialize the model to JSON.
+   */
+  toJSON(): JSONObject {
+    const out: JSONObject = Object.create(null);
+    const keys = this.keys();
+
+    for (let key of keys) {
+      const value = this.get(key);
+
+      if (value !== undefined) {
+        out[key] = JSONExt.deepCopy(value);
+      }
+    }
+    return out;
+  }
+}
+
+/**
+ * The namespace for ObservableJSON static data.
+ */
+export namespace ObservableJSON {
+  /**
+   * The options use to initialize an observable JSON object.
+   */
+  export interface IOptions {}
+
+  /**
+   * An observable JSON change message.
+   */
+  export class ChangeMessage extends Message {
+    /**
+     * Create a new metadata changed message.
+     */
+    constructor(args: IObservableJSON.IChangedArgs) {
+      super('jsonvalue-changed');
+      this.args = args;
+    }
+
+    /**
+     * The arguments of the change.
+     */
+    readonly args: IObservableJSON.IChangedArgs;
+  }
+}
diff --git a/packages/datastore/src/observables/list.ts b/packages/datastore/src/observables/list.ts
new file mode 100644
index 00000000000..c742c3517ef
--- /dev/null
+++ b/packages/datastore/src/observables/list.ts
@@ -0,0 +1,517 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import { IObservableList } from '@jupyterlab/observables';
+
+import {
+  ArrayExt,
+  ArrayIterator,
+  IIterator,
+  IterableOrArrayLike,
+  toArray,
+  each
+} from '@phosphor/algorithm';
+
+import { ReadonlyJSONValue } from '@phosphor/coreutils';
+
+import { ListField, Schema } from '@phosphor/datastore';
+
+import { ISignal, Signal } from '@phosphor/signaling';
+
+import { ObservableBase } from './base';
+
+import { DatastoreManager } from '../manager';
+
+/**
+ * A concrete implementation of [[IObservableList]].
+ */
+export class ObservableList<T extends ReadonlyJSONValue>
+  extends ObservableBase<ListField.Change<T>>
+  implements IObservableList<T> {
+  /**
+   * Construct a new observable list.
+   */
+  constructor(
+    manager: DatastoreManager,
+    schema: Schema,
+    recordId: string,
+    fieldId: string,
+    options: ObservableList.IOptions<T> = {}
+  ) {
+    super(manager, schema, recordId, fieldId);
+    this._itemCmp = options.itemCmp || Private.itemCmp;
+  }
+
+  /**
+   * The type of this object.
+   */
+  get type(): 'List' {
+    return 'List';
+  }
+
+  /**
+   * A signal emitted when the list has changed.
+   */
+  get changed(): ISignal<this, IObservableList.IChangedArgs<T>> {
+    return this._changed;
+  }
+
+  /**
+   * The length of the list.
+   */
+  get length(): number {
+    return this._array.length;
+  }
+
+  /**
+   * Create an iterator over the values in the list.
+   *
+   * @returns A new iterator starting at the front of the list.
+   *
+   * #### Complexity
+   * Constant.
+   *
+   * #### Iterator Validity
+   * No changes.
+   */
+  iter(): IIterator<T> {
+    return new ArrayIterator(this._array);
+  }
+
+  /**
+   * Get the value at the specified index.
+   *
+   * @param index - The positive integer index of interest.
+   *
+   * @returns The value at the specified index.
+   *
+   * #### Undefined Behavior
+   * An `index` which is non-integral or out of range.
+   */
+  get(index: number): T | undefined {
+    if (this.ds === undefined) {
+      return undefined;
+    }
+    return this._array[index];
+  }
+
+  /**
+   * Set the value at the specified index.
+   *
+   * @param index - The positive integer index of interest.
+   *
+   * @param value - The value to set at the specified index.
+   *
+   * #### Complexity
+   * Constant.
+   *
+   * #### Iterator Validity
+   * No changes.
+   *
+   * #### Undefined Behavior
+   * An `index` which is non-integral or out of range.
+   */
+  set(index: number, value: T): void {
+    let oldValue = this._array[index];
+    if (value === undefined) {
+      throw new Error('Cannot set an undefined item');
+    }
+    // Bail if the value does not change.
+    let itemCmp = this._itemCmp;
+    if (itemCmp(oldValue, value)) {
+      return;
+    }
+
+    const table = this.ds!.get(this.schema);
+    this.withTransaction(() => {
+      table.update({
+        [this.recordID]: {
+          [this.fieldId]: {
+            index,
+            remove: 1,
+            values: [value]
+          }
+        }
+      } as any);
+    });
+  }
+
+  /**
+   * Add a value to the end of the list.
+   *
+   * @param value - The value to add to the end of the list.
+   *
+   * @returns The new length of the list.
+   *
+   * #### Complexity
+   * Constant.
+   *
+   * #### Iterator Validity
+   * No changes.
+   */
+  push(value: T): number {
+    let current = this._array;
+    const table = this.ds!.get(this.schema);
+    this.withTransaction(() => {
+      table.update({
+        [this.recordID]: {
+          [this.fieldId]: {
+            index: current.length,
+            remove: 0,
+            values: [value]
+          }
+        }
+      } as any);
+    });
+    return current.length + 1;
+  }
+
+  /**
+   * Insert a value into the list at a specific index.
+   *
+   * @param index - The index at which to insert the value.
+   *
+   * @param value - The value to set at the specified index.
+   *
+   * #### Complexity
+   * Linear.
+   *
+   * #### Iterator Validity
+   * No changes.
+   *
+   * #### Notes
+   * The `index` will be clamped to the bounds of the list.
+   *
+   * #### Undefined Behavior
+   * An `index` which is non-integral.
+   */
+  insert(index: number, value: T): void {
+    this.ensureBackend();
+    const table = this.ds!.get(this.schema);
+    this.withTransaction(() => {
+      table.update({
+        [this.recordID]: {
+          [this.fieldId]: {
+            index,
+            remove: 0,
+            values: [value]
+          }
+        }
+      } as any);
+    });
+  }
+
+  /**
+   * Remove the first occurrence of a value from the list.
+   *
+   * @param value - The value of interest.
+   *
+   * @returns The index of the removed value, or `-1` if the value
+   *   is not contained in the list.
+   *
+   * #### Complexity
+   * Linear.
+   *
+   * #### Iterator Validity
+   * Iterators pointing at the removed value and beyond are invalidated.
+   */
+  removeValue(value: T): number {
+    let itemCmp = this._itemCmp;
+    let index = ArrayExt.findFirstIndex(this._array, item => {
+      return itemCmp(item, value);
+    });
+    this.remove(index);
+    return index;
+  }
+
+  /**
+   * Remove and return the value at a specific index.
+   *
+   * @param index - The index of the value of interest.
+   *
+   * @returns The value at the specified index, or `undefined` if the
+   *   index is out of range.
+   *
+   * #### Complexity
+   * Constant.
+   *
+   * #### Iterator Validity
+   * Iterators pointing at the removed value and beyond are invalidated.
+   *
+   * #### Undefined Behavior
+   * An `index` which is non-integral.
+   */
+  remove(index: number): T | undefined {
+    if (index < 0 || index >= this.length) {
+      return;
+    }
+    const table = this.ds!.get(this.schema);
+    this.withTransaction(() => {
+      table.update({
+        [this.recordID]: {
+          [this.fieldId]: {
+            index,
+            remove: 1,
+            values: []
+          }
+        }
+      } as any);
+    });
+  }
+
+  /**
+   * Remove all values from the list.
+   *
+   * #### Complexity
+   * Linear.
+   *
+   * #### Iterator Validity
+   * All current iterators are invalidated.
+   */
+  clear(): void {
+    this.ensureBackend();
+    const table = this.ds!.get(this.schema);
+    this.withTransaction(() => {
+      table.update({
+        [this.recordID]: {
+          [this.fieldId]: {
+            index: 0,
+            remove: this.length,
+            values: []
+          }
+        }
+      } as any);
+    });
+  }
+
+  /**
+   * Move a value from one index to another.
+   *
+   * @parm fromIndex - The index of the element to move.
+   *
+   * @param toIndex - The index to move the element to.
+   *
+   * #### Complexity
+   * Constant.
+   *
+   * #### Iterator Validity
+   * Iterators pointing at the lesser of the `fromIndex` and the `toIndex`
+   * and beyond are invalidated.
+   *
+   * #### Undefined Behavior
+   * A `fromIndex` or a `toIndex` which is non-integral.
+   */
+  move(fromIndex: number, toIndex: number): void {
+    const array = this._array;
+    let n = array.length;
+    if (n <= 1) {
+      return;
+    }
+    if (fromIndex < 0) {
+      fromIndex = Math.max(0, fromIndex + n);
+    } else {
+      fromIndex = Math.min(fromIndex, n - 1);
+    }
+    if (toIndex < 0) {
+      toIndex = Math.max(0, toIndex + n);
+    } else {
+      toIndex = Math.min(toIndex, n - 1);
+    }
+    if (fromIndex === toIndex) {
+      return;
+    }
+
+    const table = this.ds!.get(this.schema);
+    this.withTransaction(() => {
+      table.update({
+        [this.recordID]: {
+          [this.fieldId]: [
+            {
+              index: fromIndex,
+              remove: 1,
+              values: []
+            },
+            {
+              index: toIndex,
+              remove: 0,
+              values: [array[fromIndex]]
+            }
+          ]
+        }
+      } as any);
+    });
+  }
+
+  /**
+   * Push a set of values to the back of the list.
+   *
+   * @param values - An iterable or array-like set of values to add.
+   *
+   * @returns The new length of the list.
+   *
+   * #### Complexity
+   * Linear.
+   *
+   * #### Iterator Validity
+   * No changes.
+   */
+  pushAll(values: IterableOrArrayLike<T>): number {
+    let length = this.length;
+    const table = this.ds!.get(this.schema);
+    const newValues = toArray(values);
+    this.withTransaction(() => {
+      table.update({
+        [this.recordID]: {
+          [this.fieldId]: {
+            index: length,
+            remove: 0,
+            values: newValues
+          }
+        }
+      } as any);
+    });
+    return length + newValues.length;
+  }
+
+  /**
+   * Insert a set of items into the list at the specified index.
+   *
+   * @param index - The index at which to insert the values.
+   *
+   * @param values - The values to insert at the specified index.
+   *
+   * #### Complexity.
+   * Linear.
+   *
+   * #### Iterator Validity
+   * No changes.
+   *
+   * #### Notes
+   * The `index` will be clamped to the bounds of the list.
+   *
+   * #### Undefined Behavior.
+   * An `index` which is non-integral.
+   */
+  insertAll(index: number, values: IterableOrArrayLike<T>): void {
+    this.ensureBackend();
+    const table = this.ds!.get(this.schema);
+    this.withTransaction(() => {
+      table.update({
+        [this.recordID]: {
+          [this.fieldId]: {
+            index,
+            remove: 0,
+            values: toArray(values)
+          }
+        }
+      } as any);
+    });
+  }
+
+  /**
+   * Remove a range of items from the list.
+   *
+   * @param startIndex - The start index of the range to remove (inclusive).
+   *
+   * @param endIndex - The end index of the range to remove (exclusive).
+   *
+   * @returns The new length of the list.
+   *
+   * #### Complexity
+   * Linear.
+   *
+   * #### Iterator Validity
+   * Iterators pointing to the first removed value and beyond are invalid.
+   *
+   * #### Undefined Behavior
+   * A `startIndex` or `endIndex` which is non-integral.
+   */
+  removeRange(startIndex: number, endIndex: number): number {
+    const length = this.length;
+    const table = this.ds!.get(this.schema);
+    this.withTransaction(() => {
+      table.update({
+        [this.recordID]: {
+          [this.fieldId]: {
+            startIndex,
+            remove: endIndex - startIndex,
+            values: []
+          }
+        }
+      } as any);
+    });
+    return length - (endIndex - startIndex);
+  }
+
+  protected onChange(change: ListField.Change<T>): void {
+    each(change, c => {
+      // Check for 1-to-1 replacement (translate to `set`)
+      if (c.removed.length === 1 && c.inserted.length === 1) {
+        this._changed.emit({
+          type: 'set',
+          newIndex: c.index,
+          oldIndex: c.index,
+          newValues: c.inserted,
+          oldValues: c.removed
+        });
+      } else {
+        if (c.removed.length > 0) {
+          this._changed.emit({
+            type: 'remove',
+            newIndex: c.index,
+            oldIndex: c.index,
+            newValues: [],
+            oldValues: c.removed
+          });
+        }
+        if (c.inserted.length > 0) {
+          this._changed.emit({
+            type: 'add',
+            newIndex: c.index,
+            oldIndex: c.index,
+            newValues: c.inserted,
+            oldValues: []
+          });
+        }
+      }
+    });
+  }
+
+  private get _array(): ReadonlyArray<T> {
+    this.ensureBackend();
+    const record = this.ds!.get(this.schema).get(this.recordID);
+    return record ? (record[this.fieldId] as ReadonlyArray<T>) : [];
+  }
+
+  private _itemCmp: (first: T, second: T) => boolean;
+  private _changed = new Signal<this, IObservableList.IChangedArgs<T>>(this);
+}
+
+/**
+ * The namespace for `ObservableList` class statics.
+ */
+export namespace ObservableList {
+  /**
+   * The options used to initialize an observable map.
+   */
+  export interface IOptions<T> {
+    /**
+     * The item comparison function for change detection on `set`.
+     *
+     * If not given, strict `===` equality will be used.
+     */
+    itemCmp?: (first: T, second: T) => boolean;
+  }
+}
+
+/**
+ * The namespace for module private data.
+ */
+namespace Private {
+  /**
+   * The default strict equality item cmp.
+   */
+  export function itemCmp(first: any, second: any): boolean {
+    return first === second;
+  }
+}
diff --git a/packages/datastore/src/observables/map.ts b/packages/datastore/src/observables/map.ts
new file mode 100644
index 00000000000..ca8ea93d16d
--- /dev/null
+++ b/packages/datastore/src/observables/map.ts
@@ -0,0 +1,257 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import { IObservableMap } from '@jupyterlab/observables';
+
+import { each } from '@phosphor/algorithm';
+
+import { ReadonlyJSONValue, ReadonlyJSONObject } from '@phosphor/coreutils';
+
+import { MapField, Schema } from '@phosphor/datastore';
+
+import { ISignal, Signal } from '@phosphor/signaling';
+
+import { ObservableBase } from './base';
+
+import { iterItems } from '../objiter';
+
+import { DatastoreManager } from '../manager';
+
+/**
+ * A concrete implementation of IObservbleMap<T>.
+ */
+export class ObservableMap<T extends ReadonlyJSONValue>
+  extends ObservableBase<MapField.Change<T>>
+  implements IObservableMap<T> {
+  /**
+   * Construct a new observable map.
+   */
+  constructor(
+    manager: DatastoreManager,
+    schema: Schema,
+    recordId: string,
+    fieldId: string,
+    options: ObservableMap.IOptions<T> = {}
+  ) {
+    super(manager, schema, recordId, fieldId);
+    this._itemCmp = options.itemCmp || Private.itemCmp;
+  }
+
+  /**
+   * The type of the Observable.
+   */
+  get type(): 'Map' {
+    return 'Map';
+  }
+
+  /**
+   * A signal emitted when the map has changed.
+   */
+  get changed(): ISignal<this, IObservableMap.IChangedArgs<T>> {
+    return this._changed;
+  }
+
+  /**
+   * The number of key-value pairs in the map.
+   */
+  get size(): number {
+    return Object.keys(this._map).length;
+  }
+
+  /**
+   * Set a key-value pair in the map
+   *
+   * @param key - The key to set.
+   *
+   * @param value - The value for the key.
+   *
+   * @returns the old value for the key, or undefined
+   *   if that did not exist.
+   *
+   * @throws if the new value is undefined.
+   *
+   * #### Notes
+   * This is a no-op if the value does not change.
+   */
+  set(key: string, value: T): T | undefined {
+    let oldVal = this._map[key] as T | undefined;
+    if (value === undefined) {
+      throw Error('Cannot set an undefined value, use remove');
+    }
+    // Bail if the value does not change.
+    let itemCmp = this._itemCmp;
+    if (oldVal !== undefined && itemCmp(oldVal, value)) {
+      return oldVal;
+    }
+
+    const table = this.ds!.get(this.schema);
+    this.withTransaction(() => {
+      table.update({
+        [this.recordID]: {
+          [this.fieldId]: {
+            [key]: value
+          }
+        }
+      } as any);
+    });
+    return oldVal;
+  }
+
+  /**
+   * Get a value for a given key.
+   *
+   * @param key - the key.
+   *
+   * @returns the value for that key.
+   */
+  get(key: string): T | undefined {
+    return this._map[key] as T | undefined;
+  }
+
+  /**
+   * Check whether the map has a key.
+   *
+   * @param key - the key to check.
+   *
+   * @returns `true` if the map has the key, `false` otherwise.
+   */
+  has(key: string): boolean {
+    return this._map[key] !== undefined;
+  }
+
+  /**
+   * Get a list of the keys in the map.
+   *
+   * @returns - a list of keys.
+   */
+  keys(): string[] {
+    return Object.keys(this._map);
+  }
+
+  /**
+   * Get a list of the values in the map.
+   *
+   * @returns - a list of values.
+   */
+  values(): T[] {
+    return Object.keys(this._map).map(k => this._map[k] as T);
+  }
+
+  /**
+   * Remove a key from the map
+   *
+   * @param key - the key to remove.
+   *
+   * @returns the value of the given key,
+   *   or undefined if that does not exist.
+   */
+  delete(key: string): T | undefined {
+    let oldVal = this._map[key] as T | undefined;
+
+    const table = this.ds!.get(this.schema);
+    this.withTransaction(() => {
+      table.update({
+        [this.recordID]: {
+          [this.fieldId]: {
+            [key]: null
+          }
+        }
+      } as any);
+    });
+    return oldVal;
+  }
+
+  /**
+   * Set the ObservableMap to an empty map.
+   */
+  clear(): void {
+    if (this.size < 1) {
+      // Nothing to clear
+      return;
+    }
+    // Delete one by one to emit the correct signals.
+    let keyList = this.keys();
+    const update: { [key: string]: T | null } = {};
+    for (let key of keyList) {
+      update[key] = null;
+    }
+
+    const table = this.ds!.get(this.schema);
+    this.withTransaction(() => {
+      table.update({
+        [this.recordID]: {
+          [this.fieldId]: update
+        }
+      } as any);
+    });
+  }
+
+  protected onChange(change: MapField.Change<T>): void {
+    each(iterItems(change.current), ([key, cur]) => {
+      const prev = change.previous[key];
+      if (prev === undefined || prev === null) {
+        this._changed.emit({
+          type: 'add',
+          key,
+          oldValue: undefined,
+          newValue: cur === null ? undefined : cur
+        });
+      }
+    });
+    each(iterItems(change.previous), ([key, prev]) => {
+      const cur = change.current[key];
+      if (cur === undefined || cur === null) {
+        this._changed.emit({
+          type: 'remove',
+          key,
+          oldValue: prev === null ? undefined : prev,
+          newValue: undefined
+        });
+      } else if (!this._itemCmp(cur, prev)) {
+        this._changed.emit({
+          type: 'change',
+          key,
+          oldValue: prev === null ? undefined : prev,
+          newValue: cur
+        });
+      }
+    });
+  }
+
+  private get _map(): ReadonlyJSONObject {
+    this.ensureBackend();
+    const record = this.ds!.get(this.schema).get(this.recordID);
+    return record ? (record[this.fieldId] as ReadonlyJSONObject) : {};
+  }
+  private _itemCmp: (first: T | null, second: T | null) => boolean;
+  private _changed = new Signal<this, IObservableMap.IChangedArgs<T>>(this);
+}
+
+/**
+ * The namespace for `ObservableMap` class statics.
+ */
+export namespace ObservableMap {
+  /**
+   * The options used to initialize an observable map.
+   */
+  export interface IOptions<T> {
+    /**
+     * The item comparison function for change detection on `set`.
+     *
+     * If not given, strict `===` equality will be used.
+     */
+    itemCmp?: (first: T, second: T) => boolean;
+  }
+}
+
+/**
+ * The namespace for module private data.
+ */
+namespace Private {
+  /**
+   * The default strict equality item comparator.
+   */
+  export function itemCmp(first: any, second: any): boolean {
+    return first === second;
+  }
+}
diff --git a/packages/datastore/src/observables/string.ts b/packages/datastore/src/observables/string.ts
new file mode 100644
index 00000000000..3858ece1fb8
--- /dev/null
+++ b/packages/datastore/src/observables/string.ts
@@ -0,0 +1,153 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import { IObservableString } from '@jupyterlab/observables';
+
+import { ISignal, Signal } from '@phosphor/signaling';
+
+import { TextField } from '@phosphor/datastore';
+
+import { ObservableBase } from './base';
+
+/**
+ *
+ */
+export class ObservableString extends ObservableBase<TextField.Change>
+  implements IObservableString {
+  /**
+   * The type of this object.
+   */
+  get type(): 'String' {
+    return 'String';
+  }
+
+  /**
+   * A signal emitted when the string has changed.
+   */
+  get changed(): ISignal<this, IObservableString.IChangedArgs> {
+    return this._changed;
+  }
+
+  /**
+   * The value of the string.
+   */
+  get text(): string | undefined {
+    if (this.ds === null) {
+      return undefined;
+    }
+    const record = this.ds!.get(this.schema).get(this.recordID);
+    return record ? (record[this.fieldId] as string) : '';
+  }
+
+  set text(value: string | undefined) {
+    if (this.ds === null && value === undefined) {
+      return;
+    }
+    this.ensureBackend();
+    let old = this.text;
+    if (old === value) {
+      return;
+    }
+    const table = this.ds!.get(this.schema);
+    this.withTransaction(() => {
+      table.update({
+        [this.recordID]: {
+          [this.fieldId]: {
+            index: 0,
+            remove: old ? old.length : 0,
+            text: value
+          }
+        }
+      } as any);
+    });
+  }
+
+  /**
+   * Insert a substring.
+   *
+   * @param index - The starting index.
+   *
+   * @param text - The substring to insert.
+   */
+  insert(index: number, text: string): void {
+    this.ensureBackend();
+    const table = this.ds!.get(this.schema);
+    this.withTransaction(() => {
+      table.update({
+        [this.recordID]: {
+          [this.fieldId]: {
+            index,
+            remove: 0,
+            text
+          }
+        }
+      } as any);
+    });
+  }
+
+  /**
+   * Remove a substring.
+   *
+   * @param start - The starting index.
+   *
+   * @param end - The ending index.
+   */
+  remove(start: number, end: number): void {
+    this.ensureBackend();
+    const table = this.ds!.get(this.schema);
+    this.withTransaction(() => {
+      table.update({
+        [this.recordID]: {
+          [this.fieldId]: {
+            index: start,
+            remove: end - start,
+            text: ''
+          }
+        }
+      } as any);
+    });
+  }
+
+  /**
+   * Set the ObservableString to an empty string.
+   */
+  clear(): void {
+    this.ensureBackend();
+    const table = this.ds!.get(this.schema);
+    const current = this.text;
+    this.withTransaction(() => {
+      table.update({
+        [this.recordID]: {
+          [this.fieldId]: {
+            index: 0,
+            remove: current ? current.length : 0,
+            text: ''
+          }
+        }
+      } as any);
+    });
+  }
+
+  protected onChange(change: TextField.Change) {
+    for (let c of change) {
+      if (c.removed) {
+        this._changed.emit({
+          type: 'remove',
+          start: c.index,
+          end: c.index + c.removed.length,
+          value: c.removed
+        });
+      }
+      if (c.inserted) {
+        this._changed.emit({
+          type: 'insert',
+          start: c.index,
+          end: c.index,
+          value: c.inserted
+        });
+      }
+    }
+  }
+
+  private _changed = new Signal<this, IObservableString.IChangedArgs>(this);
+}
diff --git a/packages/datastore/src/observables/undoablelist.ts b/packages/datastore/src/observables/undoablelist.ts
new file mode 100644
index 00000000000..f2517887cf6
--- /dev/null
+++ b/packages/datastore/src/observables/undoablelist.ts
@@ -0,0 +1,273 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import {
+  IObservableUndoableList,
+  ISerializer,
+  IObservableList
+} from '@jupyterlab/observables';
+
+import { each } from '@phosphor/algorithm';
+
+import { ReadonlyJSONValue } from '@phosphor/coreutils';
+
+import { Schema } from '@phosphor/datastore';
+
+import { ObservableList } from './list';
+
+import { DatastoreManager } from '../manager';
+
+/**
+ * A concrete implementation of an observable undoable list.
+ */
+export class ObservableUndoableList<T extends ReadonlyJSONValue>
+  extends ObservableList<T>
+  implements IObservableUndoableList<T> {
+  /**
+   * Construct a new undoable observable list.
+   */
+  constructor(
+    manager: DatastoreManager,
+    schema: Schema,
+    recordId: string,
+    fieldId: string,
+    serializer: ISerializer<T>
+  ) {
+    super(manager, schema, recordId, fieldId);
+    this._serializer = serializer;
+    this.changed.connect(
+      this._onListChanged,
+      this
+    );
+  }
+
+  /**
+   * Whether the object can redo changes.
+   */
+  get canRedo(): boolean {
+    return this._index < this._stack.length - 1;
+  }
+
+  /**
+   * Whether the object can undo changes.
+   */
+  get canUndo(): boolean {
+    return this._index >= 0;
+  }
+
+  /**
+   * Begin a compound operation.
+   *
+   * @param isUndoAble - Whether the operation is undoable.
+   *   The default is `true`.
+   */
+  beginCompoundOperation(isUndoAble?: boolean): void {
+    this._inCompound = true;
+    this._isUndoable = isUndoAble !== false;
+    this._madeCompoundChange = false;
+  }
+
+  /**
+   * End a compound operation.
+   */
+  endCompoundOperation(): void {
+    this._inCompound = false;
+    this._isUndoable = true;
+    if (this._madeCompoundChange) {
+      this._index++;
+    }
+  }
+
+  /**
+   * Undo an operation.
+   */
+  undo(): void {
+    if (!this.canUndo) {
+      return;
+    }
+    let changes = this._stack[this._index];
+    this._isUndoable = false;
+    for (let change of changes.reverse()) {
+      this._undoChange(change);
+    }
+    this._isUndoable = true;
+    this._index--;
+  }
+
+  /**
+   * Redo an operation.
+   */
+  redo(): void {
+    if (!this.canRedo) {
+      return;
+    }
+    this._index++;
+    let changes = this._stack[this._index];
+    this._isUndoable = false;
+    for (let change of changes) {
+      this._redoChange(change);
+    }
+    this._isUndoable = true;
+  }
+
+  /**
+   * Clear the change stack.
+   */
+  clearUndo(): void {
+    this._index = -1;
+    this._stack = [];
+  }
+
+  /**
+   * Handle a change in the list.
+   */
+  private _onListChanged(
+    list: IObservableList<T>,
+    change: IObservableList.IChangedArgs<T>
+  ): void {
+    if (this.isDisposed || !this._isUndoable) {
+      return;
+    }
+    // Clear everything after this position if necessary.
+    if (!this._inCompound || !this._madeCompoundChange) {
+      this._stack = this._stack.slice(0, this._index + 1);
+    }
+    // Copy the change.
+    let evt = this._copyChange(change);
+    // Put the change in the stack.
+    if (this._stack[this._index + 1]) {
+      this._stack[this._index + 1].push(evt);
+    } else {
+      this._stack.push([evt]);
+    }
+    // If not in a compound operation, increase index.
+    if (!this._inCompound) {
+      this._index++;
+    } else {
+      this._madeCompoundChange = true;
+    }
+  }
+
+  /**
+   * Undo a change event.
+   */
+  private _undoChange(
+    change: IObservableList.IChangedArgs<ReadonlyJSONValue>
+  ): void {
+    let index = 0;
+    let serializer = this._serializer;
+    switch (change.type) {
+      case 'add':
+        each(change.newValues, () => {
+          this.remove(change.newIndex);
+        });
+        break;
+      case 'set':
+        index = change.oldIndex;
+        each(change.oldValues, value => {
+          this.set(index++, serializer.fromJSON(value));
+        });
+        break;
+      case 'remove':
+        index = change.oldIndex;
+        each(change.oldValues, value => {
+          this.insert(index++, serializer.fromJSON(value));
+        });
+        break;
+      case 'move':
+        this.move(change.newIndex, change.oldIndex);
+        break;
+      default:
+        return;
+    }
+  }
+
+  /**
+   * Redo a change event.
+   */
+  private _redoChange(
+    change: IObservableList.IChangedArgs<ReadonlyJSONValue>
+  ): void {
+    let index = 0;
+    let serializer = this._serializer;
+    switch (change.type) {
+      case 'add':
+        index = change.newIndex;
+        each(change.newValues, value => {
+          this.insert(index++, serializer.fromJSON(value));
+        });
+        break;
+      case 'set':
+        index = change.newIndex;
+        each(change.newValues, value => {
+          this.set(change.newIndex++, serializer.fromJSON(value));
+        });
+        break;
+      case 'remove':
+        each(change.oldValues, () => {
+          this.remove(change.oldIndex);
+        });
+        break;
+      case 'move':
+        this.move(change.oldIndex, change.newIndex);
+        break;
+      default:
+        return;
+    }
+  }
+
+  /**
+   * Copy a change as JSON.
+   */
+  private _copyChange(
+    change: IObservableList.IChangedArgs<T>
+  ): IObservableList.IChangedArgs<ReadonlyJSONValue> {
+    let oldValues: ReadonlyJSONValue[] = [];
+    each(change.oldValues, value => {
+      oldValues.push(this._serializer.toJSON(value));
+    });
+    let newValues: ReadonlyJSONValue[] = [];
+    each(change.newValues, value => {
+      newValues.push(this._serializer.toJSON(value));
+    });
+    return {
+      type: change.type,
+      oldIndex: change.oldIndex,
+      newIndex: change.newIndex,
+      oldValues,
+      newValues
+    };
+  }
+
+  private _inCompound = false;
+  private _isUndoable = true;
+  private _madeCompoundChange = false;
+  private _index = -1;
+  private _stack: IObservableList.IChangedArgs<ReadonlyJSONValue>[][] = [];
+  private _serializer: ISerializer<T>;
+}
+
+/**
+ * Namespace for ObservableUndoableList utilities.
+ */
+export namespace ObservableUndoableList {
+  /**
+   * A default, identity serializer.
+   */
+  export class IdentitySerializer<T extends ReadonlyJSONValue>
+    implements ISerializer<T> {
+    /**
+     * Identity serialize.
+     */
+    toJSON(value: T): ReadonlyJSONValue {
+      return value;
+    }
+
+    /**
+     * Identity deserialize.
+     */
+    fromJSON(value: ReadonlyJSONValue): T {
+      return value as T;
+    }
+  }
+}
diff --git a/packages/datastore/src/observables/value.ts b/packages/datastore/src/observables/value.ts
new file mode 100644
index 00000000000..f0263d43145
--- /dev/null
+++ b/packages/datastore/src/observables/value.ts
@@ -0,0 +1,69 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import { IObservableValue } from '@jupyterlab/observables';
+
+import { JSONValue, JSONExt, ReadonlyJSONValue } from '@phosphor/coreutils';
+
+import { RegisterField } from '@phosphor/datastore';
+
+import { ISignal, Signal } from '@phosphor/signaling';
+
+import { ObservableBase } from './base';
+
+/**
+ * A concrete implementation of an `IObservableValue`.
+ */
+export class ObservableValue
+  extends ObservableBase<RegisterField.Change<ReadonlyJSONValue>>
+  implements IObservableValue {
+  /**
+   * The observable type.
+   */
+  get type(): 'Value' {
+    return 'Value';
+  }
+
+  /**
+   * A signal emitted when the value has changed.
+   */
+  get changed(): ISignal<this, IObservableValue.IChangedArgs> {
+    return this._changed;
+  }
+
+  /**
+   * Get the current value, or `undefined` if it has not been set.
+   */
+  get(): JSONValue | undefined {
+    this.ensureBackend();
+    const record = this.ds!.get(this.schema).get(this.recordID);
+    return record ? (record[this.fieldId] as JSONValue) : undefined;
+  }
+
+  /**
+   * Set the current value.
+   */
+  set(value: JSONValue): void {
+    let oldValue = this.get();
+    if (oldValue !== undefined && JSONExt.deepEqual(oldValue, value)) {
+      return;
+    }
+    const table = this.ds!.get(this.schema);
+    this.withTransaction(() => {
+      table.update({
+        [this.recordID]: {
+          [this.fieldId]: value
+        }
+      } as any);
+    });
+  }
+
+  protected onChange(change: RegisterField.Change<ReadonlyJSONValue>) {
+    this._changed.emit({
+      oldValue: change.previous,
+      newValue: change.current
+    });
+  }
+
+  private _changed = new Signal<this, IObservableValue.IChangedArgs>(this);
+}
diff --git a/packages/datastore/src/rest.ts b/packages/datastore/src/rest.ts
new file mode 100644
index 00000000000..1c4756b7bfd
--- /dev/null
+++ b/packages/datastore/src/rest.ts
@@ -0,0 +1,76 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import { URLExt } from '@jupyterlab/coreutils';
+
+import { ServerConnection } from '@jupyterlab/services';
+
+/**
+ *
+ */
+const DATASTORE_REST_URL = '/lab/api/datastore';
+
+/**
+ * Query the server for current, accessible collaborations.
+ *
+ * @param options - The options to the function.
+ */
+export async function currentCollaborations(
+  options?: currentCollaborations.IOptions
+): Promise<currentCollaborations.CollaborationMap> {
+  const settings =
+    (options && options.serverSettings) || ServerConnection.makeSettings();
+  const token = settings.token;
+  const queryParams = [];
+
+  let url;
+  url = URLExt.join(settings.baseUrl, DATASTORE_REST_URL);
+
+  if (token) {
+    queryParams.push(`token=${encodeURIComponent(token)}`);
+  }
+  if (queryParams) {
+    url = url + `?${queryParams.join('&')}`;
+  }
+  const response = await ServerConnection.makeRequest(url, {}, settings);
+  return response.json();
+}
+
+/**
+ * currentCollaborations type declarations.
+ */
+export namespace currentCollaborations {
+  /**
+   * Information about a single collaboration.
+   */
+  export type CollaborationInfo = {
+    /**
+     * A unique id of the collaboration.
+     */
+    id: string;
+
+    /**
+     * A user-friendly name for the session (not necessarily unique)
+     */
+    friendlyName: string;
+  };
+
+  /**
+   * A map of collaboration infos by their id.
+   */
+  export type CollaborationMap = {
+    collaborations: {
+      [id: string]: CollaborationInfo;
+    };
+  };
+
+  /**
+   * Options to currentSessions
+   */
+  export interface IOptions {
+    /**
+     * The server settings for the session.
+     */
+    serverSettings?: ServerConnection.ISettings;
+  }
+}
diff --git a/packages/datastore/src/wsmessages.ts b/packages/datastore/src/wsmessages.ts
new file mode 100644
index 00000000000..4fd44270869
--- /dev/null
+++ b/packages/datastore/src/wsmessages.ts
@@ -0,0 +1,376 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import { ReadonlyJSONObject, UUID } from '@phosphor/coreutils';
+
+import { Datastore } from '@phosphor/datastore';
+
+/**
+ * Namespace for datastore collaboration statics.
+ */
+export namespace Collaboration {
+  /**
+   * A transaction with a serial number.
+   */
+  export type SerialTransaction = Datastore.Transaction & {
+    /**
+     * A serial number given by the server.
+     */
+    serial: number;
+  };
+
+  /**
+   * A lookup for transactions by their transaction id.
+   */
+  export type SerialTransactionMap = { [key: string]: SerialTransaction };
+
+  /**
+   *
+   */
+  export type Base = ReadonlyJSONObject & {
+    /**
+     * The unique message id.
+     */
+    msgId: string;
+  };
+
+  /**
+   * Maps a msgType to the corresponding type.
+   */
+  export interface ITypeMap {
+    'storeid-request': StoreIdRequest;
+    'storeid-reply': StoreIdReply;
+    'transaction-broadcast': TransactionBroadcast;
+    'transaction-ack': TransactionAck;
+    'history-request': HistoryRequest;
+    'history-reply': HistoryReply;
+    'transaction-request': TransactionRequest;
+    'transaction-reply': TransactionReply;
+    'serial-request': SerialRequest;
+    'serial-reply': SerialReply;
+    'permissions-request': PermissionsRequest;
+    'permissions-reply': PermissionsReply;
+    'serial-update': SerialNotice;
+    'state-stable': StableStateNotice;
+    'error-reply': ErrorReply;
+  }
+
+  /**
+   * Maps a request msgType to the corresponding reply type.
+   */
+  export interface IReplyMap {
+    'storeid-request': StoreIdReply;
+    'transaction-broadcast': TransactionAck;
+    'history-request': HistoryReply;
+    'transaction-request': TransactionReply;
+    'serial-request': SerialReply;
+    'permissions-request': PermissionsReply;
+  }
+
+  export type BaseReply = Base & {
+    /**
+     * The msgId of the corresponding request message.
+     */
+    readonly parentId: string;
+  };
+
+  /**
+   * A message requesting the store id of the client.
+   */
+  export type StoreIdRequest = Base & {
+    readonly msgType: 'storeid-request';
+    readonly content: {};
+  };
+
+  /**
+   * A reply to a 'storeid-request' message.
+   */
+  export type StoreIdReply = BaseReply & {
+    readonly msgType: 'storeid-reply';
+    readonly content: {
+      /**
+       * The unique store id for this client.
+       */
+      readonly storeId: number;
+    };
+  };
+
+  /**
+   * A message broadcasting some transactions to peers.
+   */
+  export type TransactionBroadcast = Base & {
+    readonly msgType: 'transaction-broadcast';
+    readonly content: {
+      /**
+       * The transactions being broadcast.
+       */
+      readonly transactions: ReadonlyArray<SerialTransaction>;
+    };
+  };
+
+  /**
+   * An ackowledgment of received transactions.
+   */
+  export type TransactionAck = BaseReply & {
+    readonly msgType: 'transaction-ack';
+    readonly content: {
+      /**
+       * The transaction ids that were received.
+       */
+      readonly transactionIds: ReadonlyArray<string>;
+
+      /**
+       * The serials assigned to the received messages.
+       */
+      readonly serials: ReadonlyArray<number>;
+    };
+  };
+
+  /**
+   * A message requesting specific transactions from the server.
+   */
+  export type TransactionRequest = Base & {
+    readonly msgType: 'transaction-request';
+    readonly content: {
+      /**
+       * The ids of the transactions that are requested.
+       */
+      readonly transactionIds: ReadonlyArray<string>;
+    };
+  };
+
+  /**
+   * A reply to a 'transaction-request'.
+   */
+  export type TransactionReply = BaseReply & {
+    readonly msgType: 'transaction-reply';
+    readonly content: {
+      /**
+       * The transactions that were requested.
+       */
+      readonly transactions: ReadonlyArray<SerialTransaction>;
+    };
+  };
+
+  /**
+   * A message requesting the full transaction history from the server.
+   */
+  export type HistoryRequest = Base & {
+    readonly msgType: 'history-request';
+    readonly content: {
+      /**
+       * The checkpoint to start from.
+       */
+      checkpointId: number | null;
+    };
+  };
+
+  /**
+   * A reply to a 'history-request'.
+   */
+  export type HistoryReply = BaseReply & {
+    readonly msgType: 'history-reply';
+    readonly content: {
+      /**
+       * The state at the checkpoint, if given.
+       */
+      readonly state: string | null;
+
+      /**
+       * The transactions that make up the history.
+       */
+      readonly transactions: ReadonlyArray<SerialTransaction>;
+    };
+  };
+
+  /**
+   * A message requesting specific transactions by serial number.
+   */
+  export type SerialRequest = Base & {
+    readonly msgType: 'serial-request';
+    readonly content: {
+      /**
+       * The serial numbers that are requested.
+       */
+      readonly serials: ReadonlyArray<number>;
+    };
+  };
+
+  /**
+   * A reply to a 'serial-request'.
+   */
+  export type SerialReply = BaseReply & {
+    readonly msgType: 'serial-reply';
+    readonly content: {
+      /**
+       * The transactions that were requested.
+       */
+      readonly transactions: ReadonlyArray<SerialTransaction>;
+    };
+  };
+
+  /**
+   * A message requesting which permission we have on the central store.
+   */
+  export type PermissionsRequest = Base & {
+    readonly msgType: 'permissions-request';
+    readonly content: {};
+  };
+
+  /**
+   * A reply to a `permission-request`.
+   */
+  export type PermissionsReply = BaseReply & {
+    readonly msgType: 'permissions-reply';
+    readonly content: {
+      /**
+       * Whether we can read transactions from the store.
+       */
+      readonly read: boolean;
+
+      /**
+       * Whether we can write transactions to the store.
+       */
+      readonly write: boolean;
+    };
+  };
+
+  /**
+   * An update to the server of the last applied server serial.
+   */
+  export type SerialNotice = Base & {
+    readonly msgType: 'serial-update';
+    readonly content: {
+      /**
+       * The server-side serial of last transaction applied.
+       */
+      readonly serial: number;
+    };
+  };
+
+  /**
+   * A notice that the datastore is *stable* up to the given serial.
+   *
+   * Stability here means that all concurrent transactions are known
+   * to have been applied.
+   */
+  export type StableStateNotice = Base & {
+    readonly msgType: 'state-stable';
+    readonly content: {
+      /**
+       * The server-side serial of the stable state.
+       */
+      serial: number;
+    };
+  };
+
+  /**
+   * An error reply message.
+   */
+  export type ErrorReply = BaseReply & {
+    readonly msgType: 'error-reply';
+    readonly content: {
+      /**
+       * The reason for the error.
+       */
+      readonly reason: string;
+    };
+  };
+
+  /**
+   * A union type for all request messages.
+   */
+  export type Request =
+    | StoreIdRequest
+    | TransactionBroadcast
+    | TransactionRequest
+    | HistoryRequest
+    | SerialRequest
+    | PermissionsRequest;
+
+  /**
+   * A union type for all reply messages.
+   */
+  export type RawReply =
+    | StoreIdReply
+    | TransactionAck
+    | TransactionReply
+    | HistoryReply
+    | SerialReply
+    | PermissionsReply
+    | ErrorReply;
+
+  /**
+   * A union type for all successful reply messages.
+   */
+  export type Reply =
+    | StoreIdReply
+    | TransactionAck
+    | TransactionReply
+    | HistoryReply
+    | SerialReply
+    | PermissionsReply;
+
+  /**
+   * A union type of all notice messages (no reply expected).
+   */
+  export type Notice = StableStateNotice | SerialNotice;
+
+  /**
+   * A union type for all messages.
+   */
+  export type Message = Request | RawReply | Notice;
+
+  /**
+   * Create a WSServerAdapter message.
+   *
+   * @param {string} msgType The message type.
+   * @param {ReadonlyJSONObject} content The content of the message.
+   * @param {string} parentId An optional id of the parent of this message.
+   * @returns {TransactionBroadcast} The created message.
+   */
+  export function createMessage<K extends Message['msgType']>(
+    msgType: K,
+    content: ITypeMap[K]['content'],
+    parentId?: ITypeMap[K]['parentId']
+  ): ITypeMap[K] {
+    const msgId = UUID.uuid4();
+    return {
+      msgId,
+      msgType,
+      parentId,
+      content
+    } as ITypeMap[K];
+  }
+
+  /**
+   * Create a WSServerAdapter message.
+   *
+   * @param {string} msgType The message type.
+   * @param {ReadonlyJSONObject} content The content of the message.
+   * @param {string} parentId The id of the parent of this reply.
+   * @returns {TransactionBroadcast} The created message.
+   */
+  export function createReply<T extends BaseReply>(
+    msgType: T['msgType'],
+    content: T['content'],
+    parentId: string
+  ): T {
+    const msgId = UUID.uuid4();
+    return ({
+      msgId,
+      msgType,
+      parentId,
+      content
+    } as unknown) as T;
+  }
+
+  /**
+   * Whether a message is a reply to a previous request.
+   * @param message - The message to consider.
+   * @returns Whether the message is a reply.
+   */
+  export function isReply(message: Message): message is RawReply {
+    return message.parentId !== undefined;
+  }
+}
diff --git a/packages/datastore/tdoptions.json b/packages/datastore/tdoptions.json
new file mode 100644
index 00000000000..49998f15a8f
--- /dev/null
+++ b/packages/datastore/tdoptions.json
@@ -0,0 +1,20 @@
+{
+  "excludeNotExported": true,
+  "mode": "file",
+  "target": "es5",
+  "module": "es5",
+  "lib": [
+    "lib.es2015.d.ts",
+    "lib.es2015.collection.d.ts",
+    "lib.es2015.promise.d.ts",
+    "lib.dom.d.ts"
+  ],
+  "out": "../../docs/api/datastore",
+  "baseUrl": ".",
+  "paths": {
+    "@jupyterlab/*": ["../packages/*"]
+  },
+  "esModuleInterop": true,
+  "jsx": "react",
+  "types": []
+}
diff --git a/packages/datastore/tsconfig.json b/packages/datastore/tsconfig.json
new file mode 100644
index 00000000000..f03f015de44
--- /dev/null
+++ b/packages/datastore/tsconfig.json
@@ -0,0 +1,21 @@
+{
+  "extends": "../../tsconfigbase",
+  "compilerOptions": {
+    "outDir": "lib",
+    "rootDir": "src",
+    "strictNullChecks": true,
+    "skipLibCheck": true
+  },
+  "include": ["src/**/*"],
+  "references": [
+    {
+      "path": "../coreutils"
+    },
+    {
+      "path": "../observables"
+    },
+    {
+      "path": "../services"
+    }
+  ]
+}
diff --git a/packages/docmanager/package.json b/packages/docmanager/package.json
index 2c4b6cdbd97..b03f7821b5d 100644
--- a/packages/docmanager/package.json
+++ b/packages/docmanager/package.json
@@ -33,6 +33,7 @@
     "@jupyterlab/apputils": "^1.0.0-alpha.3",
     "@jupyterlab/coreutils": "^3.0.0-alpha.3",
     "@jupyterlab/docregistry": "^1.0.0-alpha.3",
+    "@jupyterlab/observables": "^2.2.0-alpha.3",
     "@jupyterlab/services": "^4.0.0-alpha.3",
     "@jupyterlab/statusbar": "^1.0.0-alpha.3",
     "@phosphor/algorithm": "^1.1.2",
diff --git a/packages/docmanager/src/manager.ts b/packages/docmanager/src/manager.ts
index 11536a493db..ef588edf1ba 100644
--- a/packages/docmanager/src/manager.ts
+++ b/packages/docmanager/src/manager.ts
@@ -13,6 +13,8 @@ import {
   IDocumentWidget
 } from '@jupyterlab/docregistry';
 
+import { IModelDB } from '@jupyterlab/observables';
+
 import { Contents, Kernel, ServiceManager } from '@jupyterlab/services';
 
 import { ArrayExt, find } from '@phosphor/algorithm';
@@ -452,7 +454,8 @@ export class DocumentManager implements IDisposable {
   private _createContext(
     path: string,
     factory: DocumentRegistry.ModelFactory,
-    kernelPreference: IClientSession.IKernelPreference
+    kernelPreference: IClientSession.IKernelPreference,
+    modelDBFactory: IModelDB.IFactory
   ): Private.IContext {
     // TODO: Make it impossible to open two different contexts for the same
     // path. Or at least prompt the closing of all widgets associated with the
@@ -469,8 +472,6 @@ export class DocumentManager implements IDisposable {
       this._widgetManager.adoptWidget(context, widget);
       this._opener.open(widget, options);
     };
-    let modelDBFactory =
-      this.services.contents.getModelDBFactory(path) || undefined;
     let context = new Context({
       opener: adopter,
       manager: this.services,
@@ -523,6 +524,10 @@ export class DocumentManager implements IDisposable {
     return registry.getWidgetFactory(widgetName);
   }
 
+  private _modelDBFactoryFor(path: string): IModelDB.IFactory {
+    return this.registry.getModelDBFactory(path);
+  }
+
   /**
    * Creates a new document, or loads one from disk, depending on the `which` argument.
    * If `which==='create'`, then it creates a new document. If `which==='open'`,
@@ -548,6 +553,8 @@ export class DocumentManager implements IDisposable {
       return undefined;
     }
 
+    let dbFactory = this._modelDBFactoryFor(path);
+
     // Handle the kernel pereference.
     let preference = this.registry.getKernelPreference(
       path,
@@ -563,13 +570,13 @@ export class DocumentManager implements IDisposable {
       // Use an existing context if available.
       context = this._findContext(path, factory.name) || null;
       if (!context) {
-        context = this._createContext(path, factory, preference);
+        context = this._createContext(path, factory, preference, dbFactory);
         // Populate the model, either from disk or a
         // model backend.
         ready = this._when.then(() => context.initialize(false));
       }
     } else if (which === 'create') {
-      context = this._createContext(path, factory, preference);
+      context = this._createContext(path, factory, preference, dbFactory);
       // Immediately save the contents to disk.
       ready = this._when.then(() => context.initialize(true));
     }
diff --git a/packages/docmanager/tsconfig.json b/packages/docmanager/tsconfig.json
index b4feba7cbf1..7756343f94c 100644
--- a/packages/docmanager/tsconfig.json
+++ b/packages/docmanager/tsconfig.json
@@ -20,6 +20,9 @@
     },
     {
       "path": "../statusbar"
+    },
+    {
+      "path": "../observables"
     }
   ]
 }
diff --git a/packages/docregistry/package.json b/packages/docregistry/package.json
index 84c24c8273b..9f842c4ad41 100644
--- a/packages/docregistry/package.json
+++ b/packages/docregistry/package.json
@@ -41,6 +41,7 @@
     "@jupyterlab/services": "^4.0.0-alpha.3",
     "@phosphor/algorithm": "^1.1.2",
     "@phosphor/coreutils": "^1.3.0",
+    "@phosphor/datastore": "file:../../../phosphor/packages/datastore",
     "@phosphor/disposable": "^1.1.2",
     "@phosphor/messaging": "^1.2.2",
     "@phosphor/signaling": "^1.2.2",
diff --git a/packages/docregistry/src/context.ts b/packages/docregistry/src/context.ts
index 9b7dd76b6b9..0ad27cc3d0a 100644
--- a/packages/docregistry/src/context.ts
+++ b/packages/docregistry/src/context.ts
@@ -24,7 +24,7 @@ import {
 
 import { PathExt } from '@jupyterlab/coreutils';
 
-import { IModelDB, ModelDB } from '@jupyterlab/observables';
+import { IModelDB } from '@jupyterlab/observables';
 
 import { RenderMimeRegistry } from '@jupyterlab/rendermime';
 
@@ -53,7 +53,7 @@ export class Context<T extends DocumentRegistry.IModel>
     let dbFactory = options.modelDBFactory;
     if (dbFactory) {
       const localPath = manager.contents.localPath(this._path);
-      this._modelDB = dbFactory.createNew(localPath);
+      this._modelDB = dbFactory.createNew(localPath, this._factory.schemas);
       this._model = this._factory.createNew(lang, this._modelDB);
     } else {
       this._model = this._factory.createNew(lang);
@@ -815,7 +815,7 @@ export namespace Context {
     /**
      * An IModelDB factory method which may be used for the document.
      */
-    modelDBFactory?: ModelDB.IFactory;
+    modelDBFactory?: IModelDB.IFactory;
 
     /**
      * An optional callback for opening sibling widgets.
diff --git a/packages/docregistry/src/default.ts b/packages/docregistry/src/default.ts
index b4054124986..c37c07ebd2f 100644
--- a/packages/docregistry/src/default.ts
+++ b/packages/docregistry/src/default.ts
@@ -7,6 +7,10 @@ import { Contents } from '@jupyterlab/services';
 
 import { JSONValue } from '@phosphor/coreutils';
 
+import { Schema, Fields } from '@phosphor/datastore';
+
+import { IDisposable } from '@phosphor/disposable';
+
 import { ISignal, Signal } from '@phosphor/signaling';
 
 import { Widget } from '@phosphor/widgets';
@@ -17,25 +21,37 @@ import { CodeEditor } from '@jupyterlab/codeeditor';
 
 import { IChangedArgs, PathExt } from '@jupyterlab/coreutils';
 
-import { IModelDB } from '@jupyterlab/observables';
+import {
+  IModelDB,
+  ModelDB,
+  IObservableString,
+  IObservableMap,
+  IObservableValue
+} from '@jupyterlab/observables';
 
 import { DocumentRegistry, IDocumentWidget } from './index';
 
 /**
  * The default implementation of a document model.
  */
-export class DocumentModel extends CodeEditor.Model
-  implements DocumentRegistry.ICodeModel {
+export abstract class DocumentModel implements IDisposable {
   /**
    * Construct a new document model.
    */
-  constructor(languagePreference?: string, modelDB?: IModelDB) {
-    super({ modelDB });
+  constructor(
+    mimeType: string,
+    languagePreference?: string,
+    modelDB?: IModelDB
+  ) {
+    this.modelDB = modelDB || new ModelDB();
     this._defaultLang = languagePreference || '';
-    this.value.changed.connect(
-      this.triggerContentChange,
+
+    let mimeTypeObs = this.modelDB.createValue('mimeType');
+    mimeTypeObs.changed.connect(
+      this._onMimeTypeChanged,
       this
     );
+    this._defaultMimeType = mimeType;
   }
 
   /**
@@ -103,28 +119,43 @@ export class DocumentModel extends CodeEditor.Model
   }
 
   /**
-   * Serialize the model to a string.
+   * A signal emitted when a mimetype changes.
    */
-  toString(): string {
-    return this.value.text;
+  get mimeTypeChanged(): ISignal<this, IChangedArgs<string>> {
+    return this._mimeTypeChanged;
   }
 
+  /**
+   * A mime type of the model.
+   */
+  get mimeType(): string {
+    return this.modelDB.getValue('mimeType') as string;
+  }
+  set mimeType(newValue: string) {
+    const oldValue = this.mimeType;
+    if (oldValue === newValue) {
+      return;
+    }
+    this.modelDB.setValue('mimeType', newValue);
+  }
+
+  /**
+   * Serialize the model to a string.
+   */
+  abstract toString(): string;
+
   /**
    * Deserialize the model from a string.
    *
    * #### Notes
    * Should emit a [contentChanged] signal.
    */
-  fromString(value: string): void {
-    this.value.text = value;
-  }
+  abstract fromString(value: string): void;
 
   /**
    * Serialize the model to JSON.
    */
-  toJSON(): JSONValue {
-    return JSON.parse(this.value.text || 'null');
-  }
+  abstract toJSON(): JSONValue;
 
   /**
    * Deserialize the model from JSON.
@@ -132,17 +163,40 @@ export class DocumentModel extends CodeEditor.Model
    * #### Notes
    * Should emit a [contentChanged] signal.
    */
-  fromJSON(value: JSONValue): void {
-    this.fromString(JSON.stringify(value));
-  }
+  abstract fromJSON(value: JSONValue): void;
 
   /**
    * Initialize the model with its current state.
    */
   initialize(): void {
-    return;
+    const mimeType = this.modelDB.get('mimeType') as IObservableValue;
+    mimeType.set(mimeType.get() || this._defaultMimeType || 'text/plain');
   }
 
+  /**
+   * Whether the model is disposed.
+   */
+  get isDisposed(): boolean {
+    return this._isDisposed;
+  }
+
+  /**
+   * Dispose of the resources used by the model.
+   */
+  dispose(): void {
+    if (this._isDisposed) {
+      return;
+    }
+    this._isDisposed = true;
+    Signal.clearData(this);
+  }
+
+  /**
+   * The underlying `IModelDB` instance in which model
+   * data is stored.
+   */
+  readonly modelDB: IModelDB;
+
   /**
    * Trigger a state change signal.
    */
@@ -158,13 +212,129 @@ export class DocumentModel extends CodeEditor.Model
     this.dirty = true;
   }
 
+  private _onMimeTypeChanged(
+    mimeType: IObservableValue,
+    args: IObservableValue.IChangedArgs
+  ): void {
+    this._mimeTypeChanged.emit({
+      name: 'mimeType',
+      oldValue: args.oldValue as string,
+      newValue: args.newValue as string
+    });
+  }
+
   private _defaultLang = '';
   private _dirty = false;
+  private _isDisposed = false;
   private _readOnly = false;
+  private _defaultMimeType: string;
   private _contentChanged = new Signal<this, void>(this);
+  private _mimeTypeChanged = new Signal<this, IChangedArgs<string>>(this);
   private _stateChanged = new Signal<this, IChangedArgs<any>>(this);
 }
 
+/**
+ *
+ */
+export class TextModel extends DocumentModel
+  implements DocumentRegistry.ICodeModel {
+  /**
+   *
+   */
+  constructor(languagePreference?: string, modelDB?: IModelDB) {
+    super('text/plain', languagePreference, modelDB);
+    let value = this.modelDB.createString('value');
+    value.changed.connect(
+      this.triggerContentChange,
+      this
+    );
+  }
+
+  /**
+   * Get the value of the model.
+   */
+  get value(): IObservableString {
+    return this.modelDB.get('value') as IObservableString;
+  }
+
+  /**
+   * Get the selections for the model.
+   */
+  get selections(): IObservableMap<CodeEditor.ITextSelection[]> {
+    return this.modelDB.get('selections') as IObservableMap<
+      CodeEditor.ITextSelection[]
+    >;
+  }
+
+  toString(): string {
+    return this.value.text;
+  }
+
+  fromString(value: string): void {
+    this.value.text = value;
+  }
+
+  toJSON(): JSONValue {
+    return JSON.parse(this.value.text || 'null');
+  }
+
+  fromJSON(value: JSONValue): void {
+    this.fromString(JSON.stringify(value));
+  }
+
+  initialize(): void {
+    super.initialize();
+    const value = this.value;
+    value.text = value.text || '';
+  }
+}
+
+/**
+ *
+ */
+export class Base64Model extends DocumentModel {
+  /**
+   *
+   */
+  constructor(languagePreference?: string, modelDB?: IModelDB) {
+    super('text/plain', languagePreference, modelDB);
+    let value = this.modelDB.createValue('value');
+    value.changed.connect(
+      this.triggerContentChange,
+      this
+    );
+  }
+
+  /**
+   * Get the value of the model.
+   */
+  get value(): IObservableValue {
+    return this.modelDB.get('value') as IObservableValue;
+  }
+
+  toString(): string {
+    return this.value.get() as string;
+  }
+
+  fromString(value: string): void {
+    this.value.set(value);
+  }
+
+  toJSON(): JSONValue {
+    return JSON.parse(this.value.toString() || 'null');
+  }
+
+  fromJSON(value: JSONValue): void {
+    this.fromString(JSON.stringify(value));
+  }
+
+  initialize(): void {
+    super.initialize();
+    const value = this.value;
+    value.set(value.get() || '');
+  }
+}
+
 /**
  * An implementation of a model factory for text files.
  */
@@ -223,7 +393,7 @@ export class TextModelFactory implements DocumentRegistry.CodeModelFactory {
     languagePreference?: string,
     modelDB?: IModelDB
   ): DocumentRegistry.ICodeModel {
-    return new DocumentModel(languagePreference, modelDB);
+    return new TextModel(languagePreference, modelDB);
   }
 
   /**
@@ -234,13 +404,34 @@ export class TextModelFactory implements DocumentRegistry.CodeModelFactory {
     return mode && mode.mode;
   }
 
+  /**
+   * The schemas for the datastore.
+   */
+  get schemas(): ReadonlyArray<Schema> {
+    return [
+      {
+        id: 'TextModelSchema.v1',
+        fields: {
+          value: Fields.Text({ description: 'The text value of the model' }),
+          mimeType: Fields.String({
+            value: 'text/plain',
+            description: 'The MIME type of the text'
+          }),
+          selections: Fields.Map({
+            description: 'A map of all text selections for all users'
+          })
+        }
+      }
+    ];
+  }
+
   private _isDisposed = false;
 }
 
 /**
  * An implementation of a model factory for base64 files.
  */
-export class Base64ModelFactory extends TextModelFactory {
+export class Base64ModelFactory implements DocumentRegistry.ModelFactory {
   /**
    * The name of the model type.
    *
@@ -269,6 +460,60 @@ export class Base64ModelFactory extends TextModelFactory {
   get fileFormat(): Contents.FileFormat {
     return 'base64';
   }
+
+  /**
+   * Get whether the model factory has been disposed.
+   */
+  get isDisposed(): boolean {
+    return this._isDisposed;
+  }
+
+  /**
+   * Dispose of the resources held by the model factory.
+   */
+  dispose(): void {
+    this._isDisposed = true;
+  }
+
+  /**
+   * Create a new model.
+   *
+   * @param languagePreference - An optional kernel language preference.
+   *
+   * @returns A new document model.
+   */
+  createNew(
+    languagePreference?: string,
+    modelDB?: IModelDB
+  ): DocumentRegistry.IModel {
+    return new Base64Model(languagePreference, modelDB);
+  }
+
+  /**
+   * Get the preferred kernel language given a file path.
+   */
+  preferredLanguage(path: string): string {
+    let mode = Mode.findByFileName(path);
+    return mode && mode.mode;
+  }
+
+  /**
+   * The schemas for the datastore.
+   */
+  get schemas(): ReadonlyArray<Schema> {
+    return [
+      {
+        id: 'Base64ModelSchema.v1',
+        fields: {
+          value: Fields.String({
+            description: 'The value of the model'
+          })
+        }
+      }
+    ];
+  }
+
+  private _isDisposed = false;
 }
 
 /**
diff --git a/packages/docregistry/src/registry.ts b/packages/docregistry/src/registry.ts
index a0ee53a030f..25ca4826817 100644
--- a/packages/docregistry/src/registry.ts
+++ b/packages/docregistry/src/registry.ts
@@ -15,6 +15,8 @@ import {
 
 import { JSONValue } from '@phosphor/coreutils';
 
+import { Schema } from '@phosphor/datastore';
+
 import { IDisposable, DisposableDelegate } from '@phosphor/disposable';
 
 import { ISignal, Signal } from '@phosphor/signaling';
@@ -209,6 +211,13 @@ export class DocumentRegistry implements IDisposable {
     });
   }
 
+  addModelDBFactory(name: string, factory: IModelDB.IFactory): IDisposable {
+    this._modelDbFactories[name] = factory;
+    return new DisposableDelegate(() => {
+      delete this._modelDbFactories[name];
+    });
+  }
+
   /**
    * Add a widget extension to the registry.
    *
@@ -407,6 +416,20 @@ export class DocumentRegistry implements IDisposable {
     return this.preferredWidgetFactories(path)[0];
   }
 
+  /**
+   * Get the preferred model DB factory for a path.
+   *
+   * @param path - The path to for which to find a model DB factory.
+   *
+   * @returns The model DB factory for the path.
+   */
+  getModelDBFactory(path: string): IModelDB.IFactory {
+    // TODO: Use some resolution to pick DB factory
+    for (let key in this._modelDbFactories) {
+      return this._modelDbFactories[key];
+    }
+  }
+
   /**
    * Create an iterator over the widget factories that have been registered.
    *
@@ -596,6 +619,9 @@ export class DocumentRegistry implements IDisposable {
     return fts;
   }
 
+  private _modelDbFactories: {
+    [key: string]: IModelDB.IFactory;
+  } = Object.create(null);
   private _modelFactories: {
     [key: string]: DocumentRegistry.ModelFactory;
   } = Object.create(null);
@@ -1042,6 +1068,11 @@ export namespace DocumentRegistry {
      * Get the preferred kernel language given a file path.
      */
     preferredLanguage(path: string): string;
+
+    /**
+     * The schemas for the datastore.
+     */
+    readonly schemas: ReadonlyArray<Schema>;
   }
 
   /**
diff --git a/packages/metapackage/package.json b/packages/metapackage/package.json
index 4cd7b2581bc..84f2f64c3e1 100644
--- a/packages/metapackage/package.json
+++ b/packages/metapackage/package.json
@@ -46,6 +46,8 @@
     "@jupyterlab/coreutils": "^3.0.0-alpha.3",
     "@jupyterlab/csvviewer": "^1.0.0-alpha.3",
     "@jupyterlab/csvviewer-extension": "^1.0.0-alpha.3",
+    "@jupyterlab/datastore": "^1.0.0-alpha.3",
+    "@jupyterlab/datastore-extension": "^1.0.0-alpha.3",
     "@jupyterlab/docmanager": "^1.0.0-alpha.3",
     "@jupyterlab/docmanager-extension": "^1.0.0-alpha.3",
     "@jupyterlab/docregistry": "^1.0.0-alpha.3",
diff --git a/packages/metapackage/src/index.ts b/packages/metapackage/src/index.ts
index ac8fdb541da..b7e80701848 100644
--- a/packages/metapackage/src/index.ts
+++ b/packages/metapackage/src/index.ts
@@ -17,6 +17,8 @@ import '@jupyterlab/console-extension';
 import '@jupyterlab/coreutils';
 import '@jupyterlab/csvviewer';
 import '@jupyterlab/csvviewer-extension';
+import '@jupyterlab/datastore';
+import '@jupyterlab/datastore-extension';
 import '@jupyterlab/docmanager';
 import '@jupyterlab/docmanager-extension';
 import '@jupyterlab/docregistry';
diff --git a/packages/metapackage/tsconfig.json b/packages/metapackage/tsconfig.json
index 669f3248553..f70b6e907ca 100644
--- a/packages/metapackage/tsconfig.json
+++ b/packages/metapackage/tsconfig.json
@@ -54,6 +54,12 @@
     {
       "path": "../csvviewer-extension"
     },
+    {
+      "path": "../datastore"
+    },
+    {
+      "path": "../datastore-extension"
+    },
     {
       "path": "../docmanager"
     },
diff --git a/packages/notebook/package.json b/packages/notebook/package.json
index 00dee96125b..6725e59c9ac 100644
--- a/packages/notebook/package.json
+++ b/packages/notebook/package.json
@@ -43,6 +43,7 @@
     "@jupyterlab/ui-components": "^1.0.0-alpha.3",
     "@phosphor/algorithm": "^1.1.2",
     "@phosphor/coreutils": "^1.3.0",
+    "@phosphor/datastore": "file:../../../phosphor/packages/datastore",
     "@phosphor/domutils": "^1.1.2",
     "@phosphor/dragdrop": "^1.3.0",
     "@phosphor/messaging": "^1.2.2",
diff --git a/packages/notebook/src/celllist.ts b/packages/notebook/src/celllist.ts
index b4243d3e1d8..726c8106af8 100644
--- a/packages/notebook/src/celllist.ts
+++ b/packages/notebook/src/celllist.ts
@@ -15,8 +15,6 @@ import { ISignal, Signal } from '@phosphor/signaling';
 import { ICellModel } from '@jupyterlab/cells';
 
 import {
-  IObservableMap,
-  ObservableMap,
   IObservableList,
   IObservableUndoableList,
   IModelDB
@@ -34,7 +32,7 @@ export class CellList implements IObservableUndoableList<ICellModel> {
   constructor(modelDB: IModelDB, factory: NotebookModel.IContentFactory) {
     this._factory = factory;
     this._cellOrder = modelDB.createList<string>('cellOrder');
-    this._cellMap = new ObservableMap<ICellModel>();
+    this._cellMap = new Map();
 
     this._cellOrder.changed.connect(
       this._onOrderChanged,
@@ -126,7 +124,7 @@ export class CellList implements IObservableUndoableList<ICellModel> {
     for (let cell of this._cellMap.values()) {
       cell.dispose();
     }
-    this._cellMap.dispose();
+    this._cellMap.clear();
     this._cellOrder.dispose();
   }
 
@@ -474,8 +472,8 @@ export class CellList implements IObservableUndoableList<ICellModel> {
     if (change.type === 'add' || change.type === 'set') {
       each(change.newValues, id => {
         if (!this._cellMap.has(id)) {
-          let cellDB = this._factory.modelDB;
-          let cellType = cellDB.createValue(id + '.type');
+          let cellDB = this._factory.modelDB.view(id);
+          let cellType = cellDB.createValue('type');
           let cell: ICellModel;
           switch (cellType.get()) {
             case 'code':
@@ -511,7 +509,7 @@ export class CellList implements IObservableUndoableList<ICellModel> {
 
   private _isDisposed: boolean = false;
   private _cellOrder: IObservableUndoableList<string> = null;
-  private _cellMap: IObservableMap<ICellModel> = null;
+  private _cellMap: Map<string, ICellModel> = null;
   private _changed = new Signal<this, IObservableList.IChangedArgs<ICellModel>>(
     this
   );
diff --git a/packages/notebook/src/model.ts b/packages/notebook/src/model.ts
index f472c7b9404..f118b934156 100644
--- a/packages/notebook/src/model.ts
+++ b/packages/notebook/src/model.ts
@@ -69,14 +69,15 @@ export class NotebookModel extends DocumentModel implements INotebookModel {
    * Construct a new notebook model.
    */
   constructor(options: NotebookModel.IOptions = {}) {
-    super(options.languagePreference, options.modelDB);
-    let factory = options.contentFactory || NotebookModel.defaultContentFactory;
+    super(
+      'application/x-ipynb+json',
+      options.languagePreference,
+      options.modelDB
+    );
+    const factory =
+      options.contentFactory || NotebookModel.defaultContentFactory;
     this.contentFactory = factory.clone(this.modelDB.view('cells'));
     this._cells = new CellList(this.modelDB, this.contentFactory);
-    // Add an initial code cell by default.
-    if (!this._cells.length) {
-      this._cells.push(factory.createCodeCell({}));
-    }
     this._cells.changed.connect(
       this._onCellsChanged,
       this
@@ -84,11 +85,6 @@ export class NotebookModel extends DocumentModel implements INotebookModel {
 
     // Handle initial metadata.
     let metadata = this.modelDB.createMap('metadata');
-    if (!metadata.has('language_info')) {
-      let name = options.languagePreference || '';
-      metadata.set('language_info', { name });
-    }
-    this._ensureMetadata();
     metadata.changed.connect(
       this.triggerContentChange,
       this
@@ -212,54 +208,59 @@ export class NotebookModel extends DocumentModel implements INotebookModel {
    * Should emit a [contentChanged] signal.
    */
   fromJSON(value: nbformat.INotebookContent): void {
-    let cells: ICellModel[] = [];
-    let factory = this.contentFactory;
-    for (let cell of value.cells) {
-      switch (cell.cell_type) {
-        case 'code':
-          cells.push(factory.createCodeCell({ cell }));
-          break;
-        case 'markdown':
-          cells.push(factory.createMarkdownCell({ cell }));
-          break;
-        case 'raw':
-          cells.push(factory.createRawCell({ cell }));
-          break;
-        default:
+    this.modelDB.withTransaction(() => {
+      let oldValue = 0;
+      let newValue = 0;
+      this._nbformatMinor = nbformat.MINOR_VERSION;
+      this._nbformat = nbformat.MAJOR_VERSION;
+
+      if (value.nbformat !== this._nbformat) {
+        oldValue = this._nbformat;
+        this._nbformat = newValue = value.nbformat;
+        this.triggerStateChange({ name: 'nbformat', oldValue, newValue });
+      }
+      if (value.nbformat_minor > this._nbformatMinor) {
+        oldValue = this._nbformatMinor;
+        this._nbformatMinor = newValue = value.nbformat_minor;
+        this.triggerStateChange({ name: 'nbformatMinor', oldValue, newValue });
+      }
+      // Update the metadata.
+      this.metadata.clear();
+      let metadata = value.metadata;
+      for (let key in metadata) {
+        // orig_nbformat is not intended to be stored per spec.
+        if (key === 'orig_nbformat') {
           continue;
+        }
+        this.metadata.set(key, metadata[key]);
       }
-    }
-    this.cells.beginCompoundOperation();
-    this.cells.clear();
-    this.cells.pushAll(cells);
-    this.cells.endCompoundOperation();
-
-    let oldValue = 0;
-    let newValue = 0;
-    this._nbformatMinor = nbformat.MINOR_VERSION;
-    this._nbformat = nbformat.MAJOR_VERSION;
-
-    if (value.nbformat !== this._nbformat) {
-      oldValue = this._nbformat;
-      this._nbformat = newValue = value.nbformat;
-      this.triggerStateChange({ name: 'nbformat', oldValue, newValue });
-    }
-    if (value.nbformat_minor > this._nbformatMinor) {
-      oldValue = this._nbformatMinor;
-      this._nbformatMinor = newValue = value.nbformat_minor;
-      this.triggerStateChange({ name: 'nbformatMinor', oldValue, newValue });
-    }
-    // Update the metadata.
-    this.metadata.clear();
-    let metadata = value.metadata;
-    for (let key in metadata) {
-      // orig_nbformat is not intended to be stored per spec.
-      if (key === 'orig_nbformat') {
-        continue;
+      this._ensureMetadata();
+    });
+
+    let cells: ICellModel[] = [];
+    this.modelDB.withTransaction((transactionId?: string) => {
+      let factory = this.contentFactory;
+      for (let cell of value.cells) {
+        switch (cell.cell_type) {
+          case 'code':
+            cells.push(factory.createCodeCell({ cell }));
+            break;
+          case 'markdown':
+            cells.push(factory.createMarkdownCell({ cell }));
+            break;
+          case 'raw':
+            cells.push(factory.createRawCell({ cell }));
+            break;
+          default:
+            continue;
+        }
       }
-      this.metadata.set(key, metadata[key]);
-    }
-    this._ensureMetadata();
+
+      this.cells.beginCompoundOperation();
+      this.cells.clear();
+      this.cells.pushAll(cells);
+      this.cells.endCompoundOperation();
+    });
     this.dirty = true;
   }
 
@@ -267,8 +268,21 @@ export class NotebookModel extends DocumentModel implements INotebookModel {
    * Initialize the model with its current state.
    */
   initialize(): void {
-    super.initialize();
-    this.cells.clearUndo();
+    this.modelDB.withTransaction(() => {
+      super.initialize();
+      // Add an initial code cell by default.
+      if (!this._cells.length && !this.modelDB.isPrepopulated) {
+        this._cells.push(this.contentFactory.createCodeCell({}));
+      }
+
+      const metadata = this.metadata;
+      if (!metadata.has('language_info')) {
+        const name = this.defaultKernelLanguage;
+        metadata.set('language_info', { name });
+      }
+      this._ensureMetadata();
+      this.cells.clearUndo();
+    });
   }
 
   /**
@@ -307,7 +321,9 @@ export class NotebookModel extends DocumentModel implements INotebookModel {
       // cell changed event during the handling of this signal.
       requestAnimationFrame(() => {
         if (!this.isDisposed && !this.cells.length) {
-          this.cells.push(factory.createCodeCell({}));
+          this.modelDB.withTransaction(() => {
+            this.cells.push(factory.createCodeCell({}));
+          });
         }
       });
     }
@@ -443,7 +459,7 @@ export namespace NotebookModel {
      *   `codeCellContentFactory` will be used.
      */
     createCodeCell(options: CodeCellModel.IOptions): ICodeCellModel {
-      if (options.contentFactory) {
+      if (!options.contentFactory) {
         options.contentFactory = this.codeCellContentFactory;
       }
       if (this.modelDB) {
@@ -451,6 +467,11 @@ export namespace NotebookModel {
           options.id = UUID.uuid4();
         }
         options.modelDB = this.modelDB.view(options.id);
+        let cell;
+        this.modelDB.withTransaction(() => {
+          cell = new CodeCellModel(options);
+        });
+        return cell;
       }
       return new CodeCellModel(options);
     }
@@ -469,6 +490,11 @@ export namespace NotebookModel {
           options.id = UUID.uuid4();
         }
         options.modelDB = this.modelDB.view(options.id);
+        let cell;
+        this.modelDB.withTransaction(() => {
+          cell = new MarkdownCellModel(options);
+        });
+        return cell;
       }
       return new MarkdownCellModel(options);
     }
@@ -487,6 +513,11 @@ export namespace NotebookModel {
           options.id = UUID.uuid4();
         }
         options.modelDB = this.modelDB.view(options.id);
+        let cell;
+        this.modelDB.withTransaction(() => {
+          cell = new RawCellModel(options);
+        });
+        return cell;
       }
       return new RawCellModel(options);
     }
diff --git a/packages/notebook/src/modelfactory.ts b/packages/notebook/src/modelfactory.ts
index 8f4c395d05f..bde15e9fd1c 100644
--- a/packages/notebook/src/modelfactory.ts
+++ b/packages/notebook/src/modelfactory.ts
@@ -1,6 +1,8 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
+import { Schema, Fields } from '@phosphor/datastore';
+
 import { CodeCellModel } from '@jupyterlab/cells';
 
 import { DocumentRegistry } from '@jupyterlab/docregistry';
@@ -85,6 +87,47 @@ export class NotebookModelFactory
     return '';
   }
 
+  get schemas(): ReadonlyArray<Schema> {
+    return [
+      {
+        id: 'NotebookModelSchema.v1',
+        fields: {
+          mimeType: Fields.String(),
+          metadata: Fields.Map(),
+          cellOrder: Fields.List<string>()
+        }
+      },
+      {
+        id: 'NotebookModelSchema.v1.cells',
+        fields: {
+          // General fields for cells:
+          type: Fields.String(),
+          metadata: Fields.Map(),
+          trusted: Fields.Boolean(),
+
+          // Fields for editable models:
+          value: Fields.Text({
+            description: 'The text value of the model'
+          }),
+          mimeType: Fields.String({
+            value: 'text/plain',
+            description: 'The MIME type of the text'
+          }),
+          selections: Fields.Map({
+            description: 'A map of all text selections for all users'
+          }),
+
+          // Code cell specific:
+          executionCount: Fields.Register<number | null>({ value: null }),
+          outputs: Fields.String(),
+
+          // Cells with attachments (md/raw):
+          attachments: Fields.String()
+        }
+      }
+    ];
+  }
+
   private _disposed = false;
 }
 
diff --git a/packages/notebook/src/widget.ts b/packages/notebook/src/widget.ts
index cce6c4b279d..de01d9a7cbf 100644
--- a/packages/notebook/src/widget.ts
+++ b/packages/notebook/src/widget.ts
@@ -217,6 +217,9 @@ export class StaticNotebook extends Widget {
 
     if (oldValue && oldValue.modelDB.isCollaborative) {
       oldValue.modelDB.connected.then(() => {
+        if (!oldValue.modelDB.collaborators) {
+          return;
+        }
         oldValue.modelDB.collaborators.changed.disconnect(
           this._onCollaboratorsChanged,
           this
@@ -225,6 +228,9 @@ export class StaticNotebook extends Widget {
     }
     if (newValue && newValue.modelDB.isCollaborative) {
       newValue.modelDB.connected.then(() => {
+        if (!newValue.modelDB.collaborators) {
+          return;
+        }
         newValue.modelDB.collaborators.changed.connect(
           this._onCollaboratorsChanged,
           this
@@ -1403,7 +1409,7 @@ export class Notebook extends StaticNotebook {
     if (this.model && this.model.modelDB.isCollaborative) {
       let modelDB = this.model.modelDB;
       modelDB.connected.then(() => {
-        if (!cell.isDisposed) {
+        if (!cell.isDisposed && modelDB.collaborators) {
           // Setup the selection style for collaborators.
           let localCollaborator = modelDB.collaborators.localCollaborator;
           cell.editor.uuid = localCollaborator.sessionId;
diff --git a/packages/observables/package.json b/packages/observables/package.json
index c8e59fecab3..28d22e53c52 100644
--- a/packages/observables/package.json
+++ b/packages/observables/package.json
@@ -31,6 +31,7 @@
   "dependencies": {
     "@phosphor/algorithm": "^1.1.2",
     "@phosphor/coreutils": "^1.3.0",
+    "@phosphor/datastore": "file:../../../phosphor/packages/datastore",
     "@phosphor/disposable": "^1.1.2",
     "@phosphor/messaging": "^1.2.2",
     "@phosphor/signaling": "^1.2.2"
diff --git a/packages/observables/src/modeldb.ts b/packages/observables/src/modeldb.ts
index 2593339fe7f..e026d2f1594 100644
--- a/packages/observables/src/modeldb.ts
+++ b/packages/observables/src/modeldb.ts
@@ -3,9 +3,11 @@
 
 import { IDisposable, DisposableSet } from '@phosphor/disposable';
 
+import { Schema } from '@phosphor/datastore';
+
 import { ISignal, Signal } from '@phosphor/signaling';
 
-import { JSONExt, JSONValue, JSONObject } from '@phosphor/coreutils';
+import { JSONExt, JSONObject, ReadonlyJSONValue } from '@phosphor/coreutils';
 
 import { ObservableMap } from './observablemap';
 
@@ -49,17 +51,37 @@ export interface IObservableValue extends IObservable {
   /**
    * The changed signal.
    */
-  readonly changed: ISignal<IObservableValue, ObservableValue.IChangedArgs>;
+  readonly changed: ISignal<IObservableValue, IObservableValue.IChangedArgs>;
 
   /**
    * Get the current value, or `undefined` if it has not been set.
    */
-  get(): JSONValue | undefined;
+  get(): ReadonlyJSONValue | undefined;
 
   /**
    * Set the value.
    */
-  set(value: JSONValue): void;
+  set(value: ReadonlyJSONValue): void;
+}
+
+/**
+ * The namespace for the `ObservableValue` class statics.
+ */
+export namespace IObservableValue {
+  /**
+   * The changed args object emitted by the `IObservableValue`.
+   */
+  export class IChangedArgs {
+    /**
+     * The old value.
+     */
+    oldValue: ReadonlyJSONValue | undefined;
+
+    /**
+     * The new value.
+     */
+    newValue: ReadonlyJSONValue | undefined;
+  }
 }
 
 /**
@@ -188,7 +210,9 @@ export interface IModelDB extends IDisposable {
    * The list can only store objects that are simple
    * JSON Objects and primitives.
    */
-  createList<T extends JSONValue>(path: string): IObservableUndoableList<T>;
+  createList<T extends ReadonlyJSONValue>(
+    path: string
+  ): IObservableUndoableList<T>;
 
   /**
    * Create a map and insert it in the database.
@@ -218,7 +242,7 @@ export interface IModelDB extends IDisposable {
    *
    * @param path: the path for the value.
    */
-  getValue(path: string): JSONValue | undefined;
+  getValue(path: string): ReadonlyJSONValue | undefined;
 
   /**
    * Set a value at a path. That value must already have
@@ -228,7 +252,7 @@ export interface IModelDB extends IDisposable {
    *
    * @param value: the new value.
    */
-  setValue(path: string, value: JSONValue): void;
+  setValue(path: string, value: ReadonlyJSONValue): void;
 
   /**
    * Create a view onto a subtree of the model database.
@@ -240,12 +264,34 @@ export interface IModelDB extends IDisposable {
    */
   view(basePath: string): IModelDB;
 
+  /**
+   * Run a funcion where all changes become part of a transaction.
+   * @param fn: the function to run. It recevies the transaction id
+   *            as an argument.
+   */
+  withTransaction(fn: (transactionId?: string) => void): void;
+
   /**
    * Dispose of the resources held by the database.
    */
   dispose(): void;
 }
 
+/**
+ * A namespace for the `IModelDB` interface.
+ */
+export namespace IModelDB {
+  /**
+   * A factory interface for creating `IModelDB` objects.
+   */
+  export interface IFactory {
+    /**
+     * Create a new `IModelDB` instance.
+     */
+    createNew(path: string, schemas: ReadonlyArray<Schema>): IModelDB;
+  }
+}
+
 /**
  * A concrete implementation of an `IObservableValue`.
  */
@@ -255,7 +301,7 @@ export class ObservableValue implements IObservableValue {
    *
    * @param initialValue: the starting value for the `ObservableValue`.
    */
-  constructor(initialValue: JSONValue = null) {
+  constructor(initialValue: ReadonlyJSONValue = null) {
     this._value = initialValue;
   }
 
@@ -276,21 +322,21 @@ export class ObservableValue implements IObservableValue {
   /**
    * The changed signal.
    */
-  get changed(): ISignal<this, ObservableValue.IChangedArgs> {
+  get changed(): ISignal<this, IObservableValue.IChangedArgs> {
     return this._changed;
   }
 
   /**
    * Get the current value, or `undefined` if it has not been set.
    */
-  get(): JSONValue {
+  get(): ReadonlyJSONValue {
     return this._value;
   }
 
   /**
    * Set the current value.
    */
-  set(value: JSONValue): void {
+  set(value: ReadonlyJSONValue): void {
     let oldValue = this._value;
     if (JSONExt.deepEqual(oldValue, value)) {
       return;
@@ -314,31 +360,11 @@ export class ObservableValue implements IObservableValue {
     this._value = null;
   }
 
-  private _value: JSONValue = null;
-  private _changed = new Signal<this, ObservableValue.IChangedArgs>(this);
+  private _value: ReadonlyJSONValue = null;
+  private _changed = new Signal<this, IObservableValue.IChangedArgs>(this);
   private _isDisposed = false;
 }
 
-/**
- * The namespace for the `ObservableValue` class statics.
- */
-export namespace ObservableValue {
-  /**
-   * The changed args object emitted by the `IObservableValue`.
-   */
-  export class IChangedArgs {
-    /**
-     * The old value.
-     */
-    oldValue: JSONValue | undefined;
-
-    /**
-     * The new value.
-     */
-    newValue: JSONValue | undefined;
-  }
-}
-
 /**
  * A concrete implementation of an `IModelDB`.
  */
@@ -437,7 +463,9 @@ export class ModelDB implements IModelDB {
    * The list can only store objects that are simple
    * JSON Objects and primitives.
    */
-  createList<T extends JSONValue>(path: string): IObservableUndoableList<T> {
+  createList<T extends ReadonlyJSONValue>(
+    path: string
+  ): IObservableUndoableList<T> {
     let vec = new ObservableUndoableList<T>(
       new ObservableUndoableList.IdentitySerializer<T>()
     );
@@ -484,7 +512,7 @@ export class ModelDB implements IModelDB {
    *
    * @param path: the path for the value.
    */
-  getValue(path: string): JSONValue | undefined {
+  getValue(path: string): ReadonlyJSONValue | undefined {
     let val = this.get(path);
     if (!val || val.type !== 'Value') {
       throw Error('Can only call getValue for an ObservableValue');
@@ -500,7 +528,7 @@ export class ModelDB implements IModelDB {
    *
    * @param value: the new value.
    */
-  setValue(path: string, value: JSONValue): void {
+  setValue(path: string, value: ReadonlyJSONValue): void {
     let val = this.get(path);
     if (!val || val.type !== 'Value') {
       throw Error('Can only call setValue on an ObservableValue');
@@ -535,6 +563,15 @@ export class ModelDB implements IModelDB {
     this._db.set(this._resolvePath(path), value);
   }
 
+  /**
+   * Run a funcion where all changes become part of a transaction.
+   * @param fn: the function to run. It recevies the transaction id
+   *            as an argument.
+   */
+  withTransaction(fn: (transactionId?: string) => void): void {
+    fn();
+  }
+
   /**
    * Dispose of the resources held by the database.
    */
@@ -585,14 +622,4 @@ export namespace ModelDB {
      */
     baseDB?: ModelDB;
   }
-
-  /**
-   * A factory interface for creating `IModelDB` objects.
-   */
-  export interface IFactory {
-    /**
-     * Create a new `IModelDB` instance.
-     */
-    createNew(path: string): IModelDB;
-  }
 }
diff --git a/packages/observables/src/observablelist.ts b/packages/observables/src/observablelist.ts
index e1aed85b7ba..97e9af95ef3 100644
--- a/packages/observables/src/observablelist.ts
+++ b/packages/observables/src/observablelist.ts
@@ -285,7 +285,7 @@ export namespace IObservableList {
      * #### Notes
      * The values will be contiguous starting at the `newIndex`.
      */
-    newValues: T[];
+    newValues: ReadonlyArray<T>;
 
     /**
      * The old index associated with the change.
@@ -298,7 +298,7 @@ export namespace IObservableList {
      * #### Notes
      * The values will be contiguous starting at the `oldIndex`.
      */
-    oldValues: T[];
+    oldValues: ReadonlyArray<T>;
   }
 }
 
diff --git a/packages/observables/src/observablestring.ts b/packages/observables/src/observablestring.ts
index 19ed4a08e21..f3134759258 100644
--- a/packages/observables/src/observablestring.ts
+++ b/packages/observables/src/observablestring.ts
@@ -24,7 +24,7 @@ export interface IObservableString extends IDisposable, IObservable {
   /**
    * The value of the string.
    */
-  text: string;
+  text: string | undefined;
 
   /**
    * Insert a substring.
diff --git a/packages/observables/src/undoablelist.ts b/packages/observables/src/undoablelist.ts
index 99d3a525cf3..6346039776a 100644
--- a/packages/observables/src/undoablelist.ts
+++ b/packages/observables/src/undoablelist.ts
@@ -1,7 +1,7 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { JSONValue } from '@phosphor/coreutils';
+import { ReadonlyJSONValue } from '@phosphor/coreutils';
 
 import { each } from '@phosphor/algorithm';
 
@@ -15,12 +15,12 @@ export interface ISerializer<T> {
   /**
    * Convert the object to JSON.
    */
-  toJSON(value: T): JSONValue;
+  toJSON(value: T): ReadonlyJSONValue;
 
   /**
    * Deserialize the object from JSON.
    */
-  fromJSON(value: JSONValue): T;
+  fromJSON(value: ReadonlyJSONValue): T;
 }
 
 /**
@@ -193,7 +193,9 @@ export class ObservableUndoableList<T> extends ObservableList<T>
   /**
    * Undo a change event.
    */
-  private _undoChange(change: IObservableList.IChangedArgs<JSONValue>): void {
+  private _undoChange(
+    change: IObservableList.IChangedArgs<ReadonlyJSONValue>
+  ): void {
     let index = 0;
     let serializer = this._serializer;
     switch (change.type) {
@@ -225,7 +227,9 @@ export class ObservableUndoableList<T> extends ObservableList<T>
   /**
    * Redo a change event.
    */
-  private _redoChange(change: IObservableList.IChangedArgs<JSONValue>): void {
+  private _redoChange(
+    change: IObservableList.IChangedArgs<ReadonlyJSONValue>
+  ): void {
     let index = 0;
     let serializer = this._serializer;
     switch (change.type) {
@@ -259,12 +263,12 @@ export class ObservableUndoableList<T> extends ObservableList<T>
    */
   private _copyChange(
     change: IObservableList.IChangedArgs<T>
-  ): IObservableList.IChangedArgs<JSONValue> {
-    let oldValues: JSONValue[] = [];
+  ): IObservableList.IChangedArgs<ReadonlyJSONValue> {
+    let oldValues: ReadonlyJSONValue[] = [];
     each(change.oldValues, value => {
       oldValues.push(this._serializer.toJSON(value));
     });
-    let newValues: JSONValue[] = [];
+    let newValues: ReadonlyJSONValue[] = [];
     each(change.newValues, value => {
       newValues.push(this._serializer.toJSON(value));
     });
@@ -281,7 +285,7 @@ export class ObservableUndoableList<T> extends ObservableList<T>
   private _isUndoable = true;
   private _madeCompoundChange = false;
   private _index = -1;
-  private _stack: IObservableList.IChangedArgs<JSONValue>[][] = [];
+  private _stack: IObservableList.IChangedArgs<ReadonlyJSONValue>[][] = [];
   private _serializer: ISerializer<T>;
 }
 
@@ -292,19 +296,19 @@ export namespace ObservableUndoableList {
   /**
    * A default, identity serializer.
    */
-  export class IdentitySerializer<T extends JSONValue>
+  export class IdentitySerializer<T extends ReadonlyJSONValue>
     implements ISerializer<T> {
     /**
      * Identity serialize.
      */
-    toJSON(value: T): JSONValue {
+    toJSON(value: T): ReadonlyJSONValue {
       return value;
     }
 
     /**
      * Identity deserialize.
      */
-    fromJSON(value: JSONValue): T {
+    fromJSON(value: ReadonlyJSONValue): T {
       return value as T;
     }
   }
diff --git a/packages/outputarea/src/model.ts b/packages/outputarea/src/model.ts
index 2f41453fc15..a5fb0d9c81d 100644
--- a/packages/outputarea/src/model.ts
+++ b/packages/outputarea/src/model.ts
@@ -13,7 +13,6 @@ import {
   IObservableList,
   ObservableList,
   IObservableValue,
-  ObservableValue,
   IModelDB
 } from '@jupyterlab/observables';
 
@@ -449,7 +448,7 @@ export class OutputAreaModel implements IOutputAreaModel {
    */
   private _onSerializedChanged(
     sender: IObservableValue,
-    args: ObservableValue.IChangedArgs
+    args: IObservableValue.IChangedArgs
   ) {
     if (!this._changeGuard) {
       this._changeGuard = true;
diff --git a/packages/services/src/contents/index.ts b/packages/services/src/contents/index.ts
index 758795ce674..7fe530efc92 100644
--- a/packages/services/src/contents/index.ts
+++ b/packages/services/src/contents/index.ts
@@ -3,8 +3,6 @@
 
 import { URLExt, PathExt } from '@jupyterlab/coreutils';
 
-import { ModelDB } from '@jupyterlab/observables';
-
 import { JSONObject } from '@phosphor/coreutils';
 
 import { each } from '@phosphor/algorithm';
@@ -242,13 +240,6 @@ export namespace Contents {
      */
     driveName(path: string): string;
 
-    /**
-     * Given a path, get a ModelDB.IFactory from the
-     * relevant backend. Returns `null` if the backend
-     * does not provide one.
-     */
-    getModelDBFactory(path: string): ModelDB.IFactory | null;
-
     /**
      * Get a file or directory.
      *
@@ -382,12 +373,6 @@ export namespace Contents {
      */
     readonly serverSettings: ServerConnection.ISettings;
 
-    /**
-     * An optional ModelDB.IFactory instance for the
-     * drive.
-     */
-    readonly modelDBFactory?: ModelDB.IFactory;
-
     /**
      * A signal emitted when a file operation takes place.
      */
@@ -576,16 +561,6 @@ export class ContentsManager implements Contents.IManager {
     );
   }
 
-  /**
-   * Given a path, get a ModelDB.IFactory from the
-   * relevant backend. Returns `null` if the backend
-   * does not provide one.
-   */
-  getModelDBFactory(path: string): ModelDB.IFactory | null {
-    let [drive] = this._driveForPath(path);
-    return (drive && drive.modelDBFactory) || null;
-  }
-
   /**
    * Given a path of the form `drive:local/portion/of/it.txt`
    * get the local part of it.
diff --git a/packages/services/src/index.ts b/packages/services/src/index.ts
index fc86490bf28..a78a8595407 100644
--- a/packages/services/src/index.ts
+++ b/packages/services/src/index.ts
@@ -10,6 +10,7 @@ export * from './session';
 export * from './setting';
 export * from './terminal';
 export * from './workspace';
+export * from './wsconnection';
 export * from './nbconvert';
 
 export { Builder } from './builder';
diff --git a/packages/services/src/terminal/default.ts b/packages/services/src/terminal/default.ts
index 4c5045b60c0..445f4f106d2 100644
--- a/packages/services/src/terminal/default.ts
+++ b/packages/services/src/terminal/default.ts
@@ -9,7 +9,9 @@ import { JSONPrimitive } from '@phosphor/coreutils';
 
 import { ISignal, Signal } from '@phosphor/signaling';
 
-import { ServerConnection } from '..';
+import { ServerConnection } from '../serverconnection';
+
+import { WSConnection } from '../wsconnection';
 
 import { TerminalSession } from './terminal';
 
@@ -21,15 +23,18 @@ const TERMINAL_SERVICE_URL = 'api/terminals';
 /**
  * An implementation of a terminal interface.
  */
-export class DefaultTerminalSession implements TerminalSession.ISession {
+export class DefaultTerminalSession
+  extends WSConnection<JSONPrimitive[], JSONPrimitive[]>
+  implements TerminalSession.ISession {
   /**
    * Construct a new terminal session.
    */
   constructor(name: string, options: TerminalSession.IOptions = {}) {
+    super();
     this._name = name;
     this.serverSettings =
       options.serverSettings || ServerConnection.makeSettings();
-    this._readyPromise = this._initializeSocket();
+    this._createSocket();
   }
 
   /**
@@ -65,41 +70,16 @@ export class DefaultTerminalSession implements TerminalSession.ISession {
    */
   readonly serverSettings: ServerConnection.ISettings;
 
-  /**
-   * Test whether the session is ready.
-   */
-  get isReady(): boolean {
-    return this._isReady;
-  }
-
-  /**
-   * A promise that fulfills when the session is ready.
-   */
-  get ready(): Promise<void> {
-    return this._readyPromise;
-  }
-
-  /**
-   * Test whether the session is disposed.
-   */
-  get isDisposed(): boolean {
-    return this._isDisposed;
-  }
-
   /**
    * Dispose of the resources held by the session.
    */
   dispose(): void {
-    if (this._isDisposed) {
+    if (this.isDisposed) {
       return;
     }
 
     this.terminated.emit(undefined);
-    this._isDisposed = true;
-    if (this._ws) {
-      this._ws.close();
-      this._ws = null;
-    }
+    super.dispose();
     delete Private.running[this._url];
     Signal.clearData(this);
   }
@@ -108,26 +88,12 @@ export class DefaultTerminalSession implements TerminalSession.ISession {
    * Send a message to the terminal session.
    */
   send(message: TerminalSession.IMessage): void {
-    if (this._isDisposed || !message.content) {
+    if (this.isDisposed || !message.content) {
       return;
     }
 
     const msg = [message.type, ...message.content];
-    const socket = this._ws;
-    const value = JSON.stringify(msg);
-
-    if (this._isReady && socket) {
-      socket.send(value);
-      return;
-    }
-
-    this.ready.then(() => {
-      const socket = this._ws;
-
-      if (socket) {
-        socket.send(value);
-      }
-    });
+    this.sendMessage(msg);
   }
 
   /**
@@ -136,9 +102,9 @@ export class DefaultTerminalSession implements TerminalSession.ISession {
    * @returns A promise that resolves when the terminal has reconnected.
    */
   reconnect(): Promise<void> {
-    this._reconnectAttempt = 0;
-    this._readyPromise = this._initializeSocket();
-    return this._readyPromise;
+    this.reconnectAttempt = 0;
+    this._createSocket();
+    return this.ready;
   }
 
   /**
@@ -157,126 +123,41 @@ export class DefaultTerminalSession implements TerminalSession.ISession {
     return new DefaultTerminalSession(name, { serverSettings });
   }
 
-  /**
-   * Connect to the websocket.
-   */
-  private _initializeSocket(): Promise<void> {
-    const name = this._name;
-    let socket = this._ws;
-
-    if (socket) {
-      // Clear the websocket event handlers and the socket itself.
-      socket.onopen = this._noOp;
-      socket.onclose = this._noOp;
-      socket.onerror = this._noOp;
-      socket.onmessage = this._noOp;
-      socket.close();
-      this._ws = null;
-    }
-    this._isReady = false;
-
-    return new Promise<void>((resolve, reject) => {
-      const settings = this.serverSettings;
-      const token = this.serverSettings.token;
+  protected wsFactory() {
+    const settings = this.serverSettings;
+    const token = this.serverSettings.token;
 
-      this._url = Private.getTermUrl(settings.baseUrl, this._name);
-      Private.running[this._url] = this;
+    this._url = Private.getTermUrl(settings.baseUrl, this._name);
+    Private.running[this._url] = this;
 
-      let wsUrl = URLExt.join(settings.wsUrl, `terminals/websocket/${name}`);
+    let wsUrl = URLExt.join(settings.wsUrl, `terminals/websocket/${name}`);
 
-      if (token) {
-        wsUrl = wsUrl + `?token=${encodeURIComponent(token)}`;
-      }
-
-      socket = this._ws = new settings.WebSocket(wsUrl);
-
-      socket.onmessage = (event: MessageEvent) => {
-        if (this._isDisposed) {
-          return;
-        }
-
-        const data = JSON.parse(event.data) as JSONPrimitive[];
-
-        if (this._reconnectAttempt > 0) {
-          // After reconnection, ignore all messages until a 'setup' message.
-          if (data[0] === 'setup') {
-            this._reconnectAttempt = 0;
-          }
-          return;
-        }
-
-        this._messageReceived.emit({
-          type: data[0] as TerminalSession.MessageType,
-          content: data.slice(1)
-        });
-      };
-
-      socket.onopen = (event: MessageEvent) => {
-        if (!this._isDisposed) {
-          this._isReady = true;
-          resolve(undefined);
-        }
-      };
-
-      socket.onerror = (event: Event) => {
-        if (!this._isDisposed) {
-          reject(event);
-        }
-      };
-
-      socket.onclose = (event: CloseEvent) => {
-        console.warn(`Terminal websocket closed: ${event.code}`);
-        this._reconnectSocket();
-      };
-    });
-  }
-
-  private _reconnectSocket(): void {
-    if (this._isDisposed || !this._ws) {
-      return;
+    if (token) {
+      wsUrl = wsUrl + `?token=${encodeURIComponent(token)}`;
     }
 
-    const attempt = this._reconnectAttempt;
-    const limit = this._reconnectLimit;
+    return new settings.WebSocket(wsUrl);
+  }
 
-    if (attempt >= limit) {
-      console.log(`Terminal reconnect aborted: ${attempt} attempts`);
+  protected handleMessage(data: JSONPrimitive[]): boolean {
+    if (this.reconnectAttempt > 0) {
+      // After reconnection, ignore all messages until a 'setup' message.
+      if (data[0] === 'setup') {
+        this.reconnectAttempt = 0;
+      }
       return;
     }
 
-    const timeout = Math.pow(2, attempt);
-
-    console.log(`Terminal will attempt to reconnect in ${timeout}s`);
-    this._isReady = false;
-    this._reconnectAttempt += 1;
-
-    setTimeout(() => {
-      if (this.isDisposed) {
-        return;
-      }
-      this._initializeSocket()
-        .then(() => {
-          console.log('Terminal reconnected');
-        })
-        .catch(reason => {
-          console.warn(`Terminal reconnect failed`, reason);
-        });
-    }, 1e3 * timeout);
+    this._messageReceived.emit({
+      type: data[0] as TerminalSession.MessageType,
+      content: data.slice(1)
+    });
   }
 
-  private _isDisposed = false;
-  private _isReady = false;
   private _messageReceived = new Signal<this, TerminalSession.IMessage>(this);
   private _terminated = new Signal<this, void>(this);
   private _name: string;
-  private _readyPromise: Promise<void>;
   private _url: string;
-  private _ws: WebSocket | null = null;
-  private _noOp = () => {
-    /* no-op */
-  };
-  private _reconnectLimit = 7;
-  private _reconnectAttempt = 0;
 }
 
 /**
diff --git a/packages/services/src/wsconnection.ts b/packages/services/src/wsconnection.ts
new file mode 100644
index 00000000000..2b257668ecd
--- /dev/null
+++ b/packages/services/src/wsconnection.ts
@@ -0,0 +1,221 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import { PromiseDelegate } from '@phosphor/coreutils';
+
+import { IDisposable } from '@phosphor/disposable';
+
+/**
+ * Abstract base for a class that sends/receives messages over websocket.
+ */
+export abstract class WSConnection<TSendMsg, TRecvMsg> implements IDisposable {
+  /**
+   * Dispose of the resources held by the connection.
+   */
+  dispose(): void {
+    if (this.isDisposed) {
+      return;
+    }
+    this._isDisposed = true;
+    this._clearSocket();
+  }
+
+  /**
+   * Test whether the connection has been disposed.
+   */
+  get isDisposed(): boolean {
+    return this._isDisposed;
+  }
+
+  /**
+   * Test whether the connection is ready.
+   */
+  get isReady(): boolean {
+    return !this._wsStopped;
+  }
+
+  /**
+   * A promise that resolves once the connection is open.
+   */
+  get ready(): Promise<void> {
+    return this._readyDelegate.promise;
+  }
+
+  /**
+   * Factory function for a WebSocket.
+   */
+  protected abstract wsFactory(): WebSocket;
+
+  /**
+   * Send a message over the websocket.
+   *
+   * @param msg - The JSON value to send.
+   *
+   */
+  protected sendMessage(msg: TSendMsg) {
+    if (!this._ws || this._wsStopped) {
+      throw new Error('Web socket not connected');
+    }
+
+    const value = this.serializeWSMessage(msg);
+
+    this._ws.send(value);
+  }
+
+  /**
+   * Handle a received, decoded WS message.
+   *
+   * @param msg - The decoded message that was received.
+   *
+   * @returns Whether the message was handled.
+   */
+  protected abstract handleMessage(msg: TRecvMsg): boolean;
+
+  /**
+   * Whether a closed connection should reconnect.
+   *
+   * @return - Returns false if it should not reconnect.
+   * Otherwise it returns a number indicating the delay before reconnecting
+   * in ms. Return 0 to reconnect as soon as possible.
+   */
+  protected shouldReconnect(): false | number {
+    if (this.reconnectAttempt >= this.reconnectLimit) {
+      console.log(
+        `Websocket reconnect abandoned after ${this.reconnectAttempt} attempts`
+      );
+      return false;
+    }
+    return 1e3 * Math.pow(2, this.reconnectAttempt++);
+  }
+
+  protected serializeWSMessage(
+    msg: TSendMsg
+  ): string | ArrayBuffer | Blob | ArrayBufferView {
+    return JSON.stringify(msg);
+  }
+
+  protected deserializeWSMessage(data: unknown): TRecvMsg {
+    if (typeof data !== 'string') {
+      console.error(`Invalid websocket message data type: ${typeof data}`);
+      return;
+    }
+    try {
+      return JSON.parse(data);
+    } catch (error) {
+      console.error(`Invalid message: ${error.message}`);
+      return;
+    }
+  }
+
+  /**
+   * Create the websocket connection and add socket status handlers.
+   */
+  protected _createSocket = () => {
+    this._clearSocket();
+    this._wsStopped = false;
+    this._ws = this.wsFactory();
+    this._readyDelegate = new PromiseDelegate<void>();
+
+    this._ws.onmessage = this._onWSMessage.bind(this);
+    this._ws.onopen = this._onWSOpen.bind(this);
+    this._ws.onclose = this._onWSClose.bind(this);
+    this._ws.onerror = this._onWSError.bind(this);
+  };
+
+  /**
+   * Clear the socket state.
+   */
+  private _clearSocket(): void {
+    this._wsStopped = true;
+    if (this._ws !== null) {
+      // Clear the websocket event handlers and the socket itself.
+      this._ws.onopen = this._noOp;
+      this._ws.onclose = this._noOp;
+      this._ws.onerror = this._noOp;
+      this._ws.onmessage = this._noOp;
+      this._ws.close();
+      this._ws = null;
+    }
+  }
+
+  private _onWSOpen(evt: Event): void {
+    if (!this.isDisposed) {
+      this.reconnectAttempt = 0;
+      this._wsStopped = false;
+      this._readyDelegate.resolve(undefined);
+    }
+  }
+
+  private _onWSMessage(evt: MessageEvent) {
+    if (this._wsStopped) {
+      // If the socket is being closed, ignore any messages
+      return;
+    }
+    const msg = this.deserializeWSMessage(evt.data);
+
+    let handled = this.handleMessage(msg);
+    if (!handled) {
+      console.log('Unhandled websocket message.', msg);
+    }
+  }
+
+  private _onWSClose(evt: CloseEvent) {
+    if (this._wsStopped || !this._ws) {
+      return;
+    }
+    console.warn(`Websocket closed: ${evt.code}`);
+    this._reconnectSocket();
+  }
+
+  private _onWSError(evt: Event) {
+    if (!this._isDisposed) {
+      this._readyDelegate.reject(evt);
+    }
+  }
+
+  private _reconnectSocket(): void {
+    const delay = this.shouldReconnect();
+    if (delay === false) {
+      return;
+    }
+
+    console.log(`Websocket will attempt to reconnect in ${delay * 1e-3}s`);
+    this._wsStopped = true;
+
+    setTimeout(() => {
+      if (this.isDisposed) {
+        return;
+      }
+      this._createSocket();
+      this.ready
+        .then(() => {
+          console.log('Websocket reconnected');
+        })
+        .catch(reason => {
+          console.warn(`Websocket reconnect failed`, reason);
+        });
+    }, delay);
+  }
+
+  protected readonly reconnectLimit = 7;
+  protected reconnectAttempt = 0;
+  protected _ws: WebSocket | null = null;
+  protected _wsStopped = true;
+
+  private _isDisposed = false;
+  private _readyDelegate: PromiseDelegate<void> | null = null;
+
+  private readonly _noOp = () => {
+    /* no-op */
+  };
+}
+
+/**
+ * The namespace for WSConnection statics.
+ */
+export namespace WSConnection {
+  /**
+   * A websocket factory function.
+   */
+  export type WSFactory = () => WebSocket;
+}
diff --git a/yarn.lock b/yarn.lock
index 596c496558f..36bbd98ceb3 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -618,6 +618,16 @@
     "@phosphor/signaling" "^1.2.2"
     "@phosphor/widgets" "^1.6.0"
 
+"@phosphor/datastore@file:../phosphor/packages/datastore":
+  version "0.7.0"
+  dependencies:
+    "@phosphor/algorithm" "^1.1.2"
+    "@phosphor/collections" "^1.1.2"
+    "@phosphor/coreutils" "^1.3.0"
+    "@phosphor/disposable" "^1.1.2"
+    "@phosphor/messaging" "^1.2.2"
+    "@phosphor/signaling" "^1.2.2"
+
 "@phosphor/disposable@^1.1.2":
   version "1.1.2"
   resolved "https://registry.yarnpkg.com/@phosphor/disposable/-/disposable-1.1.2.tgz#a192dd6a2e6c69d5d09d39ecf334dab93778060e"
