diff --git a/.gitignore b/.gitignore
index 6b07c0b4a26..8d187d47d49 100644
--- a/.gitignore
+++ b/.gitignore
@@ -35,6 +35,7 @@ __pycache__
 *.swp
 *.map
 .idea/
+.mypy_cache
 
 coverage/
 tests/**/coverage
diff --git a/dev_mode/package.json b/dev_mode/package.json
index c3029da2d25..9b900b953d8 100644
--- a/dev_mode/package.json
+++ b/dev_mode/package.json
@@ -22,6 +22,7 @@
     "@jupyterlab/console-extension": "^1.0.1",
     "@jupyterlab/coreutils": "^3.0.0",
     "@jupyterlab/csvviewer-extension": "^1.0.1",
+    "@jupyterlab/datastore-extension": "^1.0.0",
     "@jupyterlab/docmanager": "^1.0.1",
     "@jupyterlab/docmanager-extension": "^1.0.1",
     "@jupyterlab/documentsearch-extension": "^1.0.1",
@@ -126,6 +127,7 @@
       "@jupyterlab/completer-extension": "",
       "@jupyterlab/console-extension": "",
       "@jupyterlab/csvviewer-extension": "",
+      "@jupyterlab/datastore-extension": "",
       "@jupyterlab/docmanager-extension": "",
       "@jupyterlab/documentsearch-extension": "",
       "@jupyterlab/extensionmanager-extension": "",
@@ -235,6 +237,8 @@
       "@jupyterlab/coreutils": "../packages/coreutils",
       "@jupyterlab/csvviewer": "../packages/csvviewer",
       "@jupyterlab/csvviewer-extension": "../packages/csvviewer-extension",
+      "@jupyterlab/datastore": "../packages/datastore",
+      "@jupyterlab/datastore-extension": "../packages/datastore-extension",
       "@jupyterlab/docmanager": "../packages/docmanager",
       "@jupyterlab/docmanager-extension": "../packages/docmanager-extension",
       "@jupyterlab/docregistry": "../packages/docregistry",
diff --git a/jupyterlab/commands.py b/jupyterlab/commands.py
index d2e2c89c638..865bcfbe728 100644
--- a/jupyterlab/commands.py
+++ b/jupyterlab/commands.py
@@ -20,7 +20,7 @@
 import tarfile
 from tempfile import TemporaryDirectory
 from threading import Event
-from urllib.request import Request, urlopen, urljoin, quote
+from urllib.request import Request, urlopen, urljoin, quote  # type: ignore
 from urllib.error import URLError
 
 from jupyter_core.paths import jupyter_config_path
@@ -1539,8 +1539,8 @@ def sort_key(key_value):
         with TemporaryDirectory() as tempdir:
             ret = self._run([which('npm'), 'pack'] + keys, cwd=tempdir)
             if ret != 0:
-                msg = '"%s" is not a valid npm package'
-                raise ValueError(msg % keys)
+                msg = 'One or more packages is not a valid npm package: %r'
+                raise ValueError(msg % (keys,))
 
             for key in keys:
                 fname = key[0].replace('@', '') + key[1:].replace('@', '-').replace('/', '-') + '.tgz'
diff --git a/jupyterlab/datastore/__init__.py b/jupyterlab/datastore/__init__.py
new file mode 100644
index 00000000000..a7b14434476
--- /dev/null
+++ b/jupyterlab/datastore/__init__.py
@@ -0,0 +1,5 @@
+
+from .handler import (
+    CollaborationHandler, collaboration_path,
+    CollaborationsManagerHandler, datastore_rest_path
+)
diff --git a/jupyterlab/datastore/collaboration.py b/jupyterlab/datastore/collaboration.py
new file mode 100644
index 00000000000..2019bb2893d
--- /dev/null
+++ b/jupyterlab/datastore/collaboration.py
@@ -0,0 +1,89 @@
+
+import collections
+import json
+
+from tornado.ioloop import IOLoop
+import typing
+
+from .db import DatastoreDB
+from .messages import (
+    create_transaction_broadcast,
+    create_stable_state_broadcast
+)
+
+if typing.TYPE_CHECKING:
+    from .handler import CollaborationHandler
+
+
+class Collaboration:
+    def __init__(self, collaboration_id, db_file, friendly_name=None) -> None:
+        self.id = collaboration_id
+        self.db = DatastoreDB(f'collab-{collaboration_id}', db_file)
+        self.friendly_name: str = friendly_name or collaboration_id
+
+        self.last_serial: typing.Optional[int] = None
+
+        self._lastStable: int = -1
+
+        self._handlers: "typing.Set[CollaborationHandler]" = set()
+        self._dangling_handlers: "typing.Dict[CollaborationHandler, object]" = {}
+        self._serials: "typing.Dict[CollaborationHandler, int]" = collections.defaultdict(lambda: -1)
+
+    def add_client(self, handler) -> None:
+        self._handlers.add(handler)
+
+    def remove_client(self, handler) -> None:
+        self._handlers.remove(handler)
+        if handler in self._serials:
+            del self._serials[handler]
+
+    @property
+    def has_clients(self) -> bool:
+        return bool(self._handlers)
+
+    def close(self) -> None:
+        self.db.close()
+        for h in self._handlers:
+            h.close(1001)
+        self._handlers = set()
+
+    def broadcast_transactions(self, source: "CollaborationHandler", transactions, serials) -> None:
+        message = create_transaction_broadcast(transactions, serials)
+        self.broadcast_message(message, source)
+        self.last_serial = max(serials.values())
+        self.update_serial(source, self.last_serial)
+
+    def broadcast_message(self, message, exclude_handler: "typing.Optional[CollaborationHandler]" = None) -> None:
+        for handler in self._handlers:
+            if handler is exclude_handler or not handler.history_inited:
+                continue
+            handler.write_message(json.dumps(message))
+
+    def mark_dangling(self, handler: "CollaborationHandler", timeout, callback) -> None:
+        loop = IOLoop.current()
+        timer = loop.add_timeout(loop.time() + timeout, callback)
+        self._dangling_handlers[handler] = timer
+
+    def forget_dangling(self, handler: "CollaborationHandler") -> None:
+        timer = self._dangling_handlers.pop(handler)
+        loop = IOLoop.current()
+        loop.remove_timeout(timer)
+
+    def is_dangling(self, handler: "CollaborationHandler") -> bool:
+        return handler in self._dangling_handlers
+
+    def update_serial(self, handler: "CollaborationHandler", serial) -> None:
+        # We can never go back:
+        print(f"Update serial {handler} {id(handler)}")
+        print(self._serials)
+        self._serials[handler] = max(serial, self._serials[handler])
+        stable = min(
+            self._serials[handler]
+            for handler in self._handlers
+            if handler.history_inited
+        )
+        if stable > self._lastStable:
+            if len(self._serials) > 1:
+                msg = create_stable_state_broadcast(stable)
+                self.broadcast_message(msg)
+            self._lastStable = stable
diff --git a/jupyterlab/datastore/db.py b/jupyterlab/datastore/db.py
new file mode 100644
index 00000000000..5888bf7825c
--- /dev/null
+++ b/jupyterlab/datastore/db.py
@@ -0,0 +1,237 @@
+
+import collections
+import json
+import sqlite3
+import re
+
+
+sqlite3.enable_callback_tracebacks(True)
+
+def serialized(transactions):
+    for t in transactions:
+        yield (
+            t['id'],
+            t['storeId'],
+            json.dumps(t['patch']).encode('ascii'),
+            t['version'],
+        )
+
+def deserialized(rows):
+    for r in rows:
+        yield dict(
+            id=r[0],
+            storeId=r[1],
+            patch=json.loads(r[2], encoding='ascii'),
+            version=r[3],
+            serial=r[4],
+        )
+
+def decode_serials(rows):
+    for r in rows:
+        yield r[0:2]
+
+
+History = collections.namedtuple('History', ('state', 'transactions'))
+
+
+def validate_table_name(name):
+    if name is None or name.startswith('checkpoints'):
+        raise ValueError('Invalid table name %r' % (name,))
+
+
+class DatastoreDB:
+
+    def __init__(self, table_name, db_file=None):
+        # first, validate table name
+        validate_table_name(table_name)
+        self._table_name = table_name
+        self._conn = sqlite3.connect(
+            db_file or ':memory:',
+            detect_types=sqlite3.PARSE_DECLTYPES
+        )
+        self.checkpoint_id = 0
+        self._setup_db()
+
+    def close(self):
+        """Clean up resources"""
+        self._conn.close()
+
+    def _setup_db(self):
+        """Set up the database tables and constraints"""
+        c = self._conn
+
+        with c:
+            # Create table for transactions
+            c.execute('''
+                CREATE TABLE IF NOT EXISTS
+                [{0}] (
+                    id text NOT NULL UNIQUE ON CONFLICT IGNORE,
+                    storeId integer,
+                    patch json,
+                    version integer
+                )
+                '''.format(self._table_name)
+            )
+            # Create table for checkpoints
+            c.execute('''
+                CREATE TABLE IF NOT EXISTS
+                [checkpoints-{0}] (
+                    id integer PRIMARY KEY ON CONFLICT REPLACE,
+                    state text,
+                    serial integer
+                )
+                '''.format(self._table_name)
+            )
+
+    def add_transactions(self, transactions):
+        """Add a sequence of transactions to the store.
+
+        Returns a dictionary mapping the ids of the passed transactions
+        to their serial numbers.
+
+        Note: Any transactions with ids already present in the store
+        will be ignored. Their existing serial number will still be present
+        in the returned dictionary.
+        """
+        c = self._conn
+        with c:
+            # Use executemany with dict lookup to insert
+            # Note: The 'ON CONFLICT IGNORE' on the id assures
+            # that duplicate transactions are discarded.
+            c.executemany(
+                '''
+                    INSERT INTO [{0}](id, storeId, patch, version)
+                    VALUES(?, ?, ?, ?)
+                '''.format(self._table_name),
+                serialized(transactions)
+            )
+
+            ids = [t['id'] for t in transactions]
+            subst = ','.join('?' * len(ids))
+
+            return dict(decode_serials(
+                c.execute(
+                    '''
+                        SELECT id, rowid
+                        FROM [{0}]
+                        WHERE id IN ({1})
+                    '''.format(self._table_name, subst),
+                    ids
+                )
+            ))
+
+    def get_transactions(self, ids):
+        """Get the transactions with the given ids.
+
+        Yields transactions in the store that match the given ids. Note that
+        any missing ids will simply not be included in the result.
+        """
+        subst = ','.join('?' * len(ids))
+        statement = '''
+            SELECT id, storeId, patch, version, rowid
+            FROM (
+                SELECT *
+                FROM [{0}]
+                WHERE id IN ({1})
+                ORDER BY rowid
+            )
+        '''.format(self._table_name, subst)
+
+        yield from deserialized(
+            self._conn.execute(statement, ids)
+        )
+
+    def get_serials(self, serials):
+        """Get the transactions with the given serials.
+
+        Yields transactions in the store that match the given serials. Note
+        that any missing serials will simply not be included in the result.
+        """
+        subst = ','.join('?' * len(serials))
+        statement = '''
+            SELECT id, storeId, patch, version, rowid
+            FROM (
+                SELECT *
+                FROM [{0}]
+                WHERE rowid IN ({1})
+                ORDER BY rowid
+            )
+        '''.format(self._table_name, subst)
+
+        yield from deserialized(
+            self._conn.execute(statement, serials)
+        )
+
+    def has_transactions(self, ids):
+        """Whether the transactions with the given ids exist in the db.
+
+        Returns a generator of booleans indicating the prescence of the
+        given ids.
+        """
+        ids = tuple(ids)
+        subst = ','.join('?' * len(ids))
+        statement = '''
+            SELECT id
+            FROM [{0}]
+            WHERE id IN ({1})
+        '''.format(self._table_name, subst)
+
+        present = set(r[0] for r in self._conn.execute(statement, ids))
+        return (i in present for i in ids)
+
+    def make_checkpoint(self, state, serial):
+        """Make a checkpoint in the transaction history.
+
+        This creates a new checkpoint after the given serial
+        with the given serialized state.
+        """
+
+        # Insert the base for the new checkpoint into the checkpoint table
+        self._conn.execute(
+            '''
+                INSERT INTO [checkpoints-{0}](id, state, serial)
+                VALUES(?, ?)
+            '''.format(self._table_name),
+            (self.checkpoint_id, state, serial)
+        )
+        self.checkpoint_id += 1
+
+    def history(self, checkpoint_id=None):
+        """Get the history for the given checkpoint id (in order).
+
+        If the checkpoint id is not given, returns the full history
+        since the start.
+
+        Returns a namedtuple (state, transactions), with tranascations
+        being an iterator of the transactions.
+        """
+        if checkpoint_id is None:
+            serial = -1
+            state = None
+        else:
+            serial, state = tuple(next(self._conn.execute(
+                '''
+                    SELECT serial, state, id
+                    FROM [checkpoints-{0}]
+                    WHERE id = ?
+                    LIMIT 1
+                '''.format(self._table_name),
+                (checkpoint_id,)
+            ), (-1, None)))[0:2]
+
+        transactions = deserialized(
+            self._conn.execute(
+                '''
+                    SELECT id, storeId, patch, version, rowid
+                    FROM [{0}]
+                    WHERE rowid > ?
+                    ORDER BY rowid
+                '''.format(self._table_name),
+                (serial,)
+            )
+        )
+
+        return History(state, transactions)
+
+
+__all__ = ['DatastoreDB']
diff --git a/jupyterlab/datastore/handler.py b/jupyterlab/datastore/handler.py
new file mode 100644
index 00000000000..1ea000e7369
--- /dev/null
+++ b/jupyterlab/datastore/handler.py
@@ -0,0 +1,290 @@
+import json
+import uuid
+import typing
+
+from notebook.base.handlers import IPythonHandler
+from notebook.base.zmqhandlers import WebSocketMixin
+from tornado import gen, web
+from tornado.websocket import WebSocketHandler
+
+from .messages import (
+    create_error_reply,
+    create_history_reply,
+    create_permissions_reply,
+    create_serial_reply,
+    create_transaction_reply,
+    create_transactions_ack,
+)
+from .collaboration import Collaboration
+
+
+def filter_duplicates(transactions, is_duplicate):
+    for (t, d) in zip(transactions, is_duplicate):
+        if not d:
+            yield t
+
+
+class DefaultDatastoreAuth:
+    """Default implementation of a datastore authenticator."""
+
+    def check_permissions(self, user, collaboration_id, action) -> bool:
+        """Whether a specific user can perform an action for a given collaboration.
+
+        This default implementation always returns True.
+        """
+        return True
+
+
+class DatastoreHandler(IPythonHandler):
+    @property
+    def auth(self) -> DefaultDatastoreAuth:
+        return self.settings.setdefault("auth", DefaultDatastoreAuth())
+
+    collaborations: "typing.Dict[int, Collaboration]" = {}
+
+
+class CollaborationsManagerHandler(DatastoreHandler):
+    @web.authenticated
+    def get(self, *args, **kwargs) -> None:
+        # For unqualified GET, list current sessions we have read access to
+        collaborations = dict({
+            key: dict(id=key, friendlyName=c.friendly_name)
+            for key, c in self.collaborations.items()
+            if self.auth.check_permissions(self.current_user, key, "r")
+        })
+        self.finish(json.dumps(dict(collaborations=collaborations)))
+
+
+class WSBaseHandler(WebSocketMixin, WebSocketHandler, DatastoreHandler):
+    """Base class for websockets reusing jupyter code"""
+
+    def set_default_headers(self):
+        """
+        Undo the set_default_headers in IPythonHandler which doesn't make
+        sense for websockets
+        """
+        pass
+
+    def pre_get(self) -> None:
+        """Run before finishing the GET request
+
+        Extend this method to add logic that should fire before
+        the websocket finishes completing.
+        """
+        # authenticate the request before opening the websocket
+        if self.get_current_user() is None:
+            self.log.warning("Couldn't authenticate WebSocket connection")
+            raise web.HTTPError(403)
+
+    @gen.coroutine
+    def get(self, *args, **kwargs):
+        # pre_get can be a coroutine in subclasses
+        # assign and yield in two step to avoid tornado 3 issues
+        res = self.pre_get()
+        yield gen.maybe_future(res)
+        yield super(WSBaseHandler, self).get(*args, **kwargs)
+
+    def get_compression_options(self):
+        return self.settings.get("websocket_compression_options", None)
+
+
+class CollaborationHandler(WSBaseHandler):
+    """Request handler for the datastore API"""
+
+    def initialize(self) -> None:
+        self.log.info("Initializing datastore connection %s", self.request.path)
+        self.collaboration: typing.Optional[Collaboration] = None
+        self.collaboration_id = None
+        self.store_transaction_serial = -1
+        self.history_inited = False
+
+    @property
+    def datastore_file(self):
+        return self.settings.setdefault("datastore_file", ":memory:")
+
+    @property
+    def rtc_recovery_timeout(self):
+        return self.settings.get("rtc_recovery_timeout", 120)
+
+    def open(self, collaboration_id=None) -> None:
+        self.log.info("Datastore open called...")
+
+        if collaboration_id is None:
+            self.log.warning("No collaboration id specified")
+            collaboration_id = uuid.uuid4()
+        self.collaboration_id = collaboration_id
+
+        if self.collaborations.get(collaboration_id, None) is None:
+            self.log.info("Created new collaboration %s" % collaboration_id)
+            self.collaborations[collaboration_id] = Collaboration(
+                collaboration_id, self.datastore_file
+            )
+        self.collaboration = self.collaborations[collaboration_id]
+
+        self.collaboration.add_client(self)
+
+        super(CollaborationHandler, self).open()
+        self.log.info("Opened datastore websocket")
+
+    def cleanup_closed(self) -> None:
+        """Cleanup after clean close, or after recovery timeout on unclean close.
+        """
+        assert self.collaboration
+        # Unmark as dangling if needed:
+        try:
+            self.collaboration.forget_dangling(self)
+        except KeyError:
+            pass
+
+        if self.datastore_file != ":memory:" and not self.collaboration.has_clients:
+            self.collaboration.close()
+            self.collaboration = None
+            assert self.collaboration_id
+            del self.collaborations[self.collaboration_id]
+
+    def on_close(self) -> None:
+        assert self.collaboration
+        clean_close = self.close_code in (1000, 1001)
+        self.collaboration.remove_client(self)
+        if clean_close:
+            self.cleanup_closed()
+        else:
+            # Un-clean close after a store was established
+            self.collaboration.mark_dangling(
+                self, self.rtc_recovery_timeout, self.cleanup_closed
+            )
+
+        super(CollaborationHandler, self).on_close()
+        self.log.info("Closed datastore websocket")
+
+    def send_error_reply(self, parent_msg_id, reason) -> None:
+        msg = create_error_reply(parent_msg_id, reason)
+        self.log.error(reason)
+        self.write_message(json.dumps(msg))
+
+    def check_permissions(self, action):
+        return self.auth.check_permissions(
+            self.current_user, self.collaboration_id, action
+        )
+
+    def on_message(self, message) -> None:
+        msg = json.loads(message)
+        msg_type = msg.pop("msgType", None)
+        msg_id = msg.pop("msgId", None)
+        reply = None
+        assert self.collaboration
+
+        self.log.info(
+            "Received datastore message %s: \n%s"
+            % (msg_type, json.dumps(msg, indent=2))
+        )
+
+        if msg_type == "transaction-broadcast":
+            if not self.check_permissions("w"):
+                return self.send_error_reply(
+                    msg_id,
+                    "Permisson error: Cannot write transactions to current collaboration.",
+                )
+
+            # Get the transactions:
+            content = msg.pop("content", None)
+            if content is None:
+                self.log.warning("Malformed transaction broadcast message received")
+                return
+            transactions = content.pop("transactions", None)
+            if transactions is None:
+                self.log.warning("Malformed transaction broadcast message received")
+                return
+
+            # Ensure that transaction serials increment as expected:
+            for t in transactions:
+                if t["serial"] != self.store_transaction_serial + 1:
+                    # TODO: ! Missing a transaction, recover !
+                    raise ValueError(
+                        "Missing transaction %d from %r"
+                        % (self.store_transaction_serial, self)
+                    )
+                self.store_transaction_serial += 1
+
+            # Check for any duplicates before adding
+            is_duplicate = self.collaboration.db.has_transactions(
+                t["id"] for t in transactions
+            )
+
+            # Add to transaction store, generating a central serial for each
+            serials = self.collaboration.db.add_transactions(transactions)
+
+            # Create an acknowledgment message to the source
+            reply = create_transactions_ack(msg_id, transactions, serials)
+            self.write_message(json.dumps(reply))
+
+            # Broadcast the tranasctions to all other stores
+            # First, filter away duplicates
+            filtered = filter_duplicates(transactions, is_duplicate)
+            self.collaboration.broadcast_transactions(self, filtered, serials)
+
+        elif msg_type == "history-request":
+            if not self.check_permissions("r"):
+                return self.send_error_reply(
+                    msg_id,
+                    "Permisson error: Cannot access collaboration: %s"
+                    % (self.collaboration_id,),
+                )
+            content = msg.pop("content", {})
+            checkpoint_id = content.pop("checkpointId", None)
+            history = self.collaboration.db.history(checkpoint_id)
+            reply = create_history_reply(
+                msg_id, tuple(history.transactions), history.state
+            )
+            self.write_message(json.dumps(reply))
+            self.history_inited = True
+
+        elif msg_type == "transaction-request":
+            if not self.check_permissions("r"):
+                return self.send_error_reply(
+                    msg_id,
+                    "Permisson error: Cannot access collaboration: %s"
+                    % (self.collaboration_id,),
+                )
+            content = msg.pop("content", None)
+            if content is None:
+                return
+            transactionIds = content.pop("transactionIds", [])
+            transactions = tuple(self.collaboration.db.get_transactions(transactionIds))
+            reply = create_transaction_reply(msg_id, transactions)
+            self.write_message(json.dumps(reply))
+
+        elif msg_type == "serial-request":
+            if not self.check_permissions("r"):
+                return self.send_error_reply(
+                    msg_id,
+                    "Permisson error: Cannot access collaboration: %s"
+                    % (self.collaboration_id,),
+                )
+            content = msg.pop("content", None)
+            if content is None:
+                return
+            serials = content.pop("serials", [])
+            transactions = tuple(self.collaboration.db.get_serials(serials))
+            reply = create_serial_reply(msg_id, transactions)
+            self.write_message(json.dumps(reply))
+
+        elif msg_type == "permissions-request":
+            reply = create_permissions_reply(
+                msg_id, self.check_permissions("r"), self.check_permissions("w")
+            )
+            self.write_message(json.dumps(reply))
+
+        elif msg_type == "serial-update":
+            content = msg.pop("content", None)
+            if content is None:
+                return
+            serial = content.pop("serial", None)
+            if serial is not None:
+                self.collaboration.update_serial(self, serial)
+
+
+# The path for lab build.
+# TODO: Is this a reasonable path?
+collaboration_path = r"/lab/api/datastore/(?P<collaboration_id>.+)(?:[^/])/?"
+datastore_rest_path = r"/lab/api/datastore/?"
diff --git a/jupyterlab/datastore/messages.py b/jupyterlab/datastore/messages.py
new file mode 100644
index 00000000000..468240c7033
--- /dev/null
+++ b/jupyterlab/datastore/messages.py
@@ -0,0 +1,85 @@
+
+import uuid
+
+
+def create_transactions_ack(parent_id, transactions, serials):
+    return dict(
+        msgId=str(uuid.uuid4()),
+        msgType='transaction-ack',
+        parentId=parent_id,
+        content=dict(
+            transactionIds=[t['id'] for t in transactions],
+            serials=[serials[t['id']] for t in transactions]
+        )
+    )
+
+def create_history_reply(parent_id, transactions, state=None):
+    return dict(
+        msgId=str(uuid.uuid4()),
+        msgType='history-reply',
+        parentId=parent_id,
+        content=dict(
+            state=state,
+            transactions=transactions
+        )
+    )
+
+def create_transaction_reply(parent_id, transactions):
+    return dict(
+        msgId=str(uuid.uuid4()),
+        msgType='transaction-reply',
+        parentId=parent_id,
+        content=dict(
+            transactions=transactions
+        )
+    )
+
+def create_serial_reply(parent_id, transactions):
+    return dict(
+        msgId=str(uuid.uuid4()),
+        msgType='serial-reply',
+        parentId=parent_id,
+        content=dict(
+            transactions=transactions
+        )
+    )
+
+def create_permissions_reply(parent_id, read, write):
+    return dict(
+        msgId=str(uuid.uuid4()),
+        msgType='permissions-reply',
+        parentId=parent_id,
+        content=dict(
+            read=read,
+            write=write
+        )
+    )
+
+def create_stable_state_broadcast(serial):
+    return dict(
+        msgId=str(uuid.uuid4()),
+        msgType='state-stable',
+        content=dict(
+            serial=serial
+        )
+    )
+
+def create_transaction_broadcast(transactions, serials):
+    rebranded = [ dict(t, serial=serials[t['id']]) for t in transactions ]
+    return dict(
+        msgId=str(uuid.uuid4()),
+        msgType='transaction-broadcast',
+        content=dict(
+            transactions=rebranded
+        )
+    )
+
+def create_error_reply(parent_id, reason):
+    return dict(
+        msgId=str(uuid.uuid4()),
+        msgType='error-reply',
+        parentId=parent_id,
+        content=dict(
+            reason=reason
+        )
+    )
diff --git a/jupyterlab/extension.py b/jupyterlab/extension.py
index f82aedf6024..e378f851659 100644
--- a/jupyterlab/extension.py
+++ b/jupyterlab/extension.py
@@ -87,6 +87,10 @@ def load_jupyter_server_extension(nbapp):
         extensions_handler_path, ExtensionManager, ExtensionHandler
     )
     from .handlers.error_handler import ErrorHandler
+    from .datastore import (
+        CollaborationHandler, collaboration_path,
+        CollaborationsManagerHandler, datastore_rest_path
+    )
     from .commands import (
         DEV_DIR, HERE, ensure_app, ensure_core, ensure_dev, watch,
         watch_dev, get_app_dir
@@ -197,6 +201,20 @@ def load_jupyter_server_extension(nbapp):
 
         config.cache_files = False
 
+    base_url = web_app.settings['base_url']
+
+    build_url = ujoin(base_url, build_path)
+    builder = Builder(logger, core_mode, app_dir)
+    build_handler = (build_url, BuildHandler, {'builder': builder})
+
+    collaborations_url = ujoin(base_url, collaboration_path)
+    collaborations_handler = (collaborations_url, CollaborationHandler, {})
+
+    colab_manager_url = ujoin(base_url, datastore_rest_path)
+    colab_manager_handler = (colab_manager_url, CollaborationsManagerHandler, {})
+
+    handlers = [build_handler, collaborations_handler, colab_manager_handler]
+
     if not core_mode and not errored:
         ext_url = ujoin(base_url, extensions_handler_path)
         ext_manager = ExtensionManager(logger, app_dir)
diff --git a/jupyterlab/semver.py b/jupyterlab/semver.py
index 7726d79b86e..32f4aac3d44 100644
--- a/jupyterlab/semver.py
+++ b/jupyterlab/semver.py
@@ -34,7 +34,7 @@
 
 # Python 2/3 compatibility
 try:
-  string_type = basestring
+  string_type = basestring # type: ignore
 except NameError:
   string_type = str
 
diff --git a/mypy.ini b/mypy.ini
new file mode 100644
index 00000000000..5715644b416
--- /dev/null
+++ b/mypy.ini
@@ -0,0 +1,6 @@
+[mypy]
+python_version = 3.6
+check_untyped_defs = True
+strict_equality = True
+follow_imports = silent
+ignore_missing_imports = True
\ No newline at end of file
diff --git a/packages/application/src/lab.ts b/packages/application/src/lab.ts
index 3640a79c668..ce3f1d9af89 100644
--- a/packages/application/src/lab.ts
+++ b/packages/application/src/lab.ts
@@ -3,7 +3,10 @@
 
 import { PageConfig } from '@jupyterlab/coreutils';
 
-import { Base64ModelFactory } from '@jupyterlab/docregistry';
+import {
+  Base64ModelFactory,
+  StringModelFactory
+} from '@jupyterlab/docregistry';
 
 import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
 
@@ -78,8 +81,9 @@ export class JupyterLab extends JupyterFrontEnd<ILabShell> {
       this.shell.addClass('jp-mod-devMode');
     }
 
-    // Add initial model factory.
+    // Add model factories for opaque string and base64-encoded data..
     this.docRegistry.addModelFactory(new Base64ModelFactory());
+    this.docRegistry.addModelFactory(new StringModelFactory());
 
     if (options.mimeExtensions) {
       for (let plugin of createRendermimePlugins(options.mimeExtensions)) {
diff --git a/packages/attachments/package.json b/packages/attachments/package.json
index 30ec621baca..15f2a2c73fe 100644
--- a/packages/attachments/package.json
+++ b/packages/attachments/package.json
@@ -36,11 +36,11 @@
   },
   "dependencies": {
     "@jupyterlab/coreutils": "^3.0.0",
-    "@jupyterlab/observables": "^2.2.0",
+    "@jupyterlab/datastore": "^1.0.0",
     "@jupyterlab/rendermime": "^1.0.1",
     "@jupyterlab/rendermime-interfaces": "^1.3.0",
-    "@phosphor/disposable": "^1.2.0",
-    "@phosphor/signaling": "^1.2.3"
+    "@phosphor/coreutils": "^1.3.1",
+    "@phosphor/datastore": "0.7.2"
   },
   "devDependencies": {
     "rimraf": "~2.6.2",
diff --git a/packages/attachments/src/data.ts b/packages/attachments/src/data.ts
new file mode 100644
index 00000000000..82abb0df77d
--- /dev/null
+++ b/packages/attachments/src/data.ts
@@ -0,0 +1,235 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import { nbformat } from '@jupyterlab/coreutils';
+
+import { DatastoreExt } from '@jupyterlab/datastore';
+
+import { imageRendererFactory } from '@jupyterlab/rendermime';
+
+import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
+
+import {
+  JSONExt,
+  JSONObject,
+  JSONValue,
+  ReadonlyJSONObject
+} from '@phosphor/coreutils';
+
+import { MapField } from '@phosphor/datastore';
+
+/**
+ * The namespace for IAttachmentsData interfaces.
+ */
+export namespace IAttachmentsData {
+  /**
+   * An interface for schema fields for an attachments model.
+   */
+  export type Fields = {
+    /**
+     * A map storing attachments.
+     */
+    attachments: MapField<nbformat.IMimeBundle>;
+  };
+
+  /**
+   * The attachments data schema.
+   */
+  export type Schema = {
+    /**
+     * The id for the schema.
+     */
+    id: string;
+
+    /**
+     * The fields storing attachment model data.
+     */
+    fields: {
+      /**
+       * A map storing attachments.
+       */
+      attachments: MapField<nbformat.IMimeBundle>;
+    };
+  };
+
+  /**
+   * The location of data in a datastore for attachments.
+   */
+  export type DataLocation = DatastoreExt.DataLocation & {
+    /**
+     * A record for storing an attachment.
+     */
+    record: DatastoreExt.RecordLocation<Schema>;
+  };
+}
+
+/**
+ * A namespace for AttachmentsData functionality.
+ */
+export namespace AttachmentsData {
+  /**
+   * Get the data for an attachment.
+   *
+   * @params bundle - A kernel attachment MIME bundle.
+   *
+   * @returns - The data for the payload.
+   */
+  export function getData(bundle: nbformat.IMimeBundle): JSONObject {
+    return Private.getData(bundle);
+  }
+
+  /**
+   * Serialize the attachment model to JSON.
+   */
+  export function toJSON(
+    loc: IAttachmentsData.DataLocation
+  ): nbformat.IAttachments {
+    return DatastoreExt.getField(loc.datastore, {
+      ...loc.record,
+      field: 'attachments'
+    });
+  }
+
+  /**
+   * Deserialize an attachment model from JSON, inserting it into a record.
+   */
+  export function fromJSON(
+    loc: IAttachmentsData.DataLocation,
+    value: nbformat.IAttachments
+  ): void {
+    // Construct an update, removing any old data from the bundle.
+    const old = toJSON(loc);
+    Object.keys(old).forEach(key => {
+      old[key] = null;
+    });
+    const update = { ...old, ...value };
+    DatastoreExt.withTransaction(loc.datastore, () => {
+      DatastoreExt.updateField(
+        loc.datastore,
+        { ...loc.record, field: 'attachments' },
+        update
+      );
+    });
+  }
+}
+
+/**
+ * A resolver for cell attachments 'attchment:filename'.
+ *
+ * Will resolve to a data: url.
+ */
+export class AttachmentsResolver implements IRenderMime.IResolver {
+  /**
+   * Create an attachments resolver object.
+   */
+  constructor(options: AttachmentsResolver.IOptions) {
+    this._parent = options.parent || null;
+    this._data = options.data;
+  }
+  /**
+   * Resolve a relative url to a correct server path.
+   */
+  resolveUrl(url: string): Promise<string> {
+    if (this._parent && !url.startsWith('attachment:')) {
+      return this._parent.resolveUrl(url);
+    }
+    return Promise.resolve(url);
+  }
+
+  /**
+   * Get the download url of a given absolute server path.
+   */
+  getDownloadUrl(path: string): Promise<string> {
+    if (this._parent && !path.startsWith('attachment:')) {
+      return this._parent.getDownloadUrl(path);
+    }
+    // Return a data URL with the data of the url
+    const key = path.slice('attachment:'.length);
+    const attachment = DatastoreExt.getField(this._data.datastore, {
+      ...this._data.record,
+      field: 'attachments'
+    });
+    if (!attachment || !attachment[key]) {
+      // Resolve with unprocessed path, to show as broken image
+      return Promise.resolve(path);
+    }
+    const data = AttachmentsData.getData(attachment[key]);
+    const mimeType = Object.keys(data)[0];
+    // Only support known safe types:
+    if (imageRendererFactory.mimeTypes.indexOf(mimeType) === -1) {
+      return Promise.reject(
+        `Cannot render unknown image mime type "${mimeType}".`
+      );
+    }
+    const dataUrl = `data:${mimeType};base64,${data[mimeType]}`;
+    return Promise.resolve(dataUrl);
+  }
+
+  /**
+   * Whether the URL should be handled by the resolver
+   * or not.
+   */
+  isLocal(url: string): boolean {
+    if (this._parent && !url.startsWith('attachment:')) {
+      return this._parent.isLocal(url);
+    }
+    return true;
+  }
+
+  private _data: IAttachmentsData.DataLocation;
+  private _parent: IRenderMime.IResolver | null;
+}
+
+/**
+ * The namespace for `AttachmentsResolver` class statics.
+ */
+export namespace AttachmentsResolver {
+  /**
+   * The options used to create an AttachmentsResolver.
+   */
+  export interface IOptions {
+    /**
+     * The attachments model to resolve against.
+     */
+    data: IAttachmentsData.DataLocation;
+
+    /**
+     * A parent resolver to use if the URL/path is not for an attachment.
+     */
+    parent?: IRenderMime.IResolver;
+  }
+}
+
+/**
+ * The namespace for module private data.
+ */
+namespace Private {
+  /**
+   * Get the data from a notebook attachment.
+   */
+  export function getData(bundle: nbformat.IMimeBundle): JSONObject {
+    return convertBundle(bundle);
+  }
+
+  /**
+   * Extract a value from a JSONObject.
+   */
+  export function extract(value: ReadonlyJSONObject, key: string): JSONValue {
+    let item = value[key];
+    if (JSONExt.isPrimitive(item)) {
+      return item;
+    }
+    return JSONExt.deepCopy(item as JSONValue);
+  }
+
+  /**
+   * Convert a mime bundle to mime data.
+   */
+  function convertBundle(bundle: nbformat.IMimeBundle): JSONObject {
+    let map: JSONObject = Object.create(null);
+    for (let mimeType in bundle) {
+      map[mimeType] = extract(bundle, mimeType);
+    }
+    return map;
+  }
+}
diff --git a/packages/attachments/src/index.ts b/packages/attachments/src/index.ts
index e6f235adbe0..f9414df8864 100644
--- a/packages/attachments/src/index.ts
+++ b/packages/attachments/src/index.ts
@@ -3,4 +3,4 @@
 | Distributed under the terms of the Modified BSD License.
 |----------------------------------------------------------------------------*/
 
-export * from './model';
+export * from './data';
diff --git a/packages/attachments/src/model.ts b/packages/attachments/src/model.ts
deleted file mode 100644
index 2a55f28b65d..00000000000
--- a/packages/attachments/src/model.ts
+++ /dev/null
@@ -1,433 +0,0 @@
-// Copyright (c) Jupyter Development Team.
-// Distributed under the terms of the Modified BSD License.
-
-import { nbformat } from '@jupyterlab/coreutils';
-
-import {
-  IObservableMap,
-  ObservableMap,
-  IObservableValue,
-  ObservableValue,
-  IModelDB
-} from '@jupyterlab/observables';
-
-import {
-  IAttachmentModel,
-  AttachmentModel,
-  imageRendererFactory
-} from '@jupyterlab/rendermime';
-
-import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
-
-import { IDisposable } from '@phosphor/disposable';
-
-import { ISignal, Signal } from '@phosphor/signaling';
-
-/**
- * The model for attachments.
- */
-export interface IAttachmentsModel extends IDisposable {
-  /**
-   * A signal emitted when the model state changes.
-   */
-  readonly stateChanged: ISignal<IAttachmentsModel, void>;
-
-  /**
-   * A signal emitted when the model changes.
-   */
-  readonly changed: ISignal<IAttachmentsModel, IAttachmentsModel.ChangedArgs>;
-
-  /**
-   * The length of the items in the model.
-   */
-  readonly length: number;
-
-  /**
-   * The keys of the attachments in the model.
-   */
-  readonly keys: ReadonlyArray<string>;
-
-  /**
-   * The attachment content factory used by the model.
-   */
-  readonly contentFactory: IAttachmentsModel.IContentFactory;
-
-  /**
-   * Whether the specified key is set.
-   */
-  has(key: string): boolean;
-
-  /**
-   * Get an item for the specified key.
-   */
-  get(key: string): IAttachmentModel;
-
-  /**
-   * Set the value of the specified key.
-   */
-  set(key: string, attachment: nbformat.IMimeBundle): void;
-
-  /**
-   * Clear all of the attachments.
-   */
-  clear(): void;
-
-  /**
-   * Deserialize the model from JSON.
-   *
-   * #### Notes
-   * This will clear any existing data.
-   */
-  fromJSON(values: nbformat.IAttachments): void;
-
-  /**
-   * Serialize the model to JSON.
-   */
-  toJSON(): nbformat.IAttachments;
-}
-
-/**
- * The namespace for IAttachmentsModel interfaces.
- */
-export namespace IAttachmentsModel {
-  /**
-   * The options used to create a attachments model.
-   */
-  export interface IOptions {
-    /**
-     * The initial values for the model.
-     */
-    values?: nbformat.IAttachments;
-
-    /**
-     * The attachment content factory used by the model.
-     *
-     * If not given, a default factory will be used.
-     */
-    contentFactory?: IContentFactory;
-
-    /**
-     * An optional IModelDB to store the attachments model.
-     */
-    modelDB?: IModelDB;
-  }
-
-  /**
-   * A type alias for changed args.
-   */
-  export type ChangedArgs = IObservableMap.IChangedArgs<IAttachmentModel>;
-
-  /**
-   * The interface for an attachment content factory.
-   */
-  export interface IContentFactory {
-    /**
-     * Create an attachment model.
-     */
-    createAttachmentModel(options: IAttachmentModel.IOptions): IAttachmentModel;
-  }
-}
-
-/**
- * The default implementation of the IAttachmentsModel.
- */
-export class AttachmentsModel implements IAttachmentsModel {
-  /**
-   * Construct a new observable outputs instance.
-   */
-  constructor(options: IAttachmentsModel.IOptions = {}) {
-    this.contentFactory =
-      options.contentFactory || AttachmentsModel.defaultContentFactory;
-    if (options.values) {
-      for (let key of Object.keys(options.values)) {
-        this.set(key, options.values[key]);
-      }
-    }
-    this._map.changed.connect(this._onMapChanged, this);
-
-    // If we are given a IModelDB, keep an up-to-date
-    // serialized copy of the AttachmentsModel in it.
-    if (options.modelDB) {
-      this._modelDB = options.modelDB;
-      this._serialized = this._modelDB.createValue('attachments');
-      if (this._serialized.get()) {
-        this.fromJSON(this._serialized.get() as nbformat.IAttachments);
-      } else {
-        this._serialized.set(this.toJSON());
-      }
-      this._serialized.changed.connect(this._onSerializedChanged, this);
-    }
-  }
-
-  /**
-   * A signal emitted when the model state changes.
-   */
-  get stateChanged(): ISignal<IAttachmentsModel, void> {
-    return this._stateChanged;
-  }
-
-  /**
-   * A signal emitted when the model changes.
-   */
-  get changed(): ISignal<this, IAttachmentsModel.ChangedArgs> {
-    return this._changed;
-  }
-
-  /**
-   * The keys of the attachments in the model.
-   */
-  get keys(): ReadonlyArray<string> {
-    return this._map.keys();
-  }
-
-  /**
-   * Get the length of the items in the model.
-   */
-  get length(): number {
-    return this._map.keys().length;
-  }
-
-  /**
-   * The attachment content factory used by the model.
-   */
-  readonly contentFactory: IAttachmentsModel.IContentFactory;
-
-  /**
-   * Test whether the model is disposed.
-   */
-  get isDisposed(): boolean {
-    return this._isDisposed;
-  }
-
-  /**
-   * Dispose of the resources used by the model.
-   */
-  dispose(): void {
-    if (this.isDisposed) {
-      return;
-    }
-    this._isDisposed = true;
-    this._map.dispose();
-    Signal.clearData(this);
-  }
-
-  /**
-   * Whether the specified key is set.
-   */
-  has(key: string): boolean {
-    return this._map.has(key);
-  }
-
-  /**
-   * Get an item at the specified key.
-   */
-  get(key: string): IAttachmentModel {
-    return this._map.get(key);
-  }
-
-  /**
-   * Set the value at the specified key.
-   */
-  set(key: string, value: nbformat.IMimeBundle): void {
-    // Normalize stream data.
-    let item = this._createItem({ value });
-    this._map.set(key, item);
-  }
-
-  /**
-   * Clear all of the attachments.
-   */
-  clear(): void {
-    this._map.values().forEach((item: IAttachmentModel) => {
-      item.dispose();
-    });
-    this._map.clear();
-  }
-
-  /**
-   * Deserialize the model from JSON.
-   *
-   * #### Notes
-   * This will clear any existing data.
-   */
-  fromJSON(values: nbformat.IAttachments) {
-    this.clear();
-    Object.keys(values).forEach(key => {
-      this.set(key, values[key]);
-    });
-  }
-
-  /**
-   * Serialize the model to JSON.
-   */
-  toJSON(): nbformat.IAttachments {
-    let ret: nbformat.IAttachments = {};
-    for (let key of this._map.keys()) {
-      ret[key] = this._map.get(key).toJSON();
-    }
-    return ret;
-  }
-
-  /**
-   * Create an attachment item and hook up its signals.
-   */
-  private _createItem(options: IAttachmentModel.IOptions): IAttachmentModel {
-    let factory = this.contentFactory;
-    let item = factory.createAttachmentModel(options);
-    item.changed.connect(this._onGenericChange, this);
-    return item;
-  }
-
-  /**
-   * Handle a change to the list.
-   */
-  private _onMapChanged(
-    sender: IObservableMap<IAttachmentModel>,
-    args: IObservableMap.IChangedArgs<IAttachmentModel>
-  ) {
-    if (this._serialized && !this._changeGuard) {
-      this._changeGuard = true;
-      this._serialized.set(this.toJSON());
-      this._changeGuard = false;
-    }
-    this._changed.emit(args);
-    this._stateChanged.emit(void 0);
-  }
-
-  /**
-   * If the serialized version of the outputs have changed due to a remote
-   * action, then update the model accordingly.
-   */
-  private _onSerializedChanged(
-    sender: IObservableValue,
-    args: ObservableValue.IChangedArgs
-  ) {
-    if (!this._changeGuard) {
-      this._changeGuard = true;
-      this.fromJSON(args.newValue as nbformat.IAttachments);
-      this._changeGuard = false;
-    }
-  }
-
-  /**
-   * Handle a change to an item.
-   */
-  private _onGenericChange(): void {
-    this._stateChanged.emit(void 0);
-  }
-
-  private _map = new ObservableMap<IAttachmentModel>();
-  private _isDisposed = false;
-  private _stateChanged = new Signal<IAttachmentsModel, void>(this);
-  private _changed = new Signal<this, IAttachmentsModel.ChangedArgs>(this);
-  private _modelDB: IModelDB = null;
-  private _serialized: IObservableValue = null;
-  private _changeGuard = false;
-}
-
-/**
- * The namespace for AttachmentsModel class statics.
- */
-export namespace AttachmentsModel {
-  /**
-   * The default implementation of a `IAttachemntsModel.IContentFactory`.
-   */
-  export class ContentFactory implements IAttachmentsModel.IContentFactory {
-    /**
-     * Create an attachment model.
-     */
-    createAttachmentModel(
-      options: IAttachmentModel.IOptions
-    ): IAttachmentModel {
-      return new AttachmentModel(options);
-    }
-  }
-
-  /**
-   * The default attachment model factory.
-   */
-  export const defaultContentFactory = new ContentFactory();
-}
-
-/**
- * A resolver for cell attachments 'attchment:filename'.
- *
- * Will resolve to a data: url.
- */
-export class AttachmentsResolver implements IRenderMime.IResolver {
-  /**
-   * Create an attachments resolver object.
-   */
-  constructor(options: AttachmentsResolver.IOptions) {
-    this._parent = options.parent || null;
-    this._model = options.model;
-  }
-  /**
-   * Resolve a relative url to a correct server path.
-   */
-  resolveUrl(url: string): Promise<string> {
-    if (this._parent && !url.startsWith('attachment:')) {
-      return this._parent.resolveUrl(url);
-    }
-    return Promise.resolve(url);
-  }
-
-  /**
-   * Get the download url of a given absolute server path.
-   */
-  getDownloadUrl(path: string): Promise<string> {
-    if (this._parent && !path.startsWith('attachment:')) {
-      return this._parent.getDownloadUrl(path);
-    }
-    // Return a data URL with the data of the url
-    const key = path.slice('attachment:'.length);
-    if (!this._model.has(key)) {
-      // Resolve with unprocessed path, to show as broken image
-      return Promise.resolve(path);
-    }
-    const { data } = this._model.get(key);
-    const mimeType = Object.keys(data)[0];
-    // Only support known safe types:
-    if (imageRendererFactory.mimeTypes.indexOf(mimeType) === -1) {
-      return Promise.reject(
-        `Cannot render unknown image mime type "${mimeType}".`
-      );
-    }
-    const dataUrl = `data:${mimeType};base64,${data[mimeType]}`;
-    return Promise.resolve(dataUrl);
-  }
-
-  /**
-   * Whether the URL should be handled by the resolver
-   * or not.
-   */
-  isLocal(url: string): boolean {
-    if (this._parent && !url.startsWith('attachment:')) {
-      return this._parent.isLocal(url);
-    }
-    return true;
-  }
-
-  private _model: IAttachmentsModel;
-  private _parent: IRenderMime.IResolver | null;
-}
-
-/**
- * The namespace for `AttachmentsResolver` class statics.
- */
-export namespace AttachmentsResolver {
-  /**
-   * The options used to create an AttachmentsResolver.
-   */
-  export interface IOptions {
-    /**
-     * The attachments model to resolve against.
-     */
-    model: IAttachmentsModel;
-
-    /**
-     * A parent resolver to use if the URL/path is not for an attachment.
-     */
-    parent?: IRenderMime.IResolver;
-  }
-}
diff --git a/packages/attachments/tsconfig.json b/packages/attachments/tsconfig.json
index 0738f0d99ad..153d08f9611 100644
--- a/packages/attachments/tsconfig.json
+++ b/packages/attachments/tsconfig.json
@@ -10,7 +10,7 @@
       "path": "../coreutils"
     },
     {
-      "path": "../observables"
+      "path": "../datastore"
     },
     {
       "path": "../rendermime"
diff --git a/packages/cells/package.json b/packages/cells/package.json
index 3eca7dd4345..49176c4b9be 100644
--- a/packages/cells/package.json
+++ b/packages/cells/package.json
@@ -40,14 +40,15 @@
     "@jupyterlab/codeeditor": "^1.0.0",
     "@jupyterlab/codemirror": "^1.0.1",
     "@jupyterlab/coreutils": "^3.0.0",
-    "@jupyterlab/observables": "^2.2.0",
+    "@jupyterlab/datastore": "^1.0.0",
     "@jupyterlab/outputarea": "^1.0.1",
     "@jupyterlab/rendermime": "^1.0.1",
     "@jupyterlab/services": "^4.0.1",
     "@phosphor/algorithm": "^1.1.3",
     "@phosphor/coreutils": "^1.3.1",
+    "@phosphor/datastore": "0.7.2",
+    "@phosphor/disposable": "^1.2.0",
     "@phosphor/messaging": "^1.2.3",
-    "@phosphor/signaling": "^1.2.3",
     "@phosphor/virtualdom": "^1.1.3",
     "@phosphor/widgets": "^1.8.0",
     "react": "~16.8.4"
diff --git a/packages/cells/src/celldragutils.ts b/packages/cells/src/celldragutils.ts
index d67bd588df2..0fb7b103ef9 100644
--- a/packages/cells/src/celldragutils.ts
+++ b/packages/cells/src/celldragutils.ts
@@ -9,11 +9,15 @@
  * Notebook widgets.
  */
 
+import { nbformat } from '@jupyterlab/coreutils';
+
+import { DatastoreExt } from '@jupyterlab/datastore';
+
 import { each, IterableOrArrayLike } from '@phosphor/algorithm';
-import { ICodeCellModel } from './model';
-import { Cell } from './widget';
+
 import { h, VirtualDOM } from '@phosphor/virtualdom';
-import { nbformat } from '@jupyterlab/coreutils';
+
+import { Cell } from './widget';
 
 /**
  * Constants for drag
@@ -142,8 +146,12 @@ export namespace CellDragUtils {
   ): HTMLElement {
     const count = selectedCells.length;
     let promptNumber: string;
-    if (activeCell.model.type === 'code') {
-      let executionCount = (activeCell.model as ICodeCellModel).executionCount;
+    const cellData = DatastoreExt.getRecord(
+      activeCell.data.datastore,
+      activeCell.data.record
+    );
+    if (cellData.type === 'code') {
+      let executionCount = cellData.executionCount;
       promptNumber = ' ';
       if (executionCount) {
         promptNumber = executionCount.toString();
@@ -152,7 +160,7 @@ export namespace CellDragUtils {
       promptNumber = '';
     }
 
-    const cellContent = activeCell.model.value.text.split('\n')[0].slice(0, 26);
+    const cellContent = cellData.text.split('\n')[0].slice(0, 26);
     if (count > 1) {
       if (promptNumber !== '') {
         return VirtualDOM.realize(
diff --git a/packages/cells/src/data.ts b/packages/cells/src/data.ts
new file mode 100644
index 00000000000..0b56b86f45d
--- /dev/null
+++ b/packages/cells/src/data.ts
@@ -0,0 +1,434 @@
+/*-----------------------------------------------------------------------------
+| Copyright (c) Jupyter Development Team.
+| Distributed under the terms of the Modified BSD License.
+|----------------------------------------------------------------------------*/
+
+import { AttachmentsData, IAttachmentsData } from '@jupyterlab/attachments';
+
+import {
+  CodeEditor,
+  CodeEditorData,
+  ICodeEditorData
+} from '@jupyterlab/codeeditor';
+
+import { nbformat } from '@jupyterlab/coreutils';
+
+import { DatastoreExt } from '@jupyterlab/datastore';
+
+import { OutputAreaData } from '@jupyterlab/outputarea';
+
+import { IOutputData, OutputData } from '@jupyterlab/rendermime';
+
+import { JSONExt, JSONObject, ReadonlyJSONValue } from '@phosphor/coreutils';
+
+import {
+  Datastore,
+  Fields,
+  ListField,
+  MapField,
+  RegisterField
+} from '@phosphor/datastore';
+
+/**
+ * The namespace for `ICellData` interfaces, describing
+ * where cells store their data in a datastore.
+ */
+export namespace ICellData {
+  /**
+   * An interface for a cell schema.
+   */
+  export type BaseSchema = {
+    /**
+     * The id for the schema.
+     */
+    id: string;
+
+    fields: ICodeEditorData.Schema['fields'] & {
+      /**
+       * The type of the cell.
+       */
+      type: RegisterField<nbformat.CellType>;
+
+      /**
+       * Whether the cell is trusted.
+       */
+      trusted: RegisterField<boolean>;
+
+      /**
+       * The metadata for the cell.
+       */
+      metadata: MapField<ReadonlyJSONValue>;
+    };
+  };
+
+  /**
+   * An interface for a cell schema.
+   */
+  export type Schema = {
+    /**
+     * The id for the schema.
+     */
+    id: string;
+
+    /**
+     * The union of cell fields.
+     */
+    fields: BaseSchema['fields'] &
+      ICodeCellData.Schema['fields'] &
+      IAttachmentsCellData.Schema['fields'];
+  };
+
+  /**
+   * The location of cell data in a datastore.
+   */
+  export type DataLocation = DatastoreExt.DataLocation & {
+    /**
+     * The record for the cell data.
+     */
+    record: DatastoreExt.RecordLocation<Schema>;
+
+    /**
+     * A table in which outputs are stored.
+     */
+    outputs: DatastoreExt.TableLocation<IOutputData.Schema>;
+  };
+}
+
+/**
+ * The namespace for `IAttachmentsCellData` interfaces.
+ */
+export namespace IAttachmentsCellData {
+  /**
+   * A type alias for an attachment cell schema, which includes the fields for
+   * a base cell, plus possible attachment data.
+   */
+  export type Schema = {
+    /**
+     * The id for the schema.
+     */
+    id: string;
+
+    /**
+     * The union of cell fields.
+     */
+    fields: ICellData.BaseSchema['fields'] & IAttachmentsData.Schema['fields'];
+  };
+}
+
+/**
+ * The namespace for `ICodeCellData` statics.
+ */
+export namespace ICodeCellData {
+  /**
+   * A type alias for a code cell data schema, which includes the fields of a base
+   * cell, plus data for execution count and outputs.
+   */
+  export type Schema = {
+    /**
+     * The id for the schema.
+     */
+    id: string;
+
+    /**
+     * The union of cell fields.
+     */
+    fields: ICellData.BaseSchema['fields'] & {
+      /**
+       * Execution count for the cell.
+       */
+      executionCount: RegisterField<nbformat.ExecutionCount>;
+
+      /**
+       * A list of output ids for the cell.
+       */
+      outputs: ListField<string>;
+    };
+  };
+}
+
+/**
+ * Utility functions for operating on cell data.
+ */
+export namespace CellData {
+  /**
+   * A concrete schema for a cell table, available at runtime.
+   */
+  export const SCHEMA: ICellData.Schema = {
+    /**
+     * The id for the schema.
+     */
+    id: '@jupyterlab/cells:cellmodel.v1',
+
+    /**
+     * The union of cell fields.
+     */
+    fields: {
+      attachments: Fields.Map<nbformat.IMimeBundle>(),
+      executionCount: Fields.Register<nbformat.ExecutionCount>({ value: null }),
+      metadata: Fields.Map<ReadonlyJSONValue>(),
+      mimeType: Fields.String(),
+      outputs: Fields.List<string>(),
+      selections: Fields.Map<CodeEditor.ITextSelection[]>(),
+      text: Fields.Text(),
+      trusted: Fields.Boolean(),
+      type: Fields.Register<nbformat.CellType>({ value: 'code' })
+    }
+  };
+
+  /**
+   * Create an in-memory datastore capable of holding the data for an output area.
+   */
+  export function createStore(id: number = 1): Datastore {
+    return Datastore.create({
+      id,
+      schemas: [SCHEMA, OutputData.SCHEMA]
+    });
+  }
+
+  /**
+   * Construct a cell model from optional cell content.
+   */
+  export function fromJSON(
+    loc: ICellData.DataLocation,
+    cell?: nbformat.IBaseCell
+  ) {
+    // Get the intitial data for the model.
+    let trusted = false;
+    let metadata: JSONObject = {};
+    let text = '';
+    let type: nbformat.CellType = 'code';
+    if (cell) {
+      metadata = JSONExt.deepCopy(cell.metadata);
+      trusted = !!metadata['trusted'];
+      delete metadata['trusted'];
+
+      if (cell.cell_type !== 'raw') {
+        delete metadata['format'];
+      }
+      if (cell.cell_type !== 'code') {
+        delete metadata['collapsed'];
+        delete metadata['scrolled'];
+      }
+
+      if (Array.isArray(cell.source)) {
+        text = (cell.source as string[]).join('');
+      } else {
+        text = (cell.source as string) || '';
+      }
+
+      type = cell.cell_type as nbformat.CellType;
+    }
+    // Set the intitial data for the model.
+    let { datastore, record } = loc;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateRecord(datastore, record, {
+        type,
+        metadata,
+        trusted,
+        text: { index: 0, remove: 0, text }
+      });
+    });
+  }
+
+  /**
+   * Convert a cell at a given data location to JSON.
+   * This delegates to specific versions of `toJSON` based
+   * on the cell type.
+   */
+  export function toJSON(loc: ICellData.DataLocation): nbformat.ICell {
+    let data = DatastoreExt.getRecord(loc.datastore, loc.record);
+    switch (data.type) {
+      case 'code':
+        return CodeCellData.toJSON(loc);
+        break;
+      case 'markdown':
+        return MarkdownCellData.toJSON(loc);
+        break;
+      default:
+        return RawCellData.toJSON(loc);
+    }
+  }
+
+  /*
+   * Clear a cell data. The record is not actually removed, but its data
+   * is emptied as much as possible to allow it to garbage collect.
+   */
+  export function clear(loc: ICellData.DataLocation): void {
+    let { datastore, record } = loc;
+    let cellData = DatastoreExt.getRecord(loc.datastore, loc.record);
+
+    let attachments: { [x: string]: nbformat.IMimeBundle | null } = {};
+    Object.keys(cellData.attachments).forEach(key => (attachments[key] = null));
+    let metadata: { [x: string]: ReadonlyJSONValue | null } = {};
+    Object.keys(cellData.metadata).forEach(key => (metadata[key] = null));
+
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateRecord(datastore, record, {
+        attachments,
+        metadata,
+        executionCount: null,
+        type: 'code',
+        trusted: false,
+        outputs: { index: 0, remove: cellData.outputs.length, values: [] }
+      });
+      OutputAreaData.clear(loc);
+      CodeEditorData.clear(loc);
+    });
+  }
+}
+
+/**
+ * The namespace for `AttachmentsCellData` statics.
+ */
+export namespace AttachmentsCellData {
+  /**
+   * Construct a new cell with optional attachments.
+   */
+  export function fromJSON(
+    loc: ICellData.DataLocation,
+    cell?: nbformat.IMarkdownCell | nbformat.IRawCell
+  ): void {
+    CellData.fromJSON(loc, cell);
+    const attachments = (cell && cell.attachments) || {};
+    AttachmentsData.fromJSON(loc, attachments);
+  }
+
+  /**
+   * Serialize the model to JSON.
+   */
+  export function toJSON(
+    loc: ICellData.DataLocation
+  ): nbformat.IRawCell | nbformat.IMarkdownCell {
+    const cell = Private.baseToJSON(loc) as
+      | nbformat.IRawCell
+      | nbformat.IMarkdownCell;
+    const attachments = AttachmentsData.toJSON(loc);
+    if (Object.keys(attachments).length) {
+      cell.attachments = attachments;
+    }
+    return cell;
+  }
+}
+
+/**
+ * Utility functions for working with RawCellData.
+ */
+export namespace RawCellData {
+  /**
+   * Construct a new cell with optional attachments.
+   */
+  export function fromJSON(
+    loc: ICellData.DataLocation,
+    cell?: nbformat.IRawCell
+  ): void {
+    const { datastore, record } = loc;
+    DatastoreExt.withTransaction(datastore, () => {
+      AttachmentsCellData.fromJSON(loc, cell);
+      DatastoreExt.updateRecord(datastore, record, {
+        type: 'raw'
+      });
+    });
+  }
+
+  /**
+   * Serialize the model to JSON.
+   */
+  export function toJSON(loc: ICellData.DataLocation): nbformat.IRawCell {
+    return AttachmentsCellData.toJSON(loc) as nbformat.IRawCell;
+  }
+}
+
+/**
+ * Utility functions for working with MarkdownCellData.
+ */
+export namespace MarkdownCellData {
+  /**
+   * Construct a new cell with optional attachments.
+   */
+  export function fromJSON(
+    loc: ICellData.DataLocation,
+    cell?: nbformat.IMarkdownCell
+  ): void {
+    const { datastore, record } = loc;
+    DatastoreExt.withTransaction(datastore, () => {
+      AttachmentsCellData.fromJSON(loc, cell);
+      DatastoreExt.updateRecord(datastore, record, {
+        mimeType: 'text/x-ipythongfm',
+        type: 'markdown'
+      });
+    });
+  }
+
+  /**
+   * Serialize the model to JSON.
+   */
+  export function toJSON(loc: ICellData.DataLocation): nbformat.IMarkdownCell {
+    return AttachmentsCellData.toJSON(loc) as nbformat.IMarkdownCell;
+  }
+}
+
+/**
+ * The namespace for `CodeCellData` statics.
+ */
+export namespace CodeCellData {
+  /**
+   * Construct a new code cell with optional original cell content.
+   */
+  export function fromJSON(
+    loc: ICellData.DataLocation,
+    cell?: nbformat.ICodeCell
+  ) {
+    const { datastore, record } = loc;
+    DatastoreExt.withTransaction(datastore, () => {
+      CellData.fromJSON(loc, cell);
+      DatastoreExt.updateRecord(datastore, record, {
+        executionCount: cell ? cell.execution_count || null : null,
+        type: 'code'
+      });
+      let outputs: nbformat.IOutput[] = (cell && cell.outputs) || [];
+      OutputAreaData.fromJSON(loc, outputs);
+    });
+  }
+
+  /**
+   * Serialize the model to JSON.
+   */
+  export function toJSON(loc: ICellData.DataLocation): nbformat.ICodeCell {
+    let cell = Private.baseToJSON(loc) as nbformat.ICodeCell;
+    const { datastore, record } = loc;
+    cell.execution_count = DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'executionCount'
+    });
+    cell.outputs = OutputAreaData.toJSON(loc);
+    return cell;
+  }
+}
+
+/**
+ * A namespace for module-private functionality.
+ */
+namespace Private {
+  /**
+   * Serialize the model to JSON.
+   *
+   * ### Notes
+   * This is the common serialization logic for the three cell types,
+   * and is called by the specializations of the cell types.
+   * The `toJSON` function in this namespace correctly delegates
+   * to the different subtypes.
+   */
+  export function baseToJSON(loc: ICellData.DataLocation): nbformat.ICell {
+    const { datastore, record } = loc;
+    let data = DatastoreExt.getRecord(datastore, record);
+    let metadata = data.metadata as JSONObject;
+    if (data.trusted) {
+      metadata['trusted'] = true;
+    }
+    return {
+      cell_type: data.type,
+      source: data.text,
+      metadata
+    } as nbformat.ICell;
+  }
+}
diff --git a/packages/cells/src/index.ts b/packages/cells/src/index.ts
index 39967bf3c55..e49bcd3f160 100644
--- a/packages/cells/src/index.ts
+++ b/packages/cells/src/index.ts
@@ -7,6 +7,6 @@ export * from './celldragutils';
 export * from './collapser';
 export * from './headerfooter';
 export * from './inputarea';
-export * from './model';
+export * from './data';
 export * from './placeholder';
 export * from './widget';
diff --git a/packages/cells/src/inputarea.ts b/packages/cells/src/inputarea.ts
index ecbf82225d9..b614b57ef70 100644
--- a/packages/cells/src/inputarea.ts
+++ b/packages/cells/src/inputarea.ts
@@ -11,7 +11,7 @@ import { CodeEditor, CodeEditorWrapper } from '@jupyterlab/codeeditor';
 
 import { CodeMirrorEditorFactory } from '@jupyterlab/codemirror';
 
-import { ICellModel } from './model';
+import { ICellData } from './data';
 
 /**
  * The class name added to input area widgets.
@@ -47,7 +47,7 @@ export class InputArea extends Widget {
   constructor(options: InputArea.IOptions) {
     super();
     this.addClass(INPUT_AREA_CLASS);
-    let model = (this.model = options.model);
+    let data = (this.data = options.data);
     let contentFactory = (this.contentFactory =
       options.contentFactory || InputArea.defaultContentFactory);
 
@@ -56,8 +56,9 @@ export class InputArea extends Widget {
     prompt.addClass(INPUT_AREA_PROMPT_CLASS);
 
     // Editor
+    let editorModel = new CodeEditor.Model({ data });
     let editorOptions = {
-      model,
+      model: editorModel,
       factory: contentFactory.editorFactory,
       updateOnShow: options.updateOnShow
     };
@@ -72,7 +73,7 @@ export class InputArea extends Widget {
   /**
    * The model used by the widget.
    */
-  readonly model: ICellModel;
+  readonly data: ICellData.DataLocation;
 
   /**
    * The content factory used by the widget.
@@ -160,7 +161,7 @@ export namespace InputArea {
     /**
      * The model used by the widget.
      */
-    model: ICellModel;
+    data: ICellData.DataLocation;
 
     /**
      * The content factory used by the widget to create children.
diff --git a/packages/cells/src/model.ts b/packages/cells/src/model.ts
deleted file mode 100644
index 14808559191..00000000000
--- a/packages/cells/src/model.ts
+++ /dev/null
@@ -1,658 +0,0 @@
-/*-----------------------------------------------------------------------------
-| Copyright (c) Jupyter Development Team.
-| Distributed under the terms of the Modified BSD License.
-|----------------------------------------------------------------------------*/
-
-import { JSONExt, JSONObject, JSONValue } from '@phosphor/coreutils';
-
-import { ISignal, Signal } from '@phosphor/signaling';
-
-import { IAttachmentsModel, AttachmentsModel } from '@jupyterlab/attachments';
-
-import { CodeEditor } from '@jupyterlab/codeeditor';
-
-import { IChangedArgs, nbformat } from '@jupyterlab/coreutils';
-
-import { UUID } from '@phosphor/coreutils';
-
-import {
-  IObservableJSON,
-  IModelDB,
-  IObservableValue,
-  ObservableValue,
-  IObservableMap
-} from '@jupyterlab/observables';
-
-import { IOutputAreaModel, OutputAreaModel } from '@jupyterlab/outputarea';
-
-/**
- * The definition of a model object for a cell.
- */
-export interface ICellModel extends CodeEditor.IModel {
-  /**
-   * The type of the cell.
-   */
-  readonly type: nbformat.CellType;
-
-  /**
-   * A unique identifier for the cell.
-   */
-  readonly id: string;
-
-  /**
-   * A signal emitted when the content of the model changes.
-   */
-  readonly contentChanged: ISignal<ICellModel, void>;
-
-  /**
-   * A signal emitted when a model state changes.
-   */
-  readonly stateChanged: ISignal<ICellModel, IChangedArgs<any>>;
-
-  /**
-   * Whether the cell is trusted.
-   */
-  trusted: boolean;
-
-  /**
-   * The metadata associated with the cell.
-   */
-  readonly metadata: IObservableJSON;
-
-  /**
-   * Serialize the model to JSON.
-   */
-  toJSON(): nbformat.ICell;
-}
-
-/**
- * The definition of a model cell object for a cell with attachments.
- */
-export interface IAttachmentsCellModel extends ICellModel {
-  /**
-   * The cell attachments
-   */
-  readonly attachments: IAttachmentsModel;
-}
-
-/**
- * The definition of a code cell.
- */
-export interface ICodeCellModel extends ICellModel {
-  /**
-   * The type of the cell.
-   *
-   * #### Notes
-   * This is a read-only property.
-   */
-  readonly type: 'code';
-
-  /**
-   * Serialize the model to JSON.
-   */
-  toJSON(): nbformat.ICodeCell;
-
-  /**
-   * The code cell's prompt number. Will be null if the cell has not been run.
-   */
-  executionCount: nbformat.ExecutionCount;
-
-  /**
-   * The cell outputs.
-   */
-  readonly outputs: IOutputAreaModel;
-}
-
-/**
- * The definition of a markdown cell.
- */
-export interface IMarkdownCellModel extends IAttachmentsCellModel {
-  /**
-   * The type of the cell.
-   */
-  readonly type: 'markdown';
-
-  /**
-   * Serialize the model to JSON.
-   */
-  toJSON(): nbformat.IMarkdownCell;
-}
-
-/**
- * The definition of a raw cell.
- */
-export interface IRawCellModel extends IAttachmentsCellModel {
-  /**
-   * The type of the cell.
-   */
-  readonly type: 'raw';
-
-  /**
-   * Serialize the model to JSON.
-   */
-  toJSON(): nbformat.IRawCell;
-}
-
-export function isCodeCellModel(model: ICellModel): model is ICodeCellModel {
-  return model.type === 'code';
-}
-
-export function isMarkdownCellModel(
-  model: ICellModel
-): model is IMarkdownCellModel {
-  return model.type === 'markdown';
-}
-
-export function isRawCellModel(model: ICellModel): model is IRawCellModel {
-  return model.type === 'raw';
-}
-
-/**
- * An implementation of the cell model.
- */
-export class CellModel extends CodeEditor.Model implements ICellModel {
-  /**
-   * Construct a cell model from optional cell content.
-   */
-  constructor(options: CellModel.IOptions) {
-    super({ modelDB: options.modelDB });
-
-    this.id = options.id || UUID.uuid4();
-
-    this.value.changed.connect(this.onGenericChange, this);
-
-    let cellType = this.modelDB.createValue('type');
-    cellType.set(this.type);
-
-    let observableMetadata = this.modelDB.createMap('metadata');
-    observableMetadata.changed.connect(this.onGenericChange, this);
-
-    let cell = options.cell;
-    let trusted = this.modelDB.createValue('trusted');
-    trusted.changed.connect(this.onTrustedChanged, this);
-
-    if (!cell) {
-      trusted.set(false);
-      return;
-    }
-    trusted.set(!!cell.metadata['trusted']);
-    delete cell.metadata['trusted'];
-
-    if (Array.isArray(cell.source)) {
-      this.value.text = (cell.source as string[]).join('');
-    } else {
-      this.value.text = cell.source as string;
-    }
-    let metadata = JSONExt.deepCopy(cell.metadata);
-    if (this.type !== 'raw') {
-      delete metadata['format'];
-    }
-    if (this.type !== 'code') {
-      delete metadata['collapsed'];
-      delete metadata['scrolled'];
-    }
-
-    for (let key in metadata) {
-      observableMetadata.set(key, metadata[key]);
-    }
-  }
-
-  /**
-   * The type of cell.
-   */
-  readonly type: nbformat.CellType;
-
-  /**
-   * A signal emitted when the state of the model changes.
-   */
-  readonly contentChanged = new Signal<this, void>(this);
-
-  /**
-   * A signal emitted when a model state changes.
-   */
-  readonly stateChanged = new Signal<this, IChangedArgs<any>>(this);
-
-  /**
-   * The id for the cell.
-   */
-  readonly id: string;
-
-  /**
-   * The metadata associated with the cell.
-   */
-  get metadata(): IObservableJSON {
-    return this.modelDB.get('metadata') as IObservableJSON;
-  }
-
-  /**
-   * Get the trusted state of the model.
-   */
-  get trusted(): boolean {
-    return this.modelDB.getValue('trusted') as boolean;
-  }
-
-  /**
-   * Set the trusted state of the model.
-   */
-  set trusted(newValue: boolean) {
-    let oldValue = this.trusted;
-    if (oldValue === newValue) {
-      return;
-    }
-    this.modelDB.setValue('trusted', newValue);
-  }
-
-  /**
-   * Serialize the model to JSON.
-   */
-  toJSON(): nbformat.ICell {
-    let metadata: nbformat.IBaseCellMetadata = Object.create(null);
-    for (let key of this.metadata.keys()) {
-      let value = JSON.parse(JSON.stringify(this.metadata.get(key)));
-      metadata[key] = value as JSONValue;
-    }
-    if (this.trusted) {
-      metadata['trusted'] = true;
-    }
-    return {
-      cell_type: this.type,
-      source: this.value.text,
-      metadata
-    } as nbformat.ICell;
-  }
-
-  /**
-   * Handle a change to the trusted state.
-   *
-   * The default implementation is a no-op.
-   */
-  onTrustedChanged(
-    trusted: IObservableValue,
-    args: ObservableValue.IChangedArgs
-  ): void {
-    /* no-op */
-  }
-
-  /**
-   * Handle a change to the observable value.
-   */
-  protected onGenericChange(): void {
-    this.contentChanged.emit(void 0);
-  }
-}
-
-/**
- * The namespace for `CellModel` statics.
- */
-export namespace CellModel {
-  /**
-   * The options used to initialize a `CellModel`.
-   */
-  export interface IOptions {
-    /**
-     * The source cell data.
-     */
-    cell?: nbformat.IBaseCell;
-
-    /**
-     * An IModelDB in which to store cell data.
-     */
-    modelDB?: IModelDB;
-
-    /**
-     * A unique identifier for this cell.
-     */
-    id?: string;
-  }
-}
-
-/**
- * A base implementation for cell models with attachments.
- */
-export class AttachmentsCellModel extends CellModel {
-  /**
-   * Construct a new cell with optional attachments.
-   */
-  constructor(options: AttachmentsCellModel.IOptions) {
-    super(options);
-    let factory =
-      options.contentFactory || AttachmentsCellModel.defaultContentFactory;
-    let attachments: nbformat.IAttachments | undefined;
-    let cell = options.cell;
-    if (cell && (cell.cell_type === 'raw' || cell.cell_type === 'markdown')) {
-      attachments = (cell as nbformat.IRawCell | nbformat.IMarkdownCell)
-        .attachments;
-    }
-
-    this._attachments = factory.createAttachmentsModel({
-      values: attachments,
-      modelDB: this.modelDB
-    });
-    this._attachments.stateChanged.connect(this.onGenericChange, this);
-  }
-
-  /**
-   * Get the attachments of the model.
-   */
-  get attachments(): IAttachmentsModel {
-    return this._attachments;
-  }
-
-  /**
-   * Serialize the model to JSON.
-   */
-  toJSON(): nbformat.IRawCell | nbformat.IMarkdownCell {
-    let cell = super.toJSON() as nbformat.IRawCell | nbformat.IMarkdownCell;
-    if (this.attachments.length) {
-      cell.attachments = this.attachments.toJSON();
-    }
-    return cell;
-  }
-
-  private _attachments: IAttachmentsModel | null = null;
-}
-
-/**
- * The namespace for `AttachmentsCellModel` statics.
- */
-export namespace AttachmentsCellModel {
-  /**
-   * The options used to initialize a `AttachmentsCellModel`.
-   */
-  export interface IOptions extends CellModel.IOptions {
-    /**
-     * The factory for attachment model creation.
-     */
-    contentFactory?: IContentFactory;
-  }
-
-  /**
-   * A factory for creating code cell model content.
-   */
-  export interface IContentFactory {
-    /**
-     * Create an output area.
-     */
-    createAttachmentsModel(
-      options: IAttachmentsModel.IOptions
-    ): IAttachmentsModel;
-  }
-
-  /**
-   * The default implementation of an `IContentFactory`.
-   */
-  export class ContentFactory implements IContentFactory {
-    /**
-     * Create an attachments model.
-     */
-    createAttachmentsModel(
-      options: IAttachmentsModel.IOptions
-    ): IAttachmentsModel {
-      return new AttachmentsModel(options);
-    }
-  }
-
-  /**
-   * The shared `ContentFactory` instance.
-   */
-  export const defaultContentFactory = new ContentFactory();
-}
-
-/**
- * An implementation of a raw cell model.
- */
-export class RawCellModel extends AttachmentsCellModel {
-  /**
-   * The type of the cell.
-   */
-  get type(): 'raw' {
-    return 'raw';
-  }
-
-  /**
-   * Serialize the model to JSON.
-   */
-  toJSON(): nbformat.IRawCell {
-    return super.toJSON() as nbformat.IRawCell;
-  }
-}
-
-/**
- * An implementation of a markdown cell model.
- */
-export class MarkdownCellModel extends AttachmentsCellModel {
-  /**
-   * Construct a markdown cell model from optional cell content.
-   */
-  constructor(options: CellModel.IOptions) {
-    super(options);
-    // Use the Github-flavored markdown mode.
-    this.mimeType = 'text/x-ipythongfm';
-  }
-
-  /**
-   * The type of the cell.
-   */
-  get type(): 'markdown' {
-    return 'markdown';
-  }
-
-  /**
-   * Serialize the model to JSON.
-   */
-  toJSON(): nbformat.IMarkdownCell {
-    return super.toJSON() as nbformat.IMarkdownCell;
-  }
-}
-
-/**
- * An implementation of a code cell Model.
- */
-export class CodeCellModel extends CellModel implements ICodeCellModel {
-  /**
-   * Construct a new code cell with optional original cell content.
-   */
-  constructor(options: CodeCellModel.IOptions) {
-    super(options);
-    let factory = options.contentFactory || CodeCellModel.defaultContentFactory;
-    let trusted = this.trusted;
-    let cell = options.cell as nbformat.ICodeCell;
-    let outputs: nbformat.IOutput[] = [];
-    let executionCount = this.modelDB.createValue('executionCount');
-    if (!executionCount.get()) {
-      if (cell && cell.cell_type === 'code') {
-        executionCount.set(cell.execution_count || null);
-        outputs = cell.outputs;
-      } else {
-        executionCount.set(null);
-      }
-    }
-    executionCount.changed.connect(this._onExecutionCountChanged, this);
-
-    this._outputs = factory.createOutputArea({ trusted, values: outputs });
-    this._outputs.changed.connect(this.onGenericChange, this);
-
-    // We keep `collapsed` and `jupyter.outputs_hidden` metadata in sync, since
-    // they are redundant in nbformat 4.4. See
-    // https://github.com/jupyter/nbformat/issues/137
-    this.metadata.changed.connect(Private.collapseChanged, this);
-
-    // Sync `collapsed` and `jupyter.outputs_hidden` for the first time, giving
-    // preference to `collapsed`.
-    if (this.metadata.has('collapsed')) {
-      let collapsed = this.metadata.get('collapsed');
-      Private.collapseChanged(this.metadata, {
-        type: 'change',
-        key: 'collapsed',
-        oldValue: collapsed,
-        newValue: collapsed
-      });
-    } else if (this.metadata.has('jupyter')) {
-      let jupyter = this.metadata.get('jupyter') as JSONObject;
-      if (jupyter.hasOwnProperty('outputs_hidden')) {
-        Private.collapseChanged(this.metadata, {
-          type: 'change',
-          key: 'jupyter',
-          oldValue: jupyter,
-          newValue: jupyter
-        });
-      }
-    }
-  }
-
-  /**
-   * The type of the cell.
-   */
-  get type(): 'code' {
-    return 'code';
-  }
-
-  /**
-   * The execution count of the cell.
-   */
-  get executionCount(): nbformat.ExecutionCount {
-    return this.modelDB.getValue('executionCount') as nbformat.ExecutionCount;
-  }
-  set executionCount(newValue: nbformat.ExecutionCount) {
-    let oldValue = this.executionCount;
-    if (newValue === oldValue) {
-      return;
-    }
-    this.modelDB.setValue('executionCount', newValue || null);
-  }
-
-  /**
-   * The cell outputs.
-   */
-  get outputs(): IOutputAreaModel {
-    return this._outputs;
-  }
-
-  /**
-   * Dispose of the resources held by the model.
-   */
-  dispose(): void {
-    if (this.isDisposed) {
-      return;
-    }
-    this._outputs.dispose();
-    this._outputs = null;
-    super.dispose();
-  }
-
-  /**
-   * Serialize the model to JSON.
-   */
-  toJSON(): nbformat.ICodeCell {
-    let cell = super.toJSON() as nbformat.ICodeCell;
-    cell.execution_count = this.executionCount || null;
-    cell.outputs = this.outputs.toJSON();
-    return cell;
-  }
-
-  /**
-   * Handle a change to the trusted state.
-   */
-  onTrustedChanged(
-    trusted: IObservableValue,
-    args: ObservableValue.IChangedArgs
-  ): void {
-    if (this._outputs) {
-      this._outputs.trusted = args.newValue as boolean;
-    }
-    this.stateChanged.emit({
-      name: 'trusted',
-      oldValue: args.oldValue,
-      newValue: args.newValue
-    });
-  }
-
-  /**
-   * Handle a change to the execution count.
-   */
-  private _onExecutionCountChanged(
-    count: IObservableValue,
-    args: ObservableValue.IChangedArgs
-  ): void {
-    this.contentChanged.emit(void 0);
-    this.stateChanged.emit({
-      name: 'executionCount',
-      oldValue: args.oldValue,
-      newValue: args.newValue
-    });
-  }
-
-  private _outputs: IOutputAreaModel = null;
-}
-
-/**
- * The namespace for `CodeCellModel` statics.
- */
-export namespace CodeCellModel {
-  /**
-   * The options used to initialize a `CodeCellModel`.
-   */
-  export interface IOptions extends CellModel.IOptions {
-    /**
-     * The factory for output area model creation.
-     */
-    contentFactory?: IContentFactory;
-  }
-
-  /**
-   * A factory for creating code cell model content.
-   */
-  export interface IContentFactory {
-    /**
-     * Create an output area.
-     */
-    createOutputArea(options: IOutputAreaModel.IOptions): IOutputAreaModel;
-  }
-
-  /**
-   * The default implementation of an `IContentFactory`.
-   */
-  export class ContentFactory implements IContentFactory {
-    /**
-     * Create an output area.
-     */
-    createOutputArea(options: IOutputAreaModel.IOptions): IOutputAreaModel {
-      return new OutputAreaModel(options);
-    }
-  }
-
-  /**
-   * The shared `ContentFactory` instance.
-   */
-  export const defaultContentFactory = new ContentFactory();
-}
-
-namespace Private {
-  export function collapseChanged(
-    metadata: IObservableJSON,
-    args: IObservableMap.IChangedArgs<JSONValue>
-  ) {
-    if (args.key === 'collapsed') {
-      const jupyter = (metadata.get('jupyter') || {}) as JSONObject;
-      const { outputs_hidden, ...newJupyter } = jupyter;
-
-      if (outputs_hidden !== args.newValue) {
-        if (args.newValue !== undefined) {
-          newJupyter['outputs_hidden'] = args.newValue;
-        }
-        if (Object.keys(newJupyter).length === 0) {
-          metadata.delete('jupyter');
-        } else {
-          metadata.set('jupyter', newJupyter);
-        }
-      }
-    } else if (args.key === 'jupyter') {
-      const jupyter = (args.newValue || {}) as JSONObject;
-      if (jupyter.hasOwnProperty('outputs_hidden')) {
-        metadata.set('collapsed', jupyter.outputs_hidden);
-      } else {
-        metadata.delete('collapsed');
-      }
-    }
-  }
-}
diff --git a/packages/cells/src/widget.ts b/packages/cells/src/widget.ts
index b9191cd0402..6d2784b9639 100644
--- a/packages/cells/src/widget.ts
+++ b/packages/cells/src/widget.ts
@@ -3,18 +3,19 @@
 | Distributed under the terms of the Modified BSD License.
 |----------------------------------------------------------------------------*/
 
-import { AttachmentsResolver } from '@jupyterlab/attachments';
-
 import { IClientSession } from '@jupyterlab/apputils';
 
-import { IChangedArgs, ActivityMonitor } from '@jupyterlab/coreutils';
+import { AttachmentsResolver } from '@jupyterlab/attachments';
+
+import { Debouncer, nbformat } from '@jupyterlab/coreutils';
 
 import { CodeEditor, CodeEditorWrapper } from '@jupyterlab/codeeditor';
 
-import { IObservableMap } from '@jupyterlab/observables';
+import { DatastoreExt } from '@jupyterlab/datastore';
 
 import {
   OutputArea,
+  OutputAreaData,
   SimplifiedOutputArea,
   IOutputPrompt,
   OutputPrompt,
@@ -24,13 +25,23 @@ import {
 
 import {
   IRenderMime,
+  IRenderMimeRegistry,
   MimeModel,
-  IRenderMimeRegistry
+  OutputData
 } from '@jupyterlab/rendermime';
 
 import { KernelMessage, Kernel } from '@jupyterlab/services';
 
-import { JSONValue, PromiseDelegate, JSONObject } from '@phosphor/coreutils';
+import {
+  JSONObject,
+  PromiseDelegate,
+  ReadonlyJSONObject,
+  ReadonlyJSONValue
+} from '@phosphor/coreutils';
+
+import { Datastore, MapField, RegisterField } from '@phosphor/datastore';
+
+import { IDisposable } from '@phosphor/disposable';
 
 import { Message } from '@phosphor/messaging';
 
@@ -47,12 +58,7 @@ import {
 
 import { InputArea, IInputPrompt, InputPrompt } from './inputarea';
 
-import {
-  ICellModel,
-  ICodeCellModel,
-  IMarkdownCellModel,
-  IRawCellModel
-} from './model';
+import { ICellData, CellData } from './data';
 
 import { InputPlaceholder, OutputPlaceholder } from './placeholder';
 
@@ -157,7 +163,22 @@ export class Cell extends Widget {
   constructor(options: Cell.IOptions) {
     super();
     this.addClass(CELL_CLASS);
-    let model = (this._model = options.model);
+    let data: ICellData.DataLocation;
+    if (options.data) {
+      data = this._data = options.data;
+    } else {
+      const datastore = (this._datastore = CellData.createStore());
+      data = this._data = {
+        datastore,
+        record: {
+          schema: CellData.SCHEMA,
+          record: 'data'
+        },
+        outputs: {
+          schema: OutputData.SCHEMA
+        }
+      };
+    }
     let contentFactory = (this.contentFactory =
       options.contentFactory || Cell.defaultContentFactory);
     this.layout = new PanelLayout();
@@ -173,7 +194,7 @@ export class Cell extends Widget {
     let inputCollapser = new InputCollapser();
     inputCollapser.addClass(CELL_INPUT_COLLAPSER_CLASS);
     let input = (this._input = new InputArea({
-      model,
+      data,
       contentFactory,
       updateOnShow: options.updateEditorOnShow
     }));
@@ -200,7 +221,12 @@ export class Cell extends Widget {
       );
     }
 
-    model.metadata.changed.connect(this.onMetadataChanged, this);
+    this._metadataListener = DatastoreExt.listenField(
+      this.data.datastore,
+      { ...this.data.record, field: 'metadata' },
+      this.onMetadataChanged,
+      this
+    );
   }
 
   /**
@@ -221,6 +247,11 @@ export class Cell extends Widget {
    */
   readonly contentFactory: Cell.IContentFactory;
 
+  /**
+   * The type of the cell widget.
+   */
+  type: nbformat.CellType;
+
   /**
    * Get the prompt node used by the cell.
    */
@@ -250,8 +281,8 @@ export class Cell extends Widget {
   /**
    * Get the model used by the cell.
    */
-  get model(): ICellModel {
-    return this._model;
+  get data(): ICellData.DataLocation {
+    return this._data;
   }
 
   /**
@@ -282,8 +313,12 @@ export class Cell extends Widget {
    * Save view editable state to model
    */
   saveEditableState() {
-    const { metadata } = this.model;
-    const current = metadata.get('editable');
+    let { datastore, record } = this.data;
+    let metadata = DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'metadata'
+    }) as JSONObject;
+    const current = metadata['editable'];
 
     if (
       (this.readOnly && current === false) ||
@@ -292,18 +327,32 @@ export class Cell extends Widget {
       return;
     }
 
-    if (this.readOnly) {
-      this.model.metadata.set('editable', false);
-    } else {
-      this.model.metadata.delete('editable');
-    }
+    DatastoreExt.withTransaction(datastore, () => {
+      if (this.readOnly) {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'metadata' },
+          { editable: false }
+        );
+      } else {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'metadata' },
+          { editable: null }
+        );
+      }
+    });
   }
 
   /**
    * Load view editable state from model.
    */
   loadEditableState() {
-    this.readOnly = this.model.metadata.get('editable') === false;
+    const metadata = DatastoreExt.getField(this.data.datastore, {
+      ...this.data.record,
+      field: 'metadata'
+    });
+    this.readOnly = metadata['editable'] === false;
   }
 
   /**
@@ -349,7 +398,14 @@ export class Cell extends Widget {
    * Save view collapse state to model
    */
   saveCollapseState() {
-    const jupyter = { ...(this.model.metadata.get('jupyter') as any) };
+    const { datastore, record } = this.data;
+    const metadata = DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'metadata'
+    });
+    const jupyter = {
+      ...(metadata['jupyter'] as any)
+    };
 
     if (
       (this.inputHidden && jupyter.source_hidden === true) ||
@@ -363,18 +419,32 @@ export class Cell extends Widget {
     } else {
       delete jupyter.source_hidden;
     }
-    if (Object.keys(jupyter).length === 0) {
-      this.model.metadata.delete('jupyter');
-    } else {
-      this.model.metadata.set('jupyter', jupyter);
-    }
+    DatastoreExt.withTransaction(datastore, () => {
+      if (Object.keys(jupyter).length === 0) {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'metadata' },
+          { jupyter: null }
+        );
+      } else {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'metadata' },
+          { jupyter }
+        );
+      }
+    });
   }
 
   /**
    * Revert view collapse state from model.
    */
   loadCollapseState() {
-    const jupyter = (this.model.metadata.get('jupyter') as any) || {};
+    const metadata = DatastoreExt.getField(this.data.datastore, {
+      ...this.data.record,
+      field: 'metadata'
+    });
+    const jupyter = (metadata['jupyter'] as any) || {};
     this.inputHidden = !!jupyter.source_hidden;
   }
 
@@ -428,7 +498,7 @@ export class Cell extends Widget {
   clone(): Cell {
     let constructor = this.constructor as typeof Cell;
     return new constructor({
-      model: this.model,
+      data: this._data,
       contentFactory: this.contentFactory
     });
   }
@@ -441,8 +511,14 @@ export class Cell extends Widget {
     if (this.isDisposed) {
       return;
     }
+    if (this._datastore) {
+      this._datastore.dispose();
+      this._datastore = null;
+    }
+    this._metadataListener.dispose();
+
     this._input = null;
-    this._model = null;
+    this._data = null;
     this._inputWrapper = null;
     this._inputPlaceholder = null;
     super.dispose();
@@ -474,7 +550,7 @@ export class Cell extends Widget {
    * Handle `update-request` messages.
    */
   protected onUpdateRequest(msg: Message): void {
-    if (!this._model) {
+    if (!this._data) {
       return;
     }
     // Handle read only state.
@@ -488,33 +564,31 @@ export class Cell extends Widget {
    * Handle changes in the metadata.
    */
   protected onMetadataChanged(
-    model: IObservableMap<JSONValue>,
-    args: IObservableMap.IChangedArgs<JSONValue>
+    sender: Datastore,
+    args: MapField.Change<ReadonlyJSONObject>
   ): void {
-    switch (args.key) {
-      case 'jupyter':
-        if (this.syncCollapse) {
-          this.loadCollapseState();
-        }
-        break;
-      case 'editable':
-        if (this.syncEditable) {
-          this.loadEditableState();
-        }
-        break;
-      default:
-        break;
+    if (args.current['jupyter']) {
+      if (this.syncCollapse) {
+        this.loadCollapseState();
+      }
+    }
+    if (args.current['editable']) {
+      if (this.syncEditable) {
+        this.loadEditableState();
+      }
     }
   }
 
+  private _metadataListener: IDisposable;
   private _readOnly = false;
-  private _model: ICellModel = null;
+  private _data: ICellData.DataLocation = null;
   private _inputHidden = false;
   private _input: InputArea = null;
   private _inputWrapper: Widget = null;
   private _inputPlaceholder: InputPlaceholder = null;
   private _syncCollapse = false;
   private _syncEditable = false;
+  private _datastore: Datastore | null = null;
 }
 
 /**
@@ -528,7 +602,7 @@ export namespace Cell {
     /**
      * The model used by the cell.
      */
-    model: ICellModel;
+    data?: ICellData.DataLocation;
 
     /**
      * The factory object for customizable cell children.
@@ -670,7 +744,7 @@ export class CodeCell extends Cell {
     // Only save options not handled by parent constructor.
     let rendermime = (this._rendermime = options.rendermime);
     let contentFactory = this.contentFactory;
-    let model = this.model;
+    let data = this.data;
 
     // Insert the output before the cell footer.
     let outputWrapper = (this._outputWrapper = new Panel());
@@ -678,7 +752,7 @@ export class CodeCell extends Cell {
     let outputCollapser = new OutputCollapser();
     outputCollapser.addClass(CELL_OUTPUT_COLLAPSER_CLASS);
     let output = (this._output = new OutputArea({
-      model: model.outputs,
+      data,
       rendermime,
       contentFactory: contentFactory
     }));
@@ -686,7 +760,7 @@ export class CodeCell extends Cell {
     // Set a CSS if there are no outputs, and connect a signal for future
     // changes to the number of outputs. This is for conditional styling
     // if there are no outputs.
-    if (model.outputs.length === 0) {
+    if (output.widgets.length === 0) {
       this.addClass(NO_OUTPUTS_CLASS);
     }
     output.outputLengthChanged.connect(this._outputLengthHandler, this);
@@ -697,13 +771,21 @@ export class CodeCell extends Cell {
     this._outputPlaceholder = new OutputPlaceholder(() => {
       this.outputHidden = !this.outputHidden;
     });
-    model.stateChanged.connect(this.onStateChanged, this);
+    this._executionCountListener = DatastoreExt.listenField(
+      this.data.datastore,
+      { ...this.data.record, field: 'executionCount' },
+      this.onExecutionCountChanged,
+      this
+    );
+    // Sync `collapsed` and `jupyter.outputs_hidden` for the first time, giving
+    // preference to `collapsed`.
+    this._syncCollapsed('collapsed');
   }
 
   /**
-   * The model used by the widget.
+   * The type of the cell widget.
    */
-  readonly model: ICodeCellModel;
+  type: nbformat.CellType = 'code';
 
   /**
    * Initialize view state from model.
@@ -715,8 +797,12 @@ export class CodeCell extends Cell {
   initializeState(): this {
     super.initializeState();
     this.loadScrolledState();
+    const executionCount = DatastoreExt.getField(this.data.datastore, {
+      ...this.data.record,
+      field: 'executionCount'
+    });
 
-    this.setPrompt(`${this.model.executionCount || ''}`);
+    this.setPrompt(`${executionCount || ''}`);
     return this;
   }
 
@@ -766,31 +852,32 @@ export class CodeCell extends Cell {
     // to changes in metadata until we have fully committed our changes.
     // Otherwise setting one key can trigger a write to the other key to
     // maintain the synced consistency.
-    this._savingMetadata = true;
+    super.saveCollapseState();
+    const { datastore, record } = this.data;
+    const loc: DatastoreExt.FieldLocation<ICellData.Schema, 'metadata'> = {
+      ...record,
+      field: 'metadata'
+    };
+    const metadata = DatastoreExt.getField(datastore, loc);
 
-    try {
-      super.saveCollapseState();
-
-      const metadata = this.model.metadata;
-      const collapsed = this.model.metadata.get('collapsed');
+    const collapsed = metadata['collapsed'] as boolean | undefined;
 
-      if (
-        (this.outputHidden && collapsed === true) ||
-        (!this.outputHidden && collapsed === undefined)
-      ) {
-        return;
-      }
+    if (
+      (this.outputHidden && collapsed === true) ||
+      (!this.outputHidden && collapsed === undefined)
+    ) {
+      return;
+    }
 
-      // Do not set jupyter.outputs_hidden since it is redundant. See
-      // and https://github.com/jupyter/nbformat/issues/137
+    // Do not set jupyter.outputs_hidden since it is redundant. See
+    // and https://github.com/jupyter/nbformat/issues/137
+    DatastoreExt.withTransaction(datastore, () => {
       if (this.outputHidden) {
-        metadata.set('collapsed', true);
+        DatastoreExt.updateField(datastore, loc, { collapsed: true });
       } else {
-        metadata.delete('collapsed');
+        DatastoreExt.updateField(datastore, loc, { collapsed: null });
       }
-    } finally {
-      this._savingMetadata = false;
-    }
+    });
   }
 
   /**
@@ -801,7 +888,11 @@ export class CodeCell extends Cell {
    */
   loadCollapseState() {
     super.loadCollapseState();
-    this.outputHidden = !!this.model.metadata.get('collapsed');
+    const metadata = DatastoreExt.getField(this.data.datastore, {
+      ...this.data.record,
+      field: 'metadata'
+    });
+    this.outputHidden = !!metadata['collapsed'];
   }
 
   /**
@@ -822,8 +913,12 @@ export class CodeCell extends Cell {
    * Save view collapse state to model
    */
   saveScrolledState() {
-    const { metadata } = this.model;
-    const current = metadata.get('scrolled');
+    const { datastore, record } = this.data;
+    const metadata = DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'metadata'
+    });
+    const current = metadata['scrolled'];
 
     if (
       (this.outputsScrolled && current === true) ||
@@ -831,24 +926,37 @@ export class CodeCell extends Cell {
     ) {
       return;
     }
-    if (this.outputsScrolled) {
-      metadata.set('scrolled', true);
-    } else {
-      metadata.delete('scrolled');
-    }
+    DatastoreExt.withTransaction(datastore, () => {
+      if (this.outputsScrolled) {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'metadata' },
+          { scrolled: true }
+        );
+      } else {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'metadata' },
+          { scrolled: null }
+        );
+      }
+    });
   }
 
   /**
    * Revert view collapse state from model.
    */
   loadScrolledState() {
-    const metadata = this.model.metadata;
+    const metadata = DatastoreExt.getField(this.data.datastore, {
+      ...this.data.record,
+      field: 'metadata'
+    });
 
     // We don't have the notion of 'auto' scrolled, so we make it false.
-    if (metadata.get('scrolled') === 'auto') {
+    if (metadata['scrolled'] === 'auto') {
       this.outputsScrolled = false;
     } else {
-      this.outputsScrolled = !!metadata.get('scrolled');
+      this.outputsScrolled = !!metadata['scrolled'];
     }
   }
 
@@ -890,7 +998,7 @@ export class CodeCell extends Cell {
   clone(): CodeCell {
     let constructor = this.constructor as typeof CodeCell;
     return new constructor({
-      model: this.model,
+      data: this.data,
       contentFactory: this.contentFactory,
       rendermime: this._rendermime
     });
@@ -901,7 +1009,7 @@ export class CodeCell extends Cell {
    */
   cloneOutputArea(): OutputArea {
     return new SimplifiedOutputArea({
-      model: this.model.outputs,
+      data: this.data,
       contentFactory: this.contentFactory,
       rendermime: this._rendermime
     });
@@ -918,6 +1026,7 @@ export class CodeCell extends Cell {
       this._outputLengthHandler,
       this
     );
+    this._executionCountListener.dispose();
     this._rendermime = null;
     this._output = null;
     this._outputWrapper = null;
@@ -928,13 +1037,12 @@ export class CodeCell extends Cell {
   /**
    * Handle changes in the model.
    */
-  protected onStateChanged(model: ICellModel, args: IChangedArgs<any>): void {
-    switch (args.name) {
-      case 'executionCount':
-        this.setPrompt(`${(model as ICodeCellModel).executionCount || ''}`);
-        break;
-      default:
-        break;
+  protected onExecutionCountChanged(
+    sender: Datastore,
+    args: RegisterField.Change<nbformat.ExecutionCount>
+  ): void {
+    if (args.current !== null) {
+      this.setPrompt(`${args.current}`);
     }
   }
 
@@ -942,28 +1050,29 @@ export class CodeCell extends Cell {
    * Handle changes in the metadata.
    */
   protected onMetadataChanged(
-    model: IObservableMap<JSONValue>,
-    args: IObservableMap.IChangedArgs<JSONValue>
+    sender: Datastore,
+    args: MapField.Change<ReadonlyJSONObject>
   ): void {
     if (this._savingMetadata) {
       // We are in middle of a metadata transaction, so don't react to it.
       return;
     }
-    switch (args.key) {
-      case 'scrolled':
-        if (this.syncScrolled) {
-          this.loadScrolledState();
-        }
-        break;
-      case 'collapsed':
-        if (this.syncCollapse) {
-          this.loadCollapseState();
-        }
-        break;
-      default:
-        break;
+    if (args.current['scrolled']) {
+      if (this.syncScrolled) {
+        this.loadScrolledState();
+      }
+    }
+    if (args.current['collapsed']) {
+      if (this.syncCollapse) {
+        this.loadCollapseState();
+      }
     }
-    super.onMetadataChanged(model, args);
+    if (args.current['collapsed'] !== undefined) {
+      this._syncCollapsed('collapsed');
+    } else if (args.current['jupyter'] !== undefined) {
+      this._syncCollapsed('outputs_hidden');
+    }
+    super.onMetadataChanged(sender, args);
   }
 
   /**
@@ -974,6 +1083,51 @@ export class CodeCell extends Cell {
     this.toggleClass(NO_OUTPUTS_CLASS, force);
   }
 
+  /**
+   * Ensure that the `outputs_hidden` and `collapsed` state of a code cell
+   * remain consistent, since they are redundant in nbformat 4.4. See
+   * https://github.com/jupyter/nbformat/issues/137
+   */
+  private _syncCollapsed(preference: 'collapsed' | 'outputs_hidden') {
+    const { datastore, record } = this.data;
+    const metadata = DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'metadata'
+    });
+    const collapsed = metadata['collapsed'] as boolean | undefined;
+    const jupyter = (metadata['jupyter'] || {}) as JSONObject;
+    const { outputs_hidden, ...newJupyter } = jupyter;
+
+    if (outputs_hidden === collapsed) {
+      return;
+    }
+    let update: MapField.Update<ReadonlyJSONValue>;
+    if (preference === 'collapsed') {
+      if (collapsed !== undefined) {
+        newJupyter['outputs_hidden'] = collapsed;
+      }
+      if (Object.keys(newJupyter).length === 0) {
+        update = { jupyter: null };
+      } else {
+        update = { jupyter: newJupyter };
+      }
+    } else {
+      if (jupyter.hasOwnProperty('outputs_hidden')) {
+        update = { collapsed: jupyter.outputs_hidden };
+      } else {
+        update = { collapsed: null };
+      }
+    }
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'metadata' },
+        update
+      );
+    });
+  }
+
+  private _executionCountListener: IDisposable;
   private _rendermime: IRenderMimeRegistry = null;
   private _outputHidden = false;
   private _outputsScrolled: boolean;
@@ -992,11 +1146,6 @@ export namespace CodeCell {
    * An options object for initializing a base cell widget.
    */
   export interface IOptions extends Cell.IOptions {
-    /**
-     * The model used by the cell.
-     */
-    model: ICodeCellModel;
-
     /**
      * The mime renderer for the cell widget.
      */
@@ -1011,20 +1160,30 @@ export namespace CodeCell {
     session: IClientSession,
     metadata?: JSONObject
   ): Promise<KernelMessage.IExecuteReplyMsg | void> {
-    let model = cell.model;
-    let code = model.value.text;
+    let code = cell.editor.model.value;
+    const { datastore, record } = cell.data;
     if (!code.trim() || !session.kernel) {
-      model.executionCount = null;
-      model.outputs.clear();
+      DatastoreExt.withTransaction(datastore, () => {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'executionCount' },
+          null
+        );
+        OutputAreaData.clear(cell.data);
+      });
       return;
     }
 
-    let cellId = { cellId: model.id };
+    let cellId = { cellId: cell.data.record.record };
     metadata = { ...metadata, ...cellId };
-    model.executionCount = null;
     cell.outputHidden = false;
     cell.setPrompt('*');
-    model.trusted = true;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateRecord(datastore, record, {
+        executionCount: null,
+        trusted: true
+      });
+    });
 
     let future: Kernel.IFuture<
       KernelMessage.IExecuteRequestMsg,
@@ -1040,7 +1199,13 @@ export namespace CodeCell {
       // Save this execution's future so we can compare in the catch below.
       future = cell.outputArea.future;
       const msg = await msgPromise;
-      model.executionCount = msg.content.execution_count;
+      DatastoreExt.withTransaction(datastore, () => {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'executionCount' },
+          msg.content.execution_count
+        );
+      });
       return msg;
     } catch (e) {
       // If this is still the current execution, clear the prompt.
@@ -1076,20 +1241,22 @@ export class MarkdownCell extends Cell {
     this._rendermime = options.rendermime.clone({
       resolver: new AttachmentsResolver({
         parent: options.rendermime.resolver,
-        model: this.model.attachments
+        data: this.data
       })
     });
 
     // Throttle the rendering rate of the widget.
-    this._monitor = new ActivityMonitor({
-      signal: this.model.contentChanged,
-      timeout: RENDER_TIMEOUT
-    });
-    this._monitor.activityStopped.connect(() => {
+    this._debouncer = new Debouncer(() => {
       if (this._rendered) {
         this.update();
       }
-    }, this);
+    }, RENDER_TIMEOUT);
+
+    this._listener = DatastoreExt.listenField(
+      this.editor.model.data.datastore,
+      { ...this.editor.model.data.record, field: 'text' },
+      () => this._debouncer.invoke()
+    );
 
     void this._updateRenderedInput().then(() => {
       this._ready.resolve(void 0);
@@ -1098,9 +1265,9 @@ export class MarkdownCell extends Cell {
   }
 
   /**
-   * The model used by the widget.
+   * The type of the cell widget.
    */
-  readonly model: IMarkdownCellModel;
+  readonly type: nbformat.CellType = 'markdown';
 
   /**
    * A promise that resolves when the widget renders for the first time.
@@ -1129,6 +1296,15 @@ export class MarkdownCell extends Cell {
     }
   }
 
+  dispose(): void {
+    if (this.isDisposed) {
+      return;
+    }
+    this._listener.dispose();
+    this._debouncer.dispose();
+    super.dispose();
+  }
+
   /**
    * Render an input instead of the text editor.
    */
@@ -1172,8 +1348,7 @@ export class MarkdownCell extends Cell {
    * Update the rendered input.
    */
   private _updateRenderedInput(): Promise<void> {
-    let model = this.model;
-    let text = (model && model.value.text) || DEFAULT_MARKDOWN_TEXT;
+    let text = this.editor.model.value || DEFAULT_MARKDOWN_TEXT;
     // Do not re-render if the text has not changed.
     if (text !== this._prevText) {
       let mimeModel = new MimeModel({ data: { 'text/markdown': text } });
@@ -1193,13 +1368,14 @@ export class MarkdownCell extends Cell {
   clone(): MarkdownCell {
     let constructor = this.constructor as typeof MarkdownCell;
     return new constructor({
-      model: this.model,
+      data: this.data,
       contentFactory: this.contentFactory,
       rendermime: this._rendermime
     });
   }
 
-  private _monitor: ActivityMonitor<any, any> = null;
+  private _listener: IDisposable;
+  private _debouncer: Debouncer;
   private _renderer: IRenderMime.IRenderer = null;
   private _rendermime: IRenderMimeRegistry;
   private _rendered = true;
@@ -1215,11 +1391,6 @@ export namespace MarkdownCell {
    * An options object for initializing a base cell widget.
    */
   export interface IOptions extends Cell.IOptions {
-    /**
-     * The model used by the cell.
-     */
-    model: IMarkdownCellModel;
-
     /**
      * The mime renderer for the cell widget.
      */
@@ -1249,15 +1420,15 @@ export class RawCell extends Cell {
   clone(): RawCell {
     let constructor = this.constructor as typeof RawCell;
     return new constructor({
-      model: this.model,
+      data: this.data,
       contentFactory: this.contentFactory
     });
   }
 
   /**
-   * The model used by the widget.
+   * The type of the cell widget.
    */
-  readonly model: IRawCellModel;
+  readonly type: nbformat.CellType = 'raw';
 }
 
 /**
@@ -1267,10 +1438,5 @@ export namespace RawCell {
   /**
    * An options object for initializing a base cell widget.
    */
-  export interface IOptions extends Cell.IOptions {
-    /**
-     * The model used by the cell.
-     */
-    model: IRawCellModel;
-  }
+  export interface IOptions extends Cell.IOptions {}
 }
diff --git a/packages/cells/tsconfig.json b/packages/cells/tsconfig.json
index 7243747dc01..0cf4f5f08cc 100644
--- a/packages/cells/tsconfig.json
+++ b/packages/cells/tsconfig.json
@@ -22,7 +22,7 @@
       "path": "../coreutils"
     },
     {
-      "path": "../observables"
+      "path": "../datastore"
     },
     {
       "path": "../outputarea"
diff --git a/packages/codeeditor/package.json b/packages/codeeditor/package.json
index 706c4bd645b..4d5fadccc57 100644
--- a/packages/codeeditor/package.json
+++ b/packages/codeeditor/package.json
@@ -36,8 +36,9 @@
   },
   "dependencies": {
     "@jupyterlab/coreutils": "^3.0.0",
-    "@jupyterlab/observables": "^2.2.0",
+    "@jupyterlab/datastore": "^1.0.0",
     "@phosphor/coreutils": "^1.3.1",
+    "@phosphor/datastore": "0.7.2",
     "@phosphor/disposable": "^1.2.0",
     "@phosphor/dragdrop": "^1.3.3",
     "@phosphor/messaging": "^1.2.3",
diff --git a/packages/codeeditor/src/data.ts b/packages/codeeditor/src/data.ts
new file mode 100644
index 00000000000..a17aad2c2b1
--- /dev/null
+++ b/packages/codeeditor/src/data.ts
@@ -0,0 +1,113 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import { DatastoreExt } from '@jupyterlab/datastore';
+
+import {
+  Datastore,
+  Fields,
+  MapField,
+  RegisterField,
+  TextField
+} from '@phosphor/datastore';
+
+import { CodeEditor } from './editor';
+
+/**
+ * A namespace for interfaces describing how a code editor holds its data.
+ */
+export namespace ICodeEditorData {
+  /**
+   * An interface for a CodeEditor schema.
+   */
+  export type Schema = {
+    /**
+     * The schema id.
+     */
+    id: string;
+
+    /**
+     * The schema fields.
+     */
+    fields: {
+      /**
+       * The mime type for the editor.
+       */
+      readonly mimeType: RegisterField<string>;
+
+      /**
+       * The text content of the editor.
+       */
+      readonly text: TextField;
+
+      /**
+       * The cursors for the editor.
+       */
+      readonly selections: MapField<CodeEditor.ITextSelection[]>;
+    };
+  };
+
+  /**
+   * A description of where data is stored in a code editor.
+   */
+  export type DataLocation = DatastoreExt.DataLocation & {
+    /**
+     * The record in which the data is located.
+     */
+    record: DatastoreExt.RecordLocation<Schema>;
+  };
+}
+
+/**
+ * Concrete utitlites for working with code editor data.
+ */
+export namespace CodeEditorData {
+  /**
+   * Create an in-memory datastore capable of holding the data for an editor.
+   */
+  export function createStore(id: number = 1): Datastore {
+    return Datastore.create({
+      id,
+      schemas: [SCHEMA]
+    });
+  }
+
+  /**
+   * A concrete CodeEditor schema, available at runtime.
+   */
+  export const SCHEMA: ICodeEditorData.Schema = {
+    /**
+     * The schema id.
+     */
+    id: '@jupyterlab/codeeditor:codeeditor:v1',
+
+    /**
+     * Concrete realizations of the schema fields, available at runtime.
+     */
+    fields: {
+      mimeType: Fields.String(),
+      text: Fields.Text(),
+      selections: Fields.Map<CodeEditor.ITextSelection[]>()
+    }
+  };
+
+  /*
+   * Clear editor data. The record is not actually removed, but its data
+   * is emptied as much as possible to allow it to garbage collect.
+   */
+  export function clear(data: ICodeEditorData.DataLocation): void {
+    let { datastore, record } = data;
+    const editorData = DatastoreExt.getRecord(datastore, record);
+
+    const selections: { [x: string]: CodeEditor.ITextSelection[] | null } = {};
+    Object.keys(editorData.selections).forEach(key => (selections[key] = null));
+
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateRecord(datastore, record, {
+        selections,
+        text: { index: 0, remove: editorData.text.length, text: '' },
+        mimeType: 'text/plain'
+      });
+    });
+  }
+}
diff --git a/packages/codeeditor/src/editor.ts b/packages/codeeditor/src/editor.ts
index 5b9e48c3187..1a6d3d712a1 100644
--- a/packages/codeeditor/src/editor.ts
+++ b/packages/codeeditor/src/editor.ts
@@ -1,22 +1,17 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
+import { DatastoreExt } from '@jupyterlab/datastore';
+
 import { JSONObject } from '@phosphor/coreutils';
 
+import { Datastore } from '@phosphor/datastore';
+
 import { IDisposable } from '@phosphor/disposable';
 
 import { ISignal, Signal } from '@phosphor/signaling';
 
-import { IChangedArgs } from '@jupyterlab/coreutils';
-
-import {
-  IModelDB,
-  ModelDB,
-  IObservableValue,
-  ObservableValue,
-  IObservableMap,
-  IObservableString
-} from '@jupyterlab/observables';
+import { CodeEditorData, ICodeEditorData } from './data';
 
 /**
  * A namespace for code editors.
@@ -111,7 +106,7 @@ export namespace CodeEditor {
   export const defaultSelectionStyle: ISelectionStyle = {
     className: '',
     displayName: '',
-    color: 'black'
+    color: '#2196F3'
   };
 
   /**
@@ -170,15 +165,10 @@ export namespace CodeEditor {
    * An editor model.
    */
   export interface IModel extends IDisposable {
-    /**
-     * A signal emitted when a property changes.
-     */
-    mimeTypeChanged: ISignal<IModel, IChangedArgs<string>>;
-
     /**
      * The text stored in the model.
      */
-    readonly value: IObservableString;
+    value: string;
 
     /**
      * A mime type of the model.
@@ -191,13 +181,12 @@ export namespace CodeEditor {
     /**
      * The currently selected code.
      */
-    readonly selections: IObservableMap<ITextSelection[]>;
+    readonly selections: { [id: string]: ITextSelection[] };
 
     /**
-     * The underlying `IModelDB` instance in which model
-     * data is stored.
+     * The location in the datastore in which this codeeditor keeps its data.
      */
-    readonly modelDB: IModelDB;
+    readonly data: ICodeEditorData.DataLocation;
   }
 
   /**
@@ -210,61 +199,107 @@ export namespace CodeEditor {
     constructor(options?: Model.IOptions) {
       options = options || {};
 
-      if (options.modelDB) {
-        this.modelDB = options.modelDB;
+      if (options.data) {
+        this.data = options.data;
       } else {
-        this.modelDB = new ModelDB();
+        const datastore = (this._datastore = CodeEditorData.createStore());
+        this.data = {
+          datastore,
+          record: {
+            schema: CodeEditorData.SCHEMA,
+            record: 'data'
+          }
+        };
+      }
+      const { datastore, record } = this.data;
+      if (!DatastoreExt.getRecord(datastore, record)) {
+        this.isPrepopulated = false;
+        // Initialize the record if it hasn't been.
+        DatastoreExt.withTransaction(datastore, () => {
+          DatastoreExt.updateRecord(datastore, record, {
+            mimeType: options.mimeType || 'text/plain',
+            text: { index: 0, remove: 0, text: options.value || '' }
+          });
+        });
+      } else {
+        this.isPrepopulated = true;
+        // Possibly override any data existing in the record with options
+        // provided by the user.
+        if (options.value) {
+          this.value = options.value;
+        }
+        if (options.mimeType) {
+          this.mimeType = options.mimeType;
+        }
+        if (!this.mimeType) {
+          this.mimeType = 'text/plain';
+        }
       }
-
-      let value = this.modelDB.createString('value');
-      value.text = value.text || options.value || '';
-
-      let mimeType = this.modelDB.createValue('mimeType');
-      mimeType.set(options.mimeType || 'text/plain');
-      mimeType.changed.connect(this._onMimeTypeChanged, this);
-
-      this.modelDB.createMap('selections');
     }
 
     /**
-     * The underlying `IModelDB` instance in which model
-     * data is stored.
+     * The record in the datastore in which this codeeditor keeps its data.
      */
-    readonly modelDB: IModelDB;
+    readonly data: ICodeEditorData.DataLocation;
 
-    /**
-     * A signal emitted when a mimetype changes.
-     */
-    get mimeTypeChanged(): ISignal<this, IChangedArgs<string>> {
-      return this._mimeTypeChanged;
-    }
+    readonly isPrepopulated: boolean;
 
     /**
      * Get the value of the model.
      */
-    get value(): IObservableString {
-      return this.modelDB.get('value') as IObservableString;
+    get value(): string {
+      return DatastoreExt.getField(this.data.datastore, {
+        ...this.data.record,
+        field: 'text'
+      });
+    }
+    set value(value: string) {
+      const current = this.value;
+      DatastoreExt.withTransaction(this.data.datastore, () => {
+        DatastoreExt.updateField(
+          this.data.datastore,
+          { ...this.data.record, field: 'text' },
+          {
+            index: 0,
+            remove: current.length,
+            text: value
+          }
+        );
+      });
     }
 
     /**
      * Get the selections for the model.
      */
-    get selections(): IObservableMap<ITextSelection[]> {
-      return this.modelDB.get('selections') as IObservableMap<ITextSelection[]>;
+    get selections(): { [id: string]: ITextSelection[] } {
+      return DatastoreExt.getField(this.data.datastore, {
+        ...this.data.record,
+        field: 'selections'
+      });
     }
 
     /**
      * A mime type of the model.
      */
     get mimeType(): string {
-      return this.modelDB.getValue('mimeType') as string;
+      return DatastoreExt.getField(this.data.datastore, {
+        ...this.data.record,
+        field: 'mimeType'
+      });
     }
     set mimeType(newValue: string) {
       const oldValue = this.mimeType;
       if (oldValue === newValue) {
         return;
       }
-      this.modelDB.setValue('mimeType', newValue);
+      const { datastore, record } = this.data;
+      DatastoreExt.withTransaction(datastore, () => {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'mimeType' },
+          newValue
+        );
+      });
     }
 
     /**
@@ -281,24 +316,16 @@ export namespace CodeEditor {
       if (this._isDisposed) {
         return;
       }
+      if (this._datastore) {
+        this._datastore.dispose();
+        this._datastore = null;
+      }
       this._isDisposed = true;
-      this.value.text = '';
       Signal.clearData(this);
     }
 
-    private _onMimeTypeChanged(
-      mimeType: IObservableValue,
-      args: ObservableValue.IChangedArgs
-    ): void {
-      this._mimeTypeChanged.emit({
-        name: 'mimeType',
-        oldValue: args.oldValue as string,
-        newValue: args.newValue as string
-      });
-    }
-
     private _isDisposed = false;
-    private _mimeTypeChanged = new Signal<this, IChangedArgs<string>>(this);
+    private _datastore: Datastore | null = null;
   }
 
   /**
@@ -709,9 +736,9 @@ export namespace CodeEditor {
       mimeType?: string;
 
       /**
-       * An optional modelDB for storing model state.
+       * A location in an existing datastore in which to store the model.
        */
-      modelDB?: IModelDB;
+      data?: ICodeEditorData.DataLocation;
     }
   }
 }
diff --git a/packages/codeeditor/src/index.ts b/packages/codeeditor/src/index.ts
index e67c50c901c..59fbce1c70b 100644
--- a/packages/codeeditor/src/index.ts
+++ b/packages/codeeditor/src/index.ts
@@ -1,6 +1,7 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
+export * from './data';
 export * from './editor';
 export * from './jsoneditor';
 export * from './widget';
diff --git a/packages/codeeditor/src/jsoneditor.ts b/packages/codeeditor/src/jsoneditor.ts
index 8f34fe73c9b..b63ecb8aea1 100644
--- a/packages/codeeditor/src/jsoneditor.ts
+++ b/packages/codeeditor/src/jsoneditor.ts
@@ -1,9 +1,18 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { IObservableJSON } from '@jupyterlab/observables';
+import { DatastoreExt } from '@jupyterlab/datastore';
 
-import { JSONExt, JSONObject } from '@phosphor/coreutils';
+import {
+  JSONExt,
+  JSONObject,
+  JSONValue,
+  ReadonlyJSONObject
+} from '@phosphor/coreutils';
+
+import { Datastore, MapField, Schema } from '@phosphor/datastore';
+
+import { IDisposable } from '@phosphor/disposable';
 
 import { Message } from '@phosphor/messaging';
 
@@ -44,7 +53,10 @@ const COMMIT_CLASS = 'jp-JSONEditor-commitButton';
 /**
  * A widget for editing observable JSON.
  */
-export class JSONEditor extends Widget {
+export class JSONEditor<
+  S extends Schema,
+  F extends keyof JSONEditor.MapFields<S>
+> extends Widget {
   /**
    * Construct a new JSON editor.
    */
@@ -75,9 +87,14 @@ export class JSONEditor extends Widget {
 
     let model = new CodeEditor.Model();
 
-    model.value.text = 'No data!';
+    model.value = 'No data!';
     model.mimeType = 'application/json';
-    model.value.changed.connect(this._onValueChanged, this);
+    DatastoreExt.listenField(
+      model.data.datastore,
+      { ...model.data.record, field: 'text' },
+      this._onValueChanged,
+      this
+    );
     this.model = model;
     this.editor = options.editorFactory({ host: this.editorHostNode, model });
     this.editor.setOption('readOnly', true);
@@ -116,20 +133,26 @@ export class JSONEditor extends Widget {
   /**
    * The observable source.
    */
-  get source(): IObservableJSON | null {
+  get source(): JSONEditor.DataLocation<S, F> | null {
     return this._source;
   }
-  set source(value: IObservableJSON | null) {
+  set source(value: JSONEditor.DataLocation<S, F> | null) {
     if (this._source === value) {
       return;
     }
-    if (this._source) {
-      this._source.changed.disconnect(this._onSourceChanged, this);
+    if (this._listener) {
+      this._listener.dispose();
+      this._listener = null;
     }
     this._source = value;
     this.editor.setOption('readOnly', value === null);
     if (value) {
-      value.changed.connect(this._onSourceChanged, this);
+      this._listener = DatastoreExt.listenField(
+        this._source.datastore,
+        this._source.field,
+        this._onSourceChanged,
+        this
+      );
     }
     this._setValue();
   }
@@ -204,11 +227,11 @@ export class JSONEditor extends Widget {
   }
 
   /**
-   * Handle a change to the metadata of the source.
+   * Handle a change to the JSON of the source.
    */
   private _onSourceChanged(
-    sender: IObservableJSON,
-    args: IObservableJSON.IChangedArgs
+    sender: Datastore,
+    args: MapField.Change<JSONValue>
   ) {
     if (this._changeGuard) {
       return;
@@ -226,7 +249,7 @@ export class JSONEditor extends Widget {
   private _onValueChanged(): void {
     let valid = true;
     try {
-      let value = JSON.parse(this.editor.model.value.text);
+      let value = JSON.parse(this.editor.model.value);
       this.removeClass(ERROR_CLASS);
       this._inputDirty =
         !this._changeGuard && !JSONExt.deepEqual(value, this._originalValue);
@@ -280,25 +303,29 @@ export class JSONEditor extends Widget {
   private _mergeContent(): void {
     let model = this.editor.model;
     let old = this._originalValue;
-    let user = JSON.parse(model.value.text) as JSONObject;
+    let user = JSON.parse(model.value) as JSONObject;
     let source = this.source;
     if (!source) {
       return;
     }
 
-    // If it is in user and has changed from old, set in new.
-    for (let key in user) {
-      if (!JSONExt.deepEqual(user[key], old[key] || null)) {
-        source.set(key, user[key]);
-      }
-    }
-
-    // If it was in old and is not in user, remove from source.
-    for (let key in old) {
+    let update: JSONObject = {};
+    Object.keys(old).forEach(key => {
+      // If it was in old and not in user, remove from the source.
       if (!(key in user)) {
-        source.delete(key);
+        update[key] = null;
       }
-    }
+    });
+    Object.keys(user).forEach(key => {
+      // If it is in user and has changed from old, set in new
+      if (!JSONExt.deepEqual(user[key], old[key] || null)) {
+        update[key] = user[key];
+      }
+    });
+    let { datastore, field } = this._source;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateField(datastore, field, update);
+    });
   }
 
   /**
@@ -311,14 +338,19 @@ export class JSONEditor extends Widget {
     this.commitButtonNode.hidden = true;
     this.removeClass(ERROR_CLASS);
     let model = this.editor.model;
-    let content = this._source ? this._source.toJSON() : {};
+    let content = this._source
+      ? (DatastoreExt.getField(
+          this._source.datastore,
+          this._source.field
+        ) as ReadonlyJSONObject)
+      : {};
     this._changeGuard = true;
     if (content === void 0) {
-      model.value.text = 'No data!';
+      model.value = 'No data!';
       this._originalValue = JSONExt.emptyObject;
     } else {
       let value = JSON.stringify(content, null, 4);
-      model.value.text = value;
+      model.value = value;
       this._originalValue = content;
       // Move the cursor to within the brace.
       if (value.length > 1 && value[0] === '{') {
@@ -333,9 +365,10 @@ export class JSONEditor extends Widget {
 
   private _dataDirty = false;
   private _inputDirty = false;
-  private _source: IObservableJSON | null = null;
-  private _originalValue = JSONExt.emptyObject;
+  private _source: JSONEditor.DataLocation<S, F> | null = null;
+  private _originalValue: ReadonlyJSONObject = JSONExt.emptyObject;
   private _changeGuard = false;
+  private _listener: IDisposable | null = null;
 }
 
 /**
@@ -351,4 +384,23 @@ export namespace JSONEditor {
      */
     editorFactory: CodeEditor.Factory;
   }
+
+  /**
+   * The subset of fields in a schema that represent a JSON Object.
+   */
+  export type MapFields<S extends Schema> = {
+    [F in keyof S['fields']]: S['fields'][F] extends MapField<JSONValue>
+      ? F
+      : never;
+  };
+
+  /**
+   * A field location referencing a JSON-able object.
+   */
+  export type DataLocation<
+    S extends Schema,
+    F extends keyof MapFields<S>
+  > = DatastoreExt.DataLocation & {
+    field: DatastoreExt.FieldLocation<S, F>;
+  };
 }
diff --git a/packages/codeeditor/src/widget.ts b/packages/codeeditor/src/widget.ts
index 270f1126db9..b0214c6863d 100644
--- a/packages/codeeditor/src/widget.ts
+++ b/packages/codeeditor/src/widget.ts
@@ -1,6 +1,8 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
+import { DatastoreExt } from '@jupyterlab/datastore';
+
 import { MimeData } from '@phosphor/coreutils';
 
 import { IDragEvent } from '@phosphor/dragdrop';
@@ -48,7 +50,12 @@ export class CodeEditorWrapper extends Widget {
       config: options.config,
       selectionStyle: options.selectionStyle
     }));
-    editor.model.selections.changed.connect(this._onSelectionsChanged, this);
+    DatastoreExt.listenField(
+      editor.model.data.datastore,
+      { ...editor.model.data.record, field: 'selections' },
+      this._onSelectionsChanged,
+      this
+    );
     this._updateOnShow = options.updateOnShow !== false;
   }
 
@@ -271,7 +278,13 @@ export class CodeEditorWrapper extends Widget {
     };
     const position = this.editor.getPositionForCoordinate(coordinate);
     const offset = this.editor.getOffsetAt(position);
-    this.model.value.insert(offset, data);
+    DatastoreExt.withTransaction(this.model.data.datastore, () => {
+      DatastoreExt.updateField(
+        this.model.data.datastore,
+        { ...this.model.data.record, field: 'text' },
+        { index: offset, remove: 0, text: data }
+      );
+    });
   }
 
   private _updateOnShow: boolean;
diff --git a/packages/codeeditor/tsconfig.json b/packages/codeeditor/tsconfig.json
index b6147c37b78..53bbe505f6b 100644
--- a/packages/codeeditor/tsconfig.json
+++ b/packages/codeeditor/tsconfig.json
@@ -10,7 +10,7 @@
       "path": "../coreutils"
     },
     {
-      "path": "../observables"
+      "path": "../datastore"
     }
   ]
 }
diff --git a/packages/codemirror-extension/src/index.ts b/packages/codemirror-extension/src/index.ts
index 16c0e1a5f3a..a30670acace 100644
--- a/packages/codemirror-extension/src/index.ts
+++ b/packages/codemirror-extension/src/index.ts
@@ -209,7 +209,8 @@ function activateEditorCommands(
   /**
    * Handle the settings of new widgets.
    */
-  tracker.widgetAdded.connect((sender, widget) => {
+  tracker.widgetAdded.connect(async (sender, widget) => {
+    await widget.context.ready;
     if (widget.content.editor instanceof CodeMirrorEditor) {
       let cm = widget.content.editor.editor;
       cm.setOption('keyMap', keyMap);
diff --git a/packages/codemirror/package.json b/packages/codemirror/package.json
index ba3485bd937..d3e1985327b 100644
--- a/packages/codemirror/package.json
+++ b/packages/codemirror/package.json
@@ -36,11 +36,13 @@
     "@jupyterlab/apputils": "^1.0.1",
     "@jupyterlab/codeeditor": "^1.0.0",
     "@jupyterlab/coreutils": "^3.0.0",
+    "@jupyterlab/datastore": "^1.0.0",
     "@jupyterlab/observables": "^2.2.0",
     "@jupyterlab/statusbar": "^1.0.1",
     "@phosphor/algorithm": "^1.1.3",
     "@phosphor/commands": "^1.6.3",
     "@phosphor/coreutils": "^1.3.1",
+    "@phosphor/datastore": "0.7.2",
     "@phosphor/disposable": "^1.2.0",
     "@phosphor/signaling": "^1.2.3",
     "@phosphor/widgets": "^1.8.0",
diff --git a/packages/codemirror/src/editor.ts b/packages/codemirror/src/editor.ts
index d68ff9601f0..204ac6e6b06 100644
--- a/packages/codemirror/src/editor.ts
+++ b/packages/codemirror/src/editor.ts
@@ -17,15 +17,15 @@ import { showDialog } from '@jupyterlab/apputils';
 
 import { Poll } from '@jupyterlab/coreutils';
 
+import { DatastoreExt } from '@jupyterlab/datastore';
+
 import { CodeEditor } from '@jupyterlab/codeeditor';
 
 import { UUID } from '@phosphor/coreutils';
 
-import {
-  IObservableMap,
-  IObservableString,
-  ICollaborator
-} from '@jupyterlab/observables';
+import { Datastore, MapField, TextField } from '@phosphor/datastore';
+
+import { ICollaborator } from '@jupyterlab/observables';
 
 import { Mode } from './mode';
 
@@ -121,7 +121,7 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
     let doc = editor.getDoc();
 
     // Handle initial values for text, mimetype, and selections.
-    doc.setValue(model.value.text);
+    doc.setValue(model.value);
     this.clearHistory();
     this._onMimeTypeChanged();
     this._onCursorActivity();
@@ -137,9 +137,25 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
     });
 
     // Connect to changes.
-    model.value.changed.connect(this._onValueChanged, this);
-    model.mimeTypeChanged.connect(this._onMimeTypeChanged, this);
-    model.selections.changed.connect(this._onSelectionsChanged, this);
+    let { record, datastore } = model.data;
+    DatastoreExt.listenField(
+      datastore,
+      { ...record, field: 'text' },
+      this._onValueChanged,
+      this
+    );
+    DatastoreExt.listenField(
+      datastore,
+      { ...record, field: 'mimeType' },
+      this._onMimeTypeChanged,
+      this
+    );
+    DatastoreExt.listenField(
+      datastore,
+      { ...record, field: 'selections' },
+      this._onSelectionsChanged,
+      this
+    );
 
     CodeMirror.on(editor, 'keydown', (editor: CodeMirror.Editor, event) => {
       let index = ArrayExt.findFirstIndex(this._keydownHandlers, handler => {
@@ -532,7 +548,14 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
     // will get screened out in _onCursorsChanged(). Make an
     // exception for this method.
     if (!this.editor.hasFocus()) {
-      this.model.selections.set(this.uuid, this.getSelections());
+      const { datastore, record } = this.model.data;
+      DatastoreExt.withTransaction(datastore, () => {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'selections' },
+          { [this.uuid]: this.getSelections() }
+        );
+      });
     }
   }
 
@@ -694,16 +717,17 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
    * Handles a selections change.
    */
   private _onSelectionsChanged(
-    selections: IObservableMap<CodeEditor.ITextSelection[]>,
-    args: IObservableMap.IChangedArgs<CodeEditor.ITextSelection[]>
+    sender: Datastore,
+    args: MapField.Change<CodeEditor.ITextSelection[]>
   ): void {
-    const uuid = args.key;
-    if (uuid !== this.uuid) {
-      this._cleanSelections(uuid);
-      if (args.type !== 'remove' && args.newValue) {
-        this._markSelections(uuid, args.newValue);
+    Object.keys(args.current).forEach(uuid => {
+      if (uuid !== this.uuid) {
+        this._cleanSelections(uuid);
+        if (args.current[uuid] !== null && args.current[uuid]) {
+          this._markSelections(uuid, args.current[uuid]);
+        }
       }
-    }
+    });
   }
 
   /**
@@ -736,9 +760,7 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
     // If we can id the selection to a specific collaborator,
     // use that information.
     let collaborator: ICollaborator | undefined;
-    if (this._model.modelDB.collaborators) {
-      collaborator = this._model.modelDB.collaborators.get(uuid);
-    }
+    // TODO: figure out who our collaborators are so we can show it.
 
     // Style each selection for the uuid.
     selections.forEach(selection => {
@@ -768,7 +790,7 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
           markerOptions = this._toTextMarkerOptions(selection.style);
         }
         markers.push(this.doc.markText(anchor, head, markerOptions));
-      } else if (collaborator) {
+      } else {
         let caret = this._getCaret(collaborator);
         markers.push(
           this.doc.setBookmark(this._toCodeMirrorPosition(selection.end), {
@@ -787,8 +809,14 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
     // Only add selections if the editor has focus. This avoids unwanted
     // triggering of cursor activity due to collaborator actions.
     if (this._editor.hasFocus()) {
-      const selections = this.getSelections();
-      this.model.selections.set(this.uuid, selections);
+      const { datastore, record } = this.model.data;
+      DatastoreExt.withTransaction(datastore, () => {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'selections' },
+          { [this.uuid]: this.getSelections() }
+        );
+      });
     }
   }
 
@@ -858,38 +886,24 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
   /**
    * Handle model value changes.
    */
-  private _onValueChanged(
-    value: IObservableString,
-    args: IObservableString.IChangedArgs
-  ): void {
+  private _onValueChanged(sender: Datastore, changes: TextField.Change): void {
+    // Ignore changes that have already been applied locally.
     if (this._changeGuard) {
       return;
     }
-    this._changeGuard = true;
-    let doc = this.doc;
-    switch (args.type) {
-      case 'insert':
-        let pos = doc.posFromIndex(args.start);
-        // Replace the range, including a '+input' orign,
-        // which indicates that CodeMirror may merge changes
-        // for undo/redo purposes.
-        doc.replaceRange(args.value, pos, pos, '+input');
-        break;
-      case 'remove':
-        let from = doc.posFromIndex(args.start);
-        let to = doc.posFromIndex(args.end);
-        // Replace the range, including a '+input' orign,
-        // which indicates that CodeMirror may merge changes
-        // for undo/redo purposes.
-        doc.replaceRange('', from, to, '+input');
-        break;
-      case 'set':
-        doc.setValue(args.value);
-        break;
-      default:
-        break;
-    }
-    this._changeGuard = false;
+    const doc = this.doc;
+    changes.forEach(tc => {
+      // Convert the change data to codemirror range and inserted text.
+      const from = doc.posFromIndex(tc.index);
+      const to = doc.posFromIndex(tc.index + tc.removed.length);
+      const replacement = tc.inserted;
+
+      // Apply the operation, setting the change guard so we can ignore
+      // the change signals from codemirror.
+      this._changeGuard = true;
+      doc.replaceRange(replacement, from, to, '+input');
+      this._changeGuard = false;
+    });
   }
 
   /**
@@ -902,18 +916,19 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
     if (this._changeGuard) {
       return;
     }
+    const start = doc.indexFromPos(change.from);
+    const end = doc.indexFromPos(change.to);
+    const text = change.text.join('\n');
+    // If this was a local change, update the table.
     this._changeGuard = true;
-    let value = this._model.value;
-    let start = doc.indexFromPos(change.from);
-    let end = doc.indexFromPos(change.to);
-    let inserted = change.text.join('\n');
-
-    if (end !== start) {
-      value.remove(start, end);
-    }
-    if (inserted) {
-      value.insert(start, inserted);
-    }
+    const { datastore, record } = this.model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'text' },
+        { index: start, remove: end - start, text }
+      );
+    });
     this._changeGuard = false;
   }
 
@@ -990,7 +1005,7 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
    * Construct a caret element representing the position
    * of a collaborator's cursor.
    */
-  private _getCaret(collaborator: ICollaborator): HTMLElement {
+  private _getCaret(collaborator?: ICollaborator): HTMLElement {
     let name = collaborator ? collaborator.displayName : 'Anonymous';
     let color = collaborator ? collaborator.color : this._selectionStyle.color;
     let caret: HTMLElement = document.createElement('span');
@@ -998,7 +1013,7 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
     caret.style.borderBottomColor = color;
     caret.onmouseenter = () => {
       this._clearHover();
-      this._hoverId = collaborator.sessionId;
+      this._hoverId = collaborator ? collaborator.sessionId : UUID.uuid4();
       let rect = caret.getBoundingClientRect();
       // Construct and place the hover box.
       let hover = document.createElement('div');
@@ -1039,7 +1054,7 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
     this._lastChange = null;
     let editor = this._editor;
     let doc = editor.getDoc();
-    if (doc.getValue() === this._model.value.text) {
+    if (doc.getValue() === this._model.value) {
       return;
     }
 
@@ -1053,7 +1068,7 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
     );
     console.log(
       JSON.stringify({
-        model: this._model.value.text,
+        model: this._model.value,
         view: doc.getValue(),
         selections: this.getSelections(),
         cursor: this.getCursorPosition(),
diff --git a/packages/codemirror/src/syntaxstatus.tsx b/packages/codemirror/src/syntaxstatus.tsx
index 888747cfb40..02032ae1652 100644
--- a/packages/codemirror/src/syntaxstatus.tsx
+++ b/packages/codemirror/src/syntaxstatus.tsx
@@ -4,7 +4,7 @@ import { VDomRenderer, VDomModel } from '@jupyterlab/apputils';
 
 import { CodeEditor } from '@jupyterlab/codeeditor';
 
-import { IChangedArgs } from '@jupyterlab/coreutils';
+import { DatastoreExt } from '@jupyterlab/datastore';
 
 import {
   interactiveItem,
@@ -19,6 +19,10 @@ import { CommandRegistry } from '@phosphor/commands';
 
 import { JSONObject } from '@phosphor/coreutils';
 
+import { Datastore, RegisterField } from '@phosphor/datastore';
+
+import { IDisposable } from '@phosphor/disposable';
+
 import { Menu } from '@phosphor/widgets';
 
 /**
@@ -150,9 +154,9 @@ export namespace EditorSyntaxStatus {
       return this._editor;
     }
     set editor(editor: CodeEditor.IEditor | null) {
-      const oldEditor = this._editor;
-      if (oldEditor !== null) {
-        oldEditor.model.mimeTypeChanged.disconnect(this._onMIMETypeChange);
+      if (this._mimeTypeListener) {
+        this._mimeTypeListener.dispose();
+        this._mimeTypeListener = null;
       }
       const oldMode = this._mode;
       this._editor = editor;
@@ -162,7 +166,11 @@ export namespace EditorSyntaxStatus {
         const spec = Mode.findByMIME(this._editor.model.mimeType);
         this._mode = spec.name || spec.mode;
 
-        this._editor.model.mimeTypeChanged.connect(this._onMIMETypeChange);
+        DatastoreExt.listenField(
+          editor.model.data.datastore,
+          { ...editor.model.data.record, field: 'mimeType' },
+          this._onMIMETypeChange
+        );
       }
 
       this._triggerChange(oldMode, this._mode);
@@ -172,11 +180,11 @@ export namespace EditorSyntaxStatus {
      * If the editor mode changes, update the model.
      */
     private _onMIMETypeChange = (
-      mode: CodeEditor.IModel,
-      change: IChangedArgs<string>
+      sender: Datastore,
+      change: RegisterField.Change<string>
     ) => {
       const oldMode = this._mode;
-      const spec = Mode.findByMIME(change.newValue);
+      const spec = Mode.findByMIME(change.current);
       this._mode = spec.name || spec.mode;
 
       this._triggerChange(oldMode, this._mode);
@@ -193,6 +201,7 @@ export namespace EditorSyntaxStatus {
 
     private _mode: string = '';
     private _editor: CodeEditor.IEditor | null = null;
+    private _mimeTypeListener: IDisposable;
   }
 
   /**
diff --git a/packages/codemirror/tsconfig.json b/packages/codemirror/tsconfig.json
index cef6c8e4442..a8a54b56b6f 100644
--- a/packages/codemirror/tsconfig.json
+++ b/packages/codemirror/tsconfig.json
@@ -15,6 +15,9 @@
     {
       "path": "../coreutils"
     },
+    {
+      "path": "../datastore"
+    },
     {
       "path": "../observables"
     },
diff --git a/packages/completer-extension/src/index.ts b/packages/completer-extension/src/index.ts
index f29b4b41c13..0328202ba28 100644
--- a/packages/completer-extension/src/index.ts
+++ b/packages/completer-extension/src/index.ts
@@ -216,7 +216,7 @@ const notebooks: JupyterFrontEndPlugin<void> = {
     app.commands.addCommand(CommandIDs.invokeNotebook, {
       execute: () => {
         const panel = notebooks.currentWidget;
-        if (panel && panel.content.activeCell.model.type === 'code') {
+        if (panel && panel.content.activeCell.type === 'code') {
           return app.commands.execute(CommandIDs.invoke, { id: panel.id });
         }
       }
@@ -261,9 +261,9 @@ const files: JupyterFrontEndPlugin<void> = {
     } = {};
 
     // When a new file editor is created, make the completer for it.
-    editorTracker.widgetAdded.connect((sender, widget) => {
+    editorTracker.widgetAdded.connect(async (sender, widget) => {
       const sessions = app.serviceManager.sessions;
-      const editor = widget.content.editor;
+      const editor = await widget.content.editor;
       const contextConnector = new ContextConnector({ editor });
 
       // When the list of running sessions changes,
diff --git a/packages/completer/package.json b/packages/completer/package.json
index cd1f8b4b8ad..25c32dd6173 100644
--- a/packages/completer/package.json
+++ b/packages/completer/package.json
@@ -38,6 +38,7 @@
     "@jupyterlab/apputils": "^1.0.1",
     "@jupyterlab/codeeditor": "^1.0.0",
     "@jupyterlab/coreutils": "^3.0.0",
+    "@jupyterlab/datastore": "^1.0.0",
     "@jupyterlab/services": "^4.0.1",
     "@phosphor/algorithm": "^1.1.3",
     "@phosphor/coreutils": "^1.3.1",
diff --git a/packages/completer/src/handler.ts b/packages/completer/src/handler.ts
index 4e783d85072..83ca71007fe 100644
--- a/packages/completer/src/handler.ts
+++ b/packages/completer/src/handler.ts
@@ -5,6 +5,8 @@ import { CodeEditor } from '@jupyterlab/codeeditor';
 
 import { IDataConnector, Text } from '@jupyterlab/coreutils';
 
+import { DatastoreExt } from '@jupyterlab/datastore';
+
 import { ReadonlyJSONObject, JSONObject, JSONArray } from '@phosphor/coreutils';
 
 import { IDisposable } from '@phosphor/disposable';
@@ -84,12 +86,16 @@ export class CompletionHandler implements IDisposable {
 
     // Clean up and disconnect from old editor.
     if (editor && !editor.isDisposed) {
-      const model = editor.model;
-
       editor.host.classList.remove(COMPLETER_ENABLED_CLASS);
       editor.host.classList.remove(COMPLETER_ACTIVE_CLASS);
-      model.selections.changed.disconnect(this.onSelectionsChanged, this);
-      model.value.changed.disconnect(this.onTextChanged, this);
+      if (this._selectionListener) {
+        this._selectionListener.dispose();
+        this._selectionListener = null;
+      }
+      if (this._textListener) {
+        this._textListener.dispose();
+        this._textListener = null;
+      }
     }
 
     // Reset completer state.
@@ -99,11 +105,21 @@ export class CompletionHandler implements IDisposable {
     // Update the editor and signal connections.
     editor = this._editor = newValue;
     if (editor) {
-      const model = editor.model;
+      const { datastore, record } = editor.model.data;
 
       this._enabled = false;
-      model.selections.changed.connect(this.onSelectionsChanged, this);
-      model.value.changed.connect(this.onTextChanged, this);
+      this._textListener = DatastoreExt.listenField(
+        datastore,
+        { ...record, field: 'text' },
+        this.onTextChanged,
+        this
+      );
+      this._selectionListener = DatastoreExt.listenField(
+        datastore,
+        { ...record, field: 'selections' },
+        this.onSelectionsChanged,
+        this
+      );
       // On initial load, manually check the cursor position.
       this.onSelectionsChanged();
     }
@@ -155,7 +171,7 @@ export class CompletionHandler implements IDisposable {
     position: CodeEditor.IPosition
   ): Completer.ITextState {
     return {
-      text: editor.model.value.text,
+      text: editor.model.value,
       lineHeight: editor.lineHeight,
       charWidth: editor.charWidth,
       line: position.line,
@@ -180,8 +196,14 @@ export class CompletionHandler implements IDisposable {
     }
 
     const { start, end, value } = patch;
-    editor.model.value.remove(start, end);
-    editor.model.value.insert(start, value);
+    const { datastore, record } = editor.model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'text' },
+        { index: start, remove: end - start, text: value }
+      );
+    });
   }
 
   /**
@@ -341,7 +363,7 @@ export class CompletionHandler implements IDisposable {
       return Promise.reject(new Error('No active editor'));
     }
 
-    const text = editor.model.value.text;
+    const text = editor.model.value;
     const offset = Text.jsIndexToCharIndex(editor.getOffsetAt(position), text);
     const pending = ++this._pending;
     const state = this.getState(editor, position);
@@ -445,6 +467,8 @@ export class CompletionHandler implements IDisposable {
   private _enabled = false;
   private _pending = 0;
   private _isDisposed = false;
+  private _textListener: IDisposable | null = null;
+  private _selectionListener: IDisposable | null = null;
 }
 
 /**
diff --git a/packages/completer/tsconfig.json b/packages/completer/tsconfig.json
index edad9823e33..2280a700be8 100644
--- a/packages/completer/tsconfig.json
+++ b/packages/completer/tsconfig.json
@@ -15,6 +15,9 @@
     {
       "path": "../coreutils"
     },
+    {
+      "path": "../datastore"
+    },
     {
       "path": "../services"
     }
diff --git a/packages/console/package.json b/packages/console/package.json
index cf53e00d243..a7e77761d6b 100644
--- a/packages/console/package.json
+++ b/packages/console/package.json
@@ -39,7 +39,9 @@
     "@jupyterlab/cells": "^1.0.1",
     "@jupyterlab/codeeditor": "^1.0.0",
     "@jupyterlab/coreutils": "^3.0.0",
+    "@jupyterlab/datastore": "^1.0.0",
     "@jupyterlab/observables": "^2.2.0",
+    "@jupyterlab/outputarea": "^1.0.1",
     "@jupyterlab/rendermime": "^1.0.1",
     "@jupyterlab/services": "^4.0.1",
     "@phosphor/algorithm": "^1.1.3",
diff --git a/packages/console/src/foreign.ts b/packages/console/src/foreign.ts
index 1b746cb308e..d891d2ee618 100644
--- a/packages/console/src/foreign.ts
+++ b/packages/console/src/foreign.ts
@@ -7,6 +7,10 @@ import { CodeCell } from '@jupyterlab/cells';
 
 import { nbformat } from '@jupyterlab/coreutils';
 
+import { DatastoreExt } from '@jupyterlab/datastore';
+
+import { OutputAreaData } from '@jupyterlab/outputarea';
+
 import { KernelMessage } from '@jupyterlab/services';
 
 import { IDisposable } from '@phosphor/disposable';
@@ -102,10 +106,18 @@ export class ForeignHandler implements IDisposable {
       case 'execute_input':
         let inputMsg = msg as KernelMessage.IExecuteInputMsg;
         cell = this._newCell(parentMsgId);
-        let model = cell.model;
-        model.executionCount = inputMsg.content.execution_count;
-        model.value.text = inputMsg.content.code;
-        model.trusted = true;
+        const { datastore, record } = cell.data;
+        DatastoreExt.withTransaction(datastore, () => {
+          DatastoreExt.updateRecord(datastore, record, {
+            executionCount: inputMsg.content.execution_count,
+            text: {
+              index: 0,
+              remove: cell.editor.model.value.length,
+              text: inputMsg.content.code
+            },
+            trusted: true
+          });
+        });
         parent.update();
         return true;
       case 'execute_result':
@@ -118,14 +130,23 @@ export class ForeignHandler implements IDisposable {
         }
         let output = msg.content as nbformat.IOutput;
         output.output_type = msgType as nbformat.OutputType;
-        cell.model.outputs.add(output);
+        if (this._clearNext) {
+          OutputAreaData.clear(cell.data);
+          this._clearNext = false;
+        } else {
+          OutputAreaData.appendItem(cell.data, output);
+        }
         parent.update();
         return true;
       case 'clear_output':
         let wait = (msg as KernelMessage.IClearOutputMsg).content.wait;
-        cell = this._parent.getCell(parentMsgId);
-        if (cell) {
-          cell.model.outputs.clear(wait);
+        if (wait) {
+          this._clearNext = true;
+        } else {
+          cell = this._parent.getCell(parentMsgId);
+          if (cell) {
+            OutputAreaData.clear(cell.data);
+          }
         }
         return true;
       default:
@@ -146,6 +167,7 @@ export class ForeignHandler implements IDisposable {
   private _enabled = false;
   private _parent: ForeignHandler.IReceiver;
   private _isDisposed = false;
+  private _clearNext = false;
 }
 
 /**
diff --git a/packages/console/src/history.ts b/packages/console/src/history.ts
index 39001027026..ad523a5b488 100644
--- a/packages/console/src/history.ts
+++ b/packages/console/src/history.ts
@@ -1,16 +1,18 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
+import { IClientSession } from '@jupyterlab/apputils';
+
+import { CodeEditor } from '@jupyterlab/codeeditor';
+
+import { DatastoreExt } from '@jupyterlab/datastore';
+
 import { KernelMessage } from '@jupyterlab/services';
 
 import { IDisposable } from '@phosphor/disposable';
 
 import { Signal } from '@phosphor/signaling';
 
-import { IClientSession } from '@jupyterlab/apputils';
-
-import { CodeEditor } from '@jupyterlab/codeeditor';
-
 /**
  * The definition of a console history manager object.
  */
@@ -99,17 +101,24 @@ export class ConsoleHistory implements IConsoleHistory {
       return;
     }
 
-    let prev = this._editor;
-    if (prev) {
-      prev.edgeRequested.disconnect(this.onEdgeRequest, this);
-      prev.model.value.changed.disconnect(this.onTextChange, this);
+    if (this._editor) {
+      this._editor.edgeRequested.disconnect(this.onEdgeRequest, this);
+    }
+    if (this._listener) {
+      this._listener.dispose();
+      this._listener = null;
     }
 
     this._editor = value;
 
     if (value) {
       value.edgeRequested.connect(this.onEdgeRequest, this);
-      value.model.value.changed.connect(this.onTextChange, this);
+      this._listener = DatastoreExt.listenField(
+        value.model.data.datastore,
+        { ...value.model.data.record, field: 'text' },
+        this.onTextChange,
+        this
+      );
     }
   }
 
@@ -255,18 +264,18 @@ export class ConsoleHistory implements IConsoleHistory {
     location: CodeEditor.EdgeLocation
   ): void {
     let model = editor.model;
-    let source = model.value.text;
+    let source = model.value;
 
     if (location === 'top' || location === 'topLine') {
       void this.back(source).then(value => {
         if (this.isDisposed || !value) {
           return;
         }
-        if (model.value.text === value) {
+        if (model.value === value) {
           return;
         }
         this._setByHistory = true;
-        model.value.text = value;
+        model.value = value;
         let columnPos = 0;
         columnPos = value.indexOf('\n');
         if (columnPos < 0) {
@@ -280,11 +289,11 @@ export class ConsoleHistory implements IConsoleHistory {
           return;
         }
         let text = value || this.placeholder;
-        if (model.value.text === text) {
+        if (model.value === text) {
           return;
         }
         this._setByHistory = true;
-        model.value.text = text;
+        model.value = text;
         let pos = editor.getPositionAt(text.length);
         if (pos) {
           editor.setCursorPosition(pos);
@@ -340,6 +349,7 @@ export class ConsoleHistory implements IConsoleHistory {
   private _setByHistory = false;
   private _isDisposed = false;
   private _editor: CodeEditor.IEditor | null = null;
+  private _listener: IDisposable = null;
   private _filtered: string[] = [];
 }
 
diff --git a/packages/console/src/panel.ts b/packages/console/src/panel.ts
index a3e8f34fc72..d00dae7d884 100644
--- a/packages/console/src/panel.ts
+++ b/packages/console/src/panel.ts
@@ -48,8 +48,7 @@ export class ConsolePanel extends Panel {
       path,
       basePath,
       name,
-      manager,
-      modelFactory
+      manager
     } = options;
     let contentFactory = (this.contentFactory =
       options.contentFactory || ConsolePanel.defaultContentFactory);
@@ -77,8 +76,7 @@ export class ConsolePanel extends Panel {
       rendermime,
       session,
       mimeTypeService,
-      contentFactory,
-      modelFactory
+      contentFactory
     });
     this.addWidget(this.console);
 
@@ -204,11 +202,6 @@ export namespace ConsolePanel {
      */
     kernelPreference?: IClientSession.IKernelPreference;
 
-    /**
-     * The model factory for the console widget.
-     */
-    modelFactory?: CodeConsole.IModelFactory;
-
     /**
      * The service used to look up mime types.
      */
diff --git a/packages/console/src/widget.ts b/packages/console/src/widget.ts
index f3d61071107..94c6d7e0438 100644
--- a/packages/console/src/widget.ts
+++ b/packages/console/src/widget.ts
@@ -6,20 +6,17 @@ import { IClientSession } from '@jupyterlab/apputils';
 import {
   Cell,
   CellDragUtils,
-  CellModel,
   CodeCell,
-  CodeCellModel,
-  ICodeCellModel,
-  isCodeCellModel,
-  IRawCellModel,
-  RawCell,
-  RawCellModel
+  CodeCellData,
+  RawCell
 } from '@jupyterlab/cells';
 
 import { IEditorMimeTypeService, CodeEditor } from '@jupyterlab/codeeditor';
 
 import { nbformat } from '@jupyterlab/coreutils';
 
+import { DatastoreExt } from '@jupyterlab/datastore';
+
 import { IObservableList, ObservableList } from '@jupyterlab/observables';
 
 import { IRenderMimeRegistry } from '@jupyterlab/rendermime';
@@ -116,7 +113,6 @@ export class CodeConsole extends Widget {
 
     this.contentFactory =
       options.contentFactory || CodeConsole.defaultContentFactory;
-    this.modelFactory = options.modelFactory || CodeConsole.defaultModelFactory;
     this.rendermime = options.rendermime;
     this.session = options.session;
     this._mimeTypeService = options.mimeTypeService;
@@ -157,11 +153,6 @@ export class CodeConsole extends Widget {
    */
   readonly contentFactory: CodeConsole.IContentFactory;
 
-  /**
-   * The model factory for the console widget.
-   */
-  readonly modelFactory: CodeConsole.IModelFactory;
-
   /**
    * The rendermime instance used by the console.
    */
@@ -227,12 +218,10 @@ export class CodeConsole extends Widget {
       cell.disposed.connect(this._onCellDisposed, this);
     }
     // Create the banner.
-    let model = this.modelFactory.createRawCell({});
-    model.value.text = '...';
     let banner = (this._banner = new RawCell({
-      model,
       contentFactory: this.contentFactory
-    })).initializeState();
+    }));
+    banner.editor.model.value = '...';
     banner.addClass(BANNER_CLASS);
     banner.readOnly = true;
     this._content.addWidget(banner);
@@ -257,7 +246,7 @@ export class CodeConsole extends Widget {
     let options = this._createCodeCellOptions();
     let cell = factory.createCodeCell(options);
     cell.readOnly = true;
-    cell.model.mimeType = this._mimetype;
+    cell.editor.model.mimeType = this._mimetype;
     return cell;
   }
 
@@ -296,7 +285,14 @@ export class CodeConsole extends Widget {
     if (!promptCell) {
       return Promise.reject('Cannot execute without a prompt cell');
     }
-    promptCell.model.trusted = true;
+    const { datastore, record } = promptCell.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'trusted' },
+        true
+      );
+    });
 
     if (force) {
       // Create a new prompt cell before kernel execution to allow typeahead.
@@ -339,10 +335,13 @@ export class CodeConsole extends Widget {
    */
   inject(code: string, metadata: JSONObject = {}): Promise<void> {
     let cell = this.createCodeCell();
-    cell.model.value.text = code;
-    for (let key of Object.keys(metadata)) {
-      cell.model.metadata.set(key, metadata[key]);
-    }
+    const { datastore, record } = cell.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateRecord(datastore, record, {
+        text: { index: 0, remove: 0, text: code },
+        metadata
+      });
+    });
     this.addCell(cell);
     return this._execute(cell);
   }
@@ -368,14 +367,13 @@ export class CodeConsole extends Widget {
   serialize(): nbformat.ICodeCell[] {
     const cells: nbformat.ICodeCell[] = [];
     each(this._cells, cell => {
-      let model = cell.model;
-      if (isCodeCellModel(model)) {
-        cells.push(model.toJSON());
+      if (cell.type === 'code') {
+        CodeCellData.toJSON(cell.data);
       }
     });
 
     if (this.promptCell) {
-      cells.push(this.promptCell.model.toJSON());
+      cells.push(CodeCellData.toJSON(this.promptCell.data));
     }
     return cells;
   }
@@ -463,8 +461,9 @@ export class CodeConsole extends Widget {
     clientX: number,
     clientY: number
   ): Promise<void> {
-    const cellModel = this._focusedCell.model as ICodeCellModel;
-    let selected: nbformat.ICell[] = [cellModel.toJSON()];
+    let selected: nbformat.ICell[] = [
+      CodeCellData.toJSON(this._focusedCell.data)
+    ];
 
     const dragImage = CellDragUtils.createCellDragImage(
       this._focusedCell,
@@ -480,7 +479,7 @@ export class CodeConsole extends Widget {
     });
 
     this._drag.mimeData.setData(JUPYTER_CELL_MIME, selected);
-    const textContent = cellModel.value.text;
+    const textContent = this._focusedCell.editor.model.value;
     this._drag.mimeData.setData('text/plain', textContent);
 
     this._focusedCell = null;
@@ -583,7 +582,7 @@ export class CodeConsole extends Widget {
     let factory = this.contentFactory;
     let options = this._createCodeCellOptions();
     promptCell = factory.createCodeCell(options);
-    promptCell.model.mimeType = this._mimetype;
+    promptCell.editor.model.mimeType = this._mimetype;
     promptCell.addClass(PROMPT_CLASS);
     this._input.addWidget(promptCell);
 
@@ -632,7 +631,7 @@ export class CodeConsole extends Widget {
    * Execute the code in the current prompt cell.
    */
   private _execute(cell: CodeCell): Promise<void> {
-    let source = cell.model.value.text;
+    let source = cell.editor.model.value;
     this._history.push(source);
     // If the source of the console is just "clear", clear the console as we
     // do in IPython or QtConsole.
@@ -640,7 +639,13 @@ export class CodeConsole extends Widget {
       this.clear();
       return Promise.resolve(void 0);
     }
-    cell.model.contentChanged.connect(this.update, this);
+    const { datastore, record } = cell.data;
+    const listener = DatastoreExt.listenRecord(
+      datastore,
+      record,
+      this.update,
+      this
+    );
     let onSuccess = (value: KernelMessage.IExecuteReplyMsg) => {
       if (this.isDisposed) {
         return;
@@ -655,17 +660,21 @@ export class CodeConsole extends Widget {
           if (setNextInput) {
             let text = (setNextInput as any).text;
             // Ignore the `replace` value and always set the next cell.
-            cell.model.value.text = text;
+            cell.editor.model.value = text;
           }
         }
       } else if (value && value.content.status === 'error') {
         each(this._cells, (cell: CodeCell) => {
-          if (cell.model.executionCount === null) {
+          const executionCount = DatastoreExt.getField(cell.data.datastore, {
+            ...cell.data.record,
+            field: 'executionCount'
+          });
+          if (executionCount === null) {
             cell.setPrompt('');
           }
         });
       }
-      cell.model.contentChanged.disconnect(this.update, this);
+      listener.dispose();
       this.update();
       this._executed.emit(new Date());
     };
@@ -673,7 +682,7 @@ export class CodeConsole extends Widget {
       if (this.isDisposed) {
         return;
       }
-      cell.model.contentChanged.disconnect(this.update, this);
+      listener.dispose();
       this.update();
     };
     return CodeCell.execute(cell, this.session).then(onSuccess, onFailure);
@@ -684,14 +693,14 @@ export class CodeConsole extends Widget {
    */
   private _handleInfo(info: KernelMessage.IInfoReplyMsg['content']): void {
     if (info.status !== 'ok') {
-      this._banner.model.value.text = 'Error in getting kernel banner';
+      this._banner.editor.model.value = 'Error in getting kernel banner';
       return;
     }
-    this._banner.model.value.text = info.banner;
+    this._banner.editor.model.value = info.banner;
     let lang = info.language_info as nbformat.ILanguageInfoMetadata;
     this._mimetype = this._mimeTypeService.getMimeTypeByLanguage(lang);
     if (this.promptCell) {
-      this.promptCell.model.mimeType = this._mimetype;
+      this.promptCell.editor.model.mimeType = this._mimetype;
     }
   }
 
@@ -700,10 +709,8 @@ export class CodeConsole extends Widget {
    */
   private _createCodeCellOptions(): CodeCell.IOptions {
     let contentFactory = this.contentFactory;
-    let modelFactory = this.modelFactory;
-    let model = modelFactory.createCodeCell({});
     let rendermime = this.rendermime;
-    return { model, rendermime, contentFactory };
+    return { rendermime, contentFactory };
   }
 
   /**
@@ -728,8 +735,7 @@ export class CodeConsole extends Widget {
     if (!promptCell) {
       return Promise.resolve(false);
     }
-    let model = promptCell.model;
-    let code = model.value.text;
+    let code = promptCell.editor.model.value;
     return new Promise<boolean>((resolve, reject) => {
       let timer = setTimeout(() => {
         resolve(true);
@@ -833,11 +839,6 @@ export namespace CodeConsole {
      */
     contentFactory: IContentFactory;
 
-    /**
-     * The model factory for the console widget.
-     */
-    modelFactory?: IModelFactory;
-
     /**
      * The mime renderer for the console widget.
      */
@@ -917,98 +918,6 @@ export namespace CodeConsole {
    * A default content factory for the code console.
    */
   export const defaultContentFactory: IContentFactory = new ContentFactory();
-
-  /**
-   * A model factory for a console widget.
-   */
-  export interface IModelFactory {
-    /**
-     * The factory for code cell content.
-     */
-    readonly codeCellContentFactory: CodeCellModel.IContentFactory;
-
-    /**
-     * Create a new code cell.
-     *
-     * @param options - The options used to create the cell.
-     *
-     * @returns A new code cell. If a source cell is provided, the
-     *   new cell will be initialized with the data from the source.
-     */
-    createCodeCell(options: CodeCellModel.IOptions): ICodeCellModel;
-
-    /**
-     * Create a new raw cell.
-     *
-     * @param options - The options used to create the cell.
-     *
-     * @returns A new raw cell. If a source cell is provided, the
-     *   new cell will be initialized with the data from the source.
-     */
-    createRawCell(options: CellModel.IOptions): IRawCellModel;
-  }
-
-  /**
-   * The default implementation of an `IModelFactory`.
-   */
-  export class ModelFactory {
-    /**
-     * Create a new cell model factory.
-     */
-    constructor(options: IModelFactoryOptions = {}) {
-      this.codeCellContentFactory =
-        options.codeCellContentFactory || CodeCellModel.defaultContentFactory;
-    }
-
-    /**
-     * The factory for output area models.
-     */
-    readonly codeCellContentFactory: CodeCellModel.IContentFactory;
-
-    /**
-     * Create a new code cell.
-     *
-     * @param source - The data to use for the original source data.
-     *
-     * @returns A new code cell. If a source cell is provided, the
-     *   new cell will be initialized with the data from the source.
-     *   If the contentFactory is not provided, the instance
-     *   `codeCellContentFactory` will be used.
-     */
-    createCodeCell(options: CodeCellModel.IOptions): ICodeCellModel {
-      if (!options.contentFactory) {
-        options.contentFactory = this.codeCellContentFactory;
-      }
-      return new CodeCellModel(options);
-    }
-
-    /**
-     * Create a new raw cell.
-     *
-     * @param source - The data to use for the original source data.
-     *
-     * @returns A new raw cell. If a source cell is provided, the
-     *   new cell will be initialized with the data from the source.
-     */
-    createRawCell(options: CellModel.IOptions): IRawCellModel {
-      return new RawCellModel(options);
-    }
-  }
-
-  /**
-   * The options used to initialize a `ModelFactory`.
-   */
-  export interface IModelFactoryOptions {
-    /**
-     * The factory for output area models.
-     */
-    codeCellContentFactory?: CodeCellModel.IContentFactory;
-  }
-
-  /**
-   * The default `ModelFactory` instance.
-   */
-  export const defaultModelFactory = new ModelFactory({});
 }
 
 /**
diff --git a/packages/console/style/index.css b/packages/console/style/index.css
index 192a269ffd7..c0e2d26bce3 100644
--- a/packages/console/style/index.css
+++ b/packages/console/style/index.css
@@ -9,6 +9,7 @@
 @import url('~@phosphor/dragdrop/style/index.css');
 @import url('~@jupyterlab/codeeditor/style/index.css');
 @import url('~@jupyterlab/rendermime/style/index.css');
+@import url('~@jupyterlab/outputarea/style/index.css');
 @import url('~@jupyterlab/cells/style/index.css');
 
 @import url('./base.css');
diff --git a/packages/console/tsconfig.json b/packages/console/tsconfig.json
index 5ad754f1cd7..12612f0a093 100644
--- a/packages/console/tsconfig.json
+++ b/packages/console/tsconfig.json
@@ -18,9 +18,15 @@
     {
       "path": "../coreutils"
     },
+    {
+      "path": "../datastore"
+    },
     {
       "path": "../observables"
     },
+    {
+      "path": "../outputarea"
+    },
     {
       "path": "../rendermime"
     },
diff --git a/packages/coreutils/src/pageconfig.ts b/packages/coreutils/src/pageconfig.ts
index e84050ffe37..25d9fa0424b 100644
--- a/packages/coreutils/src/pageconfig.ts
+++ b/packages/coreutils/src/pageconfig.ts
@@ -132,6 +132,13 @@ export namespace PageConfig {
     return URLExt.normalize(wsUrl);
   }
 
+  /**
+   * Get the unique store ID.
+   */
+  export function getStoreID(): number {
+    return Number(getOption('store_id'));
+  }
+
   /**
    * Returns the URL converting this notebook to a certain
    * format with nbconvert.
diff --git a/packages/csvviewer-extension/src/index.ts b/packages/csvviewer-extension/src/index.ts
index db69d577375..60a3519cd64 100644
--- a/packages/csvviewer-extension/src/index.ts
+++ b/packages/csvviewer-extension/src/index.ts
@@ -86,6 +86,7 @@ function activateCsv(
 ): void {
   const factory = new CSVViewerFactory({
     name: FACTORY_CSV,
+    modelName: 'string',
     fileTypes: ['csv'],
     defaultFor: ['csv'],
     readOnly: true
@@ -156,6 +157,7 @@ function activateTsv(
 ): void {
   const factory = new TSVViewerFactory({
     name: FACTORY_TSV,
+    modelName: 'string',
     fileTypes: ['tsv'],
     defaultFor: ['tsv'],
     readOnly: true
diff --git a/packages/datastore-extension/package.json b/packages/datastore-extension/package.json
new file mode 100644
index 00000000000..b1d883b2911
--- /dev/null
+++ b/packages/datastore-extension/package.json
@@ -0,0 +1,53 @@
+{
+  "name": "@jupyterlab/datastore-extension",
+  "version": "1.0.0",
+  "description": "JupyterLab - Datastore Extension",
+  "homepage": "https://github.com/jupyterlab/jupyterlab",
+  "bugs": {
+    "url": "https://github.com/jupyterlab/jupyterlab/issues"
+  },
+  "repository": {
+    "type": "git",
+    "url": "https://github.com/jupyterlab/jupyterlab.git"
+  },
+  "license": "BSD-3-Clause",
+  "author": "Project Jupyter",
+  "files": [
+    "lib/**/*.{d.ts,eot,gif,html,jpg,js,js.map,json,png,svg,woff2,ttf}",
+    "schema/*.json",
+    "style/**/*.{css,eot,gif,html,jpg,json,png,svg,woff2,ttf}"
+  ],
+  "sideEffects": [
+    "style/**/*"
+  ],
+  "main": "lib/index.js",
+  "types": "lib/index.d.ts",
+  "directories": {
+    "lib": "lib/"
+  },
+  "scripts": {
+    "build": "tsc",
+    "clean": "rimraf lib",
+    "prepublishOnly": "npm run build",
+    "watch": "tsc -w --listEmittedFiles"
+  },
+  "dependencies": {
+    "@jupyterlab/application": "^1.0.1",
+    "@jupyterlab/apputils": "^1.0.1",
+    "@jupyterlab/datastore": "^1.0.0",
+    "@phosphor/algorithm": "^1.1.3",
+    "@phosphor/coreutils": "^1.3.1",
+    "@phosphor/datastore": "0.7.2",
+    "react": "~16.8.4"
+  },
+  "devDependencies": {
+    "rimraf": "~2.6.2",
+    "typescript": "~3.5.1"
+  },
+  "publishConfig": {
+    "access": "public"
+  },
+  "jupyterlab": {
+    "extension": true
+  }
+}
diff --git a/packages/datastore-extension/src/index.ts b/packages/datastore-extension/src/index.ts
new file mode 100644
index 00000000000..70a0483ea2e
--- /dev/null
+++ b/packages/datastore-extension/src/index.ts
@@ -0,0 +1,4 @@
+import todoPlugin from './todo';
+import { JupyterFrontEndPlugin } from '@jupyterlab/application';
+
+export default [todoPlugin] as Array<JupyterFrontEndPlugin<any>>;
diff --git a/packages/datastore-extension/src/todo.tsx b/packages/datastore-extension/src/todo.tsx
new file mode 100644
index 00000000000..ddea99e70fb
--- /dev/null
+++ b/packages/datastore-extension/src/todo.tsx
@@ -0,0 +1,164 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import {
+  JupyterFrontEndPlugin,
+  ILayoutRestorer,
+  JupyterFrontEnd
+} from '@jupyterlab/application';
+import { createDatastore } from '@jupyterlab/datastore';
+import {
+  ICommandPalette,
+  MainAreaWidget,
+  ReactWidget,
+  WidgetTracker,
+  UseSignal
+} from '@jupyterlab/apputils';
+import { Fields, Datastore } from '@phosphor/datastore';
+import * as React from 'react';
+import { toArray } from '@phosphor/algorithm';
+import { UUID } from '@phosphor/coreutils';
+
+type TODOState = {
+  datastore: Datastore | undefined;
+};
+
+const TODOSchema = {
+  id: 'todo',
+  fields: {
+    description: Fields.Text(),
+    show: Fields.Boolean({ value: true })
+  }
+};
+
+class TODO extends React.Component<{}, TODOState> {
+  readonly state: TODOState = {
+    datastore: undefined
+  };
+
+  input = React.createRef<HTMLInputElement>();
+
+  async componentDidMount() {
+    const datastore = await createDatastore('todo', [TODOSchema]);
+    this.setState({ datastore });
+  }
+  render() {
+    const { datastore } = this.state;
+    if (!datastore) {
+      return <div>Loading...</div>;
+    }
+    const table = datastore.get(TODOSchema);
+    return (
+      <div>
+        <h1>TODO</h1>
+        <ol>
+          <UseSignal signal={datastore.changed}>
+            {() =>
+              toArray(table.iter()).map(row =>
+                row.show ? (
+                  <li id={row.$id}>
+                    {row.description}
+                    <button
+                      onClick={event => {
+                        datastore.beginTransaction();
+                        table.update({
+                          [row.$id]: { show: false }
+                        });
+                        datastore.endTransaction();
+                        event.preventDefault();
+                      }}
+                    >
+                      Remove
+                    </button>
+                  </li>
+                ) : (
+                  <></>
+                )
+              )
+            }
+          </UseSignal>
+        </ol>
+        <form
+          onSubmit={e => {
+            datastore.beginTransaction();
+            table.update({
+              [UUID.uuid4()]: {
+                description: {
+                  index: 0,
+                  remove: 0,
+                  text: this.input.current.value
+                }
+              }
+            });
+            datastore.endTransaction();
+            e.preventDefault();
+          }}
+        >
+          <label>
+            Task:
+            <input type="text" ref={this.input} />
+          </label>
+          <input type="submit" value="Add" />
+        </form>
+      </div>
+    );
+  }
+
+  componentWillUnmount() {
+    this.state.datastore && this.state.datastore.dispose();
+  }
+}
+
+export default {
+  id: '@jupyterlab/datastore-extension:todo-plugin',
+  requires: [ILayoutRestorer, ICommandPalette],
+  autoStart: true,
+  activate: (
+    app: JupyterFrontEnd,
+    restorer: ILayoutRestorer,
+    palette: ICommandPalette
+  ) => {
+    // Declare a widget variable
+    let widget: MainAreaWidget<ReactWidget>;
+
+    // Add an application command
+    const command: string = 'todo:open';
+    app.commands.addCommand(command, {
+      label: 'Open TODO',
+      execute: async () => {
+        if (!widget) {
+          // Create a new widget if one does not exist
+          const content = ReactWidget.create(<TODO />);
+          widget = new MainAreaWidget({ content });
+          widget.id = 'todo';
+          widget.title.label = 'TODO';
+          widget.title.closable = true;
+        }
+        if (!tracker.has(widget)) {
+          // Track the state of the widget for later restoration
+          await tracker.add(widget);
+        }
+        if (!widget.isAttached) {
+          // Attach the widget to the main work area if it's not there
+          app.shell.add(widget, 'main');
+        }
+        widget.content.update();
+
+        // Activate the widget
+        app.shell.activateById(widget.id);
+      }
+    });
+
+    // Add the command to the palette.
+    palette.addItem({ command, category: 'TODO' });
+
+    // Track and restore the widget state
+    let tracker = new WidgetTracker<MainAreaWidget<ReactWidget>>({
+      namespace: 'todo'
+    });
+    void restorer.restore(tracker, {
+      command,
+      name: () => 'todo'
+    });
+  }
+} as JupyterFrontEndPlugin<void>;
diff --git a/packages/datastore-extension/tdoptions.json b/packages/datastore-extension/tdoptions.json
new file mode 100644
index 00000000000..aba75aa7c53
--- /dev/null
+++ b/packages/datastore-extension/tdoptions.json
@@ -0,0 +1,20 @@
+{
+  "excludeNotExported": true,
+  "mode": "file",
+  "target": "es5",
+  "module": "es5",
+  "lib": [
+    "lib.es2015.d.ts",
+    "lib.es2015.collection.d.ts",
+    "lib.es2015.promise.d.ts",
+    "lib.dom.d.ts"
+  ],
+  "out": "../../docs/api/datastore-extension",
+  "baseUrl": ".",
+  "paths": {
+    "@jupyterlab/*": ["../packages/*"]
+  },
+  "esModuleInterop": true,
+  "jsx": "react",
+  "types": []
+}
diff --git a/packages/datastore-extension/tsconfig.json b/packages/datastore-extension/tsconfig.json
new file mode 100644
index 00000000000..6acf0be8e6c
--- /dev/null
+++ b/packages/datastore-extension/tsconfig.json
@@ -0,0 +1,19 @@
+{
+  "extends": "../../tsconfigbase",
+  "compilerOptions": {
+    "outDir": "lib",
+    "rootDir": "src"
+  },
+  "include": ["src/*"],
+  "references": [
+    {
+      "path": "../application"
+    },
+    {
+      "path": "../apputils"
+    },
+    {
+      "path": "../datastore"
+    }
+  ]
+}
diff --git a/packages/datastore/package.json b/packages/datastore/package.json
new file mode 100644
index 00000000000..ae1c416f102
--- /dev/null
+++ b/packages/datastore/package.json
@@ -0,0 +1,50 @@
+{
+  "name": "@jupyterlab/datastore",
+  "version": "1.0.0",
+  "description": "JupyterLab - Datastore",
+  "homepage": "https://github.com/jupyterlab/jupyterlab",
+  "bugs": {
+    "url": "https://github.com/jupyterlab/jupyterlab/issues"
+  },
+  "repository": {
+    "type": "git",
+    "url": "https://github.com/jupyterlab/jupyterlab.git"
+  },
+  "license": "BSD-3-Clause",
+  "author": "Project Jupyter",
+  "files": [
+    "lib/**/*.{d.ts,eot,gif,html,jpg,js,js.map,json,png,svg,woff2,ttf}",
+    "schema/*.json",
+    "style/**/*.{css,eot,gif,html,jpg,json,png,svg,woff2,ttf}"
+  ],
+  "sideEffects": [
+    "style/**/*"
+  ],
+  "main": "lib/index.js",
+  "types": "lib/index.d.ts",
+  "directories": {
+    "lib": "lib/"
+  },
+  "scripts": {
+    "build": "tsc",
+    "clean": "rimraf lib",
+    "prepublishOnly": "npm run build",
+    "watch": "tsc -w --listEmittedFiles"
+  },
+  "dependencies": {
+    "@jupyterlab/coreutils": "^3.0.0",
+    "@jupyterlab/services": "^4.0.1",
+    "@phosphor/algorithm": "^1.1.3",
+    "@phosphor/coreutils": "^1.3.1",
+    "@phosphor/datastore": "0.7.2",
+    "@phosphor/disposable": "^1.2.0",
+    "@phosphor/messaging": "^1.2.3"
+  },
+  "devDependencies": {
+    "rimraf": "~2.6.2",
+    "typescript": "~3.5.1"
+  },
+  "publishConfig": {
+    "access": "public"
+  }
+}
diff --git a/packages/datastore/src/client.ts b/packages/datastore/src/client.ts
new file mode 100644
index 00000000000..30652d682f1
--- /dev/null
+++ b/packages/datastore/src/client.ts
@@ -0,0 +1,377 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import { URLExt } from '@jupyterlab/coreutils';
+
+import { PromiseDelegate } from '@phosphor/coreutils';
+
+import { Datastore } from '@phosphor/datastore';
+
+import { IMessageHandler, Message, MessageLoop } from '@phosphor/messaging';
+
+import { ServerConnection, WSConnection } from '@jupyterlab/services';
+
+import { Collaboration } from './wsmessages';
+
+/**
+ * The url for the datastore service.
+ */
+const DATASTORE_SERVICE_URL = 'lab/api/datastore';
+
+/**
+ * The default treshold for idle time, in seconds.
+ */
+const DEFAULT_IDLE_TIME = 3;
+
+/**
+ * A class that manages exchange of transactions with the collaboration server.
+ */
+export class CollaborationClient extends WSConnection<
+  Collaboration.Message,
+  Collaboration.Message
+> {
+  /**
+   * Create a new collaboration client connection.
+   */
+  constructor(options: CollaborationClient.IOptions = {}) {
+    super();
+    this.collaborationId = options.collaborationId;
+    this._idleTreshold = 1000 * (options.idleTreshold || DEFAULT_IDLE_TIME);
+    this.serverSettings =
+      options.serverSettings || ServerConnection.makeSettings();
+    this._createSocket();
+  }
+
+  /**
+   * The permissions for the current use on the datastore session.
+   */
+  get permissions(): Promise<CollaborationClient.Permissions> {
+    return Promise.resolve().then(async () => {
+      await this.ready;
+      const msg = Collaboration.createMessage('permissions-request', {});
+      const reply = await this._requestMessageReply(msg);
+      return reply.content;
+    });
+  }
+
+  processMessage(msg: Message) {
+    if (msg.type === 'datastore-transaction') {
+      this.broadcastTransactions([
+        (msg as Datastore.TransactionMessage).transaction
+      ]);
+      return;
+    }
+    throw new Error(
+      `CollaborationClient cannot process message type ${msg.type}`
+    );
+  }
+  /**
+   * Broadcast transactions to all datastores.
+   *
+   * @param transactions - The transactions to broadcast.
+   * @returns An array of acknowledged transactionIds from the server.
+   */
+  broadcastTransactions(transactions: Datastore.Transaction[]): void {
+    // Brand outgoing transactions with our serial
+    const branded = [];
+    for (let t of transactions) {
+      const b = { ...t, serial: this._ourSerial++ };
+      branded.push(b);
+      this._pendingTransactions[b.id] = b;
+    }
+    this._resetIdleTimer();
+    const msg = Collaboration.createMessage('transaction-broadcast', {
+      transactions: branded
+    });
+    this._requestMessageReply(msg).then(
+      reply => {
+        const { serials, transactionIds } = reply.content;
+        for (let i = 0; i < serials.length; ++i) {
+          const serial = serials[i];
+          const id = transactionIds[i];
+          delete this._pendingTransactions[id];
+          if (serial !== this._serverSerial + 1) {
+            // Out of order serials!
+            // Something has gone wrong somewhere.
+            // TODO: Trigger recovery?
+            throw new Error(
+              'Critical! Out of order transactions in datastore.'
+            );
+          }
+          this._serverSerial = serial;
+        }
+        this._resetIdleTimer();
+      },
+      () => {
+        // TODO: Resend transactions
+      }
+    );
+  }
+
+  /**
+   * Request the complete history of the datastore.
+   *
+   * The transactions of the history will be sent to the set handler.
+   */
+  async replayHistory(checkpointId?: number): Promise<boolean> {
+    const msg = Collaboration.createMessage('history-request', {
+      checkpointId: checkpointId === undefined ? null : checkpointId
+    });
+    const response = await this._requestMessageReply(msg);
+    if (!response.content.transactions.length) {
+      return false;
+    }
+    this._handleTransactions(response.content.transactions);
+    return true;
+  }
+
+  /**
+   * The server settings for the session.
+   */
+  readonly serverSettings: ServerConnection.ISettings;
+
+  /**
+   * The id of the collaboration.
+   */
+  readonly collaborationId: string | undefined;
+
+  /**
+   * The message handler of any data messages.
+   */
+  public handler: IMessageHandler | null;
+
+  /**
+   * Factory method for creating the web socket object.
+   */
+  protected wsFactory() {
+    const settings = this.serverSettings;
+    const token = this.serverSettings.token;
+    const queryParams = [];
+
+    let wsUrl;
+    if (this.collaborationId) {
+      wsUrl = URLExt.join(
+        settings.wsUrl,
+        DATASTORE_SERVICE_URL,
+        this.collaborationId
+      );
+    } else {
+      wsUrl = URLExt.join(settings.wsUrl, DATASTORE_SERVICE_URL);
+    }
+
+    if (token) {
+      queryParams.push(`token=${encodeURIComponent(token)}`);
+    }
+    if (queryParams) {
+      wsUrl = wsUrl + `?${queryParams.join('&')}`;
+    }
+
+    return new settings.WebSocket(wsUrl);
+  }
+
+  /**
+   * Handler for deserialized websocket messages.
+   */
+  protected handleMessage(
+    msg:
+      | Collaboration.RawReply
+      | Collaboration.TransactionBroadcast
+      | Collaboration.StableStateNotice
+  ): boolean {
+    try {
+      // TODO: Write a validator?
+      // validate.validateMessage(msg);
+    } catch (error) {
+      console.error(`Invalid message: ${error.message}`);
+      return false;
+    }
+
+    if (Collaboration.isReply(msg)) {
+      let delegate = this._delegates && this._delegates.get(msg.parentId!);
+      if (delegate) {
+        if (msg.msgType === 'error-reply') {
+          console.warn('Received datastore error from server', msg.content);
+          delegate.reject(msg.content.reason);
+        } else {
+          delegate.resolve(msg);
+        }
+        return true;
+      }
+    }
+    if (msg.msgType === 'transaction-broadcast') {
+      this._handleTransactions(msg.content.transactions);
+    } else if (msg.msgType === 'state-stable') {
+      // TODO: Possibly signal a chance for garbage collection.
+    } else {
+      return false;
+    }
+    return true;
+  }
+
+  /**
+   * Process transactions received over the websocket.
+   */
+  private _handleTransactions(
+    transactions: ReadonlyArray<Collaboration.SerialTransaction>
+  ) {
+    if (!this.handler) {
+      return;
+    }
+    for (let t of transactions) {
+      if (t.serial !== this._serverSerial + 1) {
+        // Out of order serials!
+        // Something has gone wrong somewhere.
+        // TODO: Trigger recovery?
+        throw new Error('Critical! Out of order transactions in datastore.');
+      }
+      this._serverSerial = t.serial;
+      MessageLoop.sendMessage(
+        this.handler,
+        new Datastore.TransactionMessage(t)
+      );
+    }
+    this._resetIdleTimer();
+  }
+
+  /**
+   * Send a message to the server and resolve the reply message.
+   */
+  private _requestMessageReply<T extends Collaboration.Request>(
+    msg: T,
+    timeout = 0
+  ): Promise<Collaboration.IReplyMap[T['msgType']]> {
+    const delegate = new PromiseDelegate<
+      Collaboration.IReplyMap[T['msgType']]
+    >();
+    this._delegates.set(msg.msgId, delegate);
+
+    // .finally(), delete from delegate map
+    const promise = delegate.promise.then(
+      reply => {
+        this._delegates.delete(msg.msgId);
+        return reply;
+      },
+      reason => {
+        this._delegates.delete(msg.msgId);
+        throw reason;
+      }
+    );
+
+    if (timeout > 0) {
+      setTimeout(() => {
+        delegate.reject('Timed out waiting for reply');
+      }, timeout);
+    }
+
+    this.sendMessage(msg);
+
+    return promise;
+  }
+
+  /**
+   * Callback called when idle after activity.
+   */
+  private _onIdle() {
+    const msg = Collaboration.createMessage('serial-update', {
+      serial: this._serverSerial
+    });
+    this.sendMessage(msg);
+    this._idleTimer = null;
+  }
+
+  /**
+   * Reset the idle timer.
+   */
+  private _resetIdleTimer() {
+    if (this._idleTimer !== null) {
+      clearTimeout(this._idleTimer);
+    }
+    this._idleTimer = setTimeout(this._onIdle.bind(this), this._idleTreshold);
+  }
+
+  private _delegates = new Map<string, PromiseDelegate<Collaboration.Reply>>();
+
+  private _ourSerial = 0;
+  private _serverSerial = 0;
+  private _pendingTransactions: Collaboration.SerialTransactionMap = {};
+
+  private _idleTreshold: number;
+  private _idleTimer: number | null = null;
+}
+
+/**
+ *
+ */
+export namespace CollaborationClient {
+  export interface IOptions {
+    /**
+     * The id of the collaboration to connect to.
+     */
+    collaborationId?: string;
+
+    /**
+     * The server settings for the session.
+     */
+    serverSettings?: ServerConnection.ISettings;
+
+    /**
+     * How long to wait before the session is considered idle, in seconds.
+     */
+    idleTreshold?: number;
+  }
+
+  /**
+   * A message class for `'remote-transactions'` messages.
+   */
+  export class RemoteTransactionMessage extends Message {
+    /**
+     * Construct a new remote transactions message.
+     *
+     * @param transaction - The transaction object
+     */
+    constructor(transaction: Datastore.Transaction) {
+      super('remote-transactions');
+      this.transaction = transaction;
+    }
+
+    /**
+     * The patch object.
+     */
+    readonly transaction: Datastore.Transaction;
+  }
+
+  /**
+   * A message class for initial state messages.
+   */
+  export class InitialStateMessage extends Message {
+    /**
+     * Construct a new initial state message.
+     *
+     * @param state - he serialized state
+     */
+    constructor(state: string | null) {
+      super('initial-state');
+      this.state = state;
+    }
+
+    /**
+     * The serialized state.
+     */
+    readonly state: string | null;
+  }
+
+  /**
+   * Datastore permissions object.
+   */
+  export type Permissions = {
+    /**
+     * Whether the current user can read from the datastore session.
+     */
+    read: boolean;
+
+    /**
+     * Whether the current user can write to the datastore session.
+     */
+    write: boolean;
+  };
+}
diff --git a/packages/datastore/src/index.ts b/packages/datastore/src/index.ts
new file mode 100644
index 00000000000..7b913fc1c67
--- /dev/null
+++ b/packages/datastore/src/index.ts
@@ -0,0 +1,7 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+export * from './client';
+export * from './manager';
+export * from './rest';
+export * from './util';
diff --git a/packages/datastore/src/manager.ts b/packages/datastore/src/manager.ts
new file mode 100644
index 00000000000..7b7cab61248
--- /dev/null
+++ b/packages/datastore/src/manager.ts
@@ -0,0 +1,27 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import { Schema, Datastore } from '@phosphor/datastore';
+
+import { CollaborationClient } from './client';
+import { PageConfig } from '@jupyterlab/coreutils';
+
+export async function createDatastore(
+  collaborationId: string,
+  schemas: ReadonlyArray<Schema>
+): Promise<Datastore> {
+  const client = new CollaborationClient({
+    collaborationId: collaborationId
+  });
+  const datastore = Datastore.create({
+    id: PageConfig.getStoreID(),
+    schemas: schemas,
+    // Pass in client as handler, so it can recieve local changes
+    broadcastHandler: client
+  });
+  client.handler = datastore;
+  // Wait for websocket connection to be ready
+  await client.ready;
+  await client.replayHistory();
+  return datastore;
+}
diff --git a/packages/datastore/src/objiter.ts b/packages/datastore/src/objiter.ts
new file mode 100644
index 00000000000..ce955b9def9
--- /dev/null
+++ b/packages/datastore/src/objiter.ts
@@ -0,0 +1,273 @@
+/*-----------------------------------------------------------------------------
+| Copyright (c) 2014-2017, PhosphorJS Contributors
+|
+| Distributed under the terms of the BSD 3-Clause License.
+|
+| The full license is in the file LICENSE, distributed with this software.
+|----------------------------------------------------------------------------*/
+
+import { IIterator } from '@phosphor/algorithm';
+
+/**
+ * Create an iterator for the keys in an object.
+ *
+ * @param object - The object of interest.
+ *
+ * @returns A new iterator for the keys in the given object.
+ *
+ * #### Complexity
+ * Linear.
+ *
+ * #### Example
+ * ```typescript
+ * import { each, keys } from '@phosphor/algorithm';
+ *
+ * let data = { one: 1, two: 2, three: 3 };
+ *
+ * each(keys(data), key => { console.log(key); }); // 'one', 'two', 'three'
+ * ```
+ */
+export function iterKeys<T>(object: {
+  readonly [key: string]: T;
+}): IIterator<string> {
+  return new KeyIterator(object);
+}
+
+/**
+ * Create an iterator for the values in an object.
+ *
+ * @param object - The object of interest.
+ *
+ * @returns A new iterator for the values in the given object.
+ *
+ * #### Complexity
+ * Linear.
+ *
+ * #### Example
+ * ```typescript
+ * import { each, values } from '@phosphor/algorithm';
+ *
+ * let data = { one: 1, two: 2, three: 3 };
+ *
+ * each(values(data), value => { console.log(value); }); // 1, 2, 3
+ * ```
+ */
+export function iterValues<T>(object: {
+  readonly [key: string]: T;
+}): IIterator<T> {
+  return new ValueIterator<T>(object);
+}
+
+/**
+ * Create an iterator for the items in an object.
+ *
+ * @param object - The object of interest.
+ *
+ * @returns A new iterator for the items in the given object.
+ *
+ * #### Complexity
+ * Linear.
+ *
+ * #### Example
+ * ```typescript
+ * import { each, items } from '@phosphor/algorithm';
+ *
+ * let data = { one: 1, two: 2, three: 3 };
+ *
+ * each(items(data), value => { console.log(value); }); // ['one', 1], ['two', 2], ['three', 3]
+ * ```
+ */
+export function iterItems<T>(object: {
+  readonly [key: string]: T;
+}): IIterator<[string, T]> {
+  return new ItemIterator<T>(object);
+}
+
+/**
+ * An iterator for the keys in an object.
+ *
+ * #### Notes
+ * This iterator can be used for any JS object.
+ */
+export class KeyIterator implements IIterator<string> {
+  /**
+   * Construct a new key iterator.
+   *
+   * @param source - The object of interest.
+   *
+   * @param keys - The keys to iterate, if known.
+   */
+  constructor(
+    source: { readonly [key: string]: any },
+    keys = Object.keys(source)
+  ) {
+    this._source = source;
+    this._keys = keys;
+  }
+
+  /**
+   * Get an iterator over the object's values.
+   *
+   * @returns An iterator which yields the object's values.
+   */
+  iter(): IIterator<string> {
+    return this;
+  }
+
+  /**
+   * Create an independent clone of the iterator.
+   *
+   * @returns A new independent clone of the iterator.
+   */
+  clone(): IIterator<string> {
+    let result = new KeyIterator(this._source, this._keys);
+    result._index = this._index;
+    return result;
+  }
+
+  /**
+   * Get the next value from the iterator.
+   *
+   * @returns The next value from the iterator, or `undefined`.
+   */
+  next(): string | undefined {
+    if (this._index >= this._keys.length) {
+      return undefined;
+    }
+    let key = this._keys[this._index++];
+    if (key in this._source) {
+      return key;
+    }
+    return this.next();
+  }
+
+  private _index = 0;
+  private _keys: string[];
+  private _source: { readonly [key: string]: any };
+}
+
+/**
+ * An iterator for the values in an object.
+ *
+ * #### Notes
+ * This iterator can be used for any JS object.
+ */
+export class ValueIterator<T> implements IIterator<T> {
+  /**
+   * Construct a new value iterator.
+   *
+   * @param source - The object of interest.
+   *
+   * @param keys - The keys to iterate, if known.
+   */
+  constructor(
+    source: { readonly [key: string]: T },
+    keys = Object.keys(source)
+  ) {
+    this._source = source;
+    this._keys = keys;
+  }
+
+  /**
+   * Get an iterator over the object's values.
+   *
+   * @returns An iterator which yields the object's values.
+   */
+  iter(): IIterator<T> {
+    return this;
+  }
+
+  /**
+   * Create an independent clone of the iterator.
+   *
+   * @returns A new independent clone of the iterator.
+   */
+  clone(): IIterator<T> {
+    let result = new ValueIterator<T>(this._source, this._keys);
+    result._index = this._index;
+    return result;
+  }
+
+  /**
+   * Get the next value from the iterator.
+   *
+   * @returns The next value from the iterator, or `undefined`.
+   */
+  next(): T | undefined {
+    if (this._index >= this._keys.length) {
+      return undefined;
+    }
+    let key = this._keys[this._index++];
+    if (key in this._source) {
+      return this._source[key];
+    }
+    return this.next();
+  }
+
+  private _index = 0;
+  private _keys: string[];
+  private _source: { readonly [key: string]: T };
+}
+
+/**
+ * An iterator for the items in an object.
+ *
+ * #### Notes
+ * This iterator can be used for any JS object.
+ */
+export class ItemIterator<T> implements IIterator<[string, T]> {
+  /**
+   * Construct a new item iterator.
+   *
+   * @param source - The object of interest.
+   *
+   * @param keys - The keys to iterate, if known.
+   */
+  constructor(
+    source: { readonly [key: string]: T },
+    keys = Object.keys(source)
+  ) {
+    this._source = source;
+    this._keys = keys;
+  }
+
+  /**
+   * Get an iterator over the object's values.
+   *
+   * @returns An iterator which yields the object's values.
+   */
+  iter(): IIterator<[string, T]> {
+    return this;
+  }
+
+  /**
+   * Create an independent clone of the iterator.
+   *
+   * @returns A new independent clone of the iterator.
+   */
+  clone(): IIterator<[string, T]> {
+    let result = new ItemIterator<T>(this._source, this._keys);
+    result._index = this._index;
+    return result;
+  }
+
+  /**
+   * Get the next value from the iterator.
+   *
+   * @returns The next value from the iterator, or `undefined`.
+   */
+  next(): [string, T] | undefined {
+    if (this._index >= this._keys.length) {
+      return undefined;
+    }
+    let key = this._keys[this._index++];
+    if (key in this._source) {
+      return [key, this._source[key]];
+    }
+    return this.next();
+  }
+
+  private _index = 0;
+  private _keys: string[];
+  private _source: { readonly [key: string]: T };
+}
diff --git a/packages/datastore/src/rest.ts b/packages/datastore/src/rest.ts
new file mode 100644
index 00000000000..1c4756b7bfd
--- /dev/null
+++ b/packages/datastore/src/rest.ts
@@ -0,0 +1,76 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import { URLExt } from '@jupyterlab/coreutils';
+
+import { ServerConnection } from '@jupyterlab/services';
+
+/**
+ *
+ */
+const DATASTORE_REST_URL = '/lab/api/datastore';
+
+/**
+ * Query the server for current, accessible collaborations.
+ *
+ * @param options - The options to the function.
+ */
+export async function currentCollaborations(
+  options?: currentCollaborations.IOptions
+): Promise<currentCollaborations.CollaborationMap> {
+  const settings =
+    (options && options.serverSettings) || ServerConnection.makeSettings();
+  const token = settings.token;
+  const queryParams = [];
+
+  let url;
+  url = URLExt.join(settings.baseUrl, DATASTORE_REST_URL);
+
+  if (token) {
+    queryParams.push(`token=${encodeURIComponent(token)}`);
+  }
+  if (queryParams) {
+    url = url + `?${queryParams.join('&')}`;
+  }
+  const response = await ServerConnection.makeRequest(url, {}, settings);
+  return response.json();
+}
+
+/**
+ * currentCollaborations type declarations.
+ */
+export namespace currentCollaborations {
+  /**
+   * Information about a single collaboration.
+   */
+  export type CollaborationInfo = {
+    /**
+     * A unique id of the collaboration.
+     */
+    id: string;
+
+    /**
+     * A user-friendly name for the session (not necessarily unique)
+     */
+    friendlyName: string;
+  };
+
+  /**
+   * A map of collaboration infos by their id.
+   */
+  export type CollaborationMap = {
+    collaborations: {
+      [id: string]: CollaborationInfo;
+    };
+  };
+
+  /**
+   * Options to currentSessions
+   */
+  export interface IOptions {
+    /**
+     * The server settings for the session.
+     */
+    serverSettings?: ServerConnection.ISettings;
+  }
+}
diff --git a/packages/datastore/src/util.ts b/packages/datastore/src/util.ts
new file mode 100644
index 00000000000..7169b195694
--- /dev/null
+++ b/packages/datastore/src/util.ts
@@ -0,0 +1,327 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import { Datastore, Record, Schema, Table } from '@phosphor/datastore';
+
+import { DisposableDelegate, IDisposable } from '@phosphor/disposable';
+
+/**
+ * A namespace for Datastore helper functions.
+ */
+export namespace DatastoreExt {
+  /**
+   * A helper function to wrap an update to the datastore in calls to
+   * `beginTransaction` and `endTransaction`.
+   *
+   * @param datastore: the datastore to which to apply the update.
+   *
+   * @param update: A function that performs the update on the datastore.
+   *   The function is called with a transaction id string, in case the
+   *   user wishes to store the transaction ID for later use.
+   *
+   * @returns the transaction ID.
+   */
+  export function withTransaction(
+    datastore: Datastore,
+    update: (id: string) => void
+  ): string {
+    let id = '';
+    if (!datastore.inTransaction) {
+      id = datastore.beginTransaction();
+    }
+    try {
+      update(id);
+    } finally {
+      if (id) {
+        datastore.endTransaction();
+      }
+    }
+    return id;
+  }
+
+  /**
+   * A base type for describing the location of data in a datastore,
+   * to be consumed by some object. The only requirement is that it
+   * has a datastore object. Objects extending from this will, in general,
+   * have some combination of table, record, and field locations.
+   */
+  export type DataLocation = {
+    /**
+     * The datastore in which the data is contained.
+     */
+    datastore: Datastore;
+  };
+
+  /**
+   * An interface for referring to a specific table in a datastore.
+   */
+  export type TableLocation<S extends Schema> = {
+    /**
+     * The schema in question. This schema must exist in the datastore,
+     * or an error may result in its usage.
+     */
+    schema: S;
+  };
+
+  /**
+   * An interface for referring to a specific record in a datastore.
+   */
+  export type RecordLocation<S extends Schema> = TableLocation<S> & {
+    /**
+     * The record in question.
+     */
+    record: string;
+  };
+
+  /**
+   * An interface for referring to a specific field in a datastore.
+   *
+   * #### Notes
+   * The field must exist in the schema.
+   */
+  export type FieldLocation<
+    S extends Schema,
+    F extends keyof S['fields']
+  > = RecordLocation<S> & {
+    /**
+     * The field in question.
+     */
+    field: F;
+  };
+
+  /**
+   * Get a given table by its location.
+   *
+   * @param datastore: the datastore in which the table resides.
+   *
+   * @param loc: The table location.
+   *
+   * @returns the table.
+   */
+  export function getTable<S extends Schema>(
+    datastore: Datastore,
+    loc: TableLocation<S>
+  ): Table<S> {
+    return datastore.get(loc.schema);
+  }
+
+  /**
+   * Get a given record by its location.
+   *
+   * @param datastore: the datastore in which the record resides.
+   *
+   * @param loc: The record location.
+   *
+   * @returns the record, or undefined if it does not exist.
+   */
+  export function getRecord<S extends Schema>(
+    datastore: Datastore,
+    loc: RecordLocation<S>
+  ): Record.Value<S> | undefined {
+    return datastore.get(loc.schema).get(loc.record);
+  }
+
+  /**
+   * Get a given field by its location.
+   *
+   * @param datastore: the datastore in which the field resides.
+   *
+   * @param loc: the field location.
+   *
+   * @returns the field in question.
+   *
+   * #### Notes
+   * This will throw an error if the record does not exist in the given table.
+   */
+  export function getField<S extends Schema, F extends keyof S['fields']>(
+    datastore: Datastore,
+    loc: FieldLocation<S, F>
+  ): S['fields'][F]['ValueType'] {
+    const record = datastore.get(loc.schema).get(loc.record);
+    if (!record) {
+      throw Error(`The record ${loc.record} could not be found`);
+    }
+    return record[loc.field];
+  }
+
+  /**
+   * Update a table.
+   *
+   * @param datastore: the datastore in which the table resides.
+   *
+   * @param loc: the table location.
+   *
+   * @param update: the update to the table.
+   *
+   * #### Notes
+   * This does not begin a transaction, so usage of this function should be
+   * combined with `beginTransaction`/`endTransaction`, or `withTransaction`.
+   */
+  export function updateTable<S extends Schema>(
+    datastore: Datastore,
+    loc: TableLocation<S>,
+    update: Table.Update<S>
+  ): void {
+    let table = datastore.get(loc.schema);
+    table.update(update);
+  }
+
+  /**
+   * Update a record in a table.
+   *
+   * @param datastore: the datastore in which the record resides.
+   *
+   * @param loc: the record location.
+   *
+   * @param update: the update to the record.
+   *
+   * #### Notes
+   * This does not begin a transaction, so usage of this function should be
+   * combined with `beginTransaction`/`endTransaction`, or `withTransaction`.
+   */
+  export function updateRecord<S extends Schema>(
+    datastore: Datastore,
+    loc: RecordLocation<S>,
+    update: Record.Update<S>
+  ): void {
+    let table = datastore.get(loc.schema);
+    table.update({
+      [loc.record]: update
+    });
+  }
+
+  /**
+   * Update a field in a table.
+   *
+   * @param datastore: the datastore in which the field resides.
+   *
+   * @param loc: the field location.
+   *
+   * @param update: the update to the field.
+   *
+   * #### Notes
+   * This does not begin a transaction, so usage of this function should be
+   * combined with `beginTransaction`/`endTransaction`, or `withTransaction`.
+   */
+  export function updateField<S extends Schema, F extends keyof S['fields']>(
+    datastore: Datastore,
+    loc: FieldLocation<S, F>,
+    update: S['fields'][F]['UpdateType']
+  ): void {
+    let table = datastore.get(loc.schema);
+    // TODO: this cast may be made unnecessary once microsoft/TypeScript#13573
+    // is fixed, possibly by microsoft/TypeScript#26797 lands.
+    table.update({
+      [loc.record]: {
+        [loc.field]: update
+      } as Record.Update<S>
+    });
+  }
+
+  /**
+   * Listen to changes in a table. Changes to other tables are ignored.
+   *
+   * @param datastore: the datastore in which the table resides.
+   *
+   * @param loc: the table location.
+   *
+   * @param slot: a callback function to invoke when the table changes.
+   *
+   * @returns an `IDisposable` that can be disposed to remove the listener.
+   */
+  export function listenTable<S extends Schema>(
+    datastore: Datastore,
+    loc: TableLocation<S>,
+    slot: (source: Datastore, args: Table.Change<S>) => void,
+    thisArg?: any
+  ): IDisposable {
+    // A wrapper change signal connection function.
+    const wrapper = (source: Datastore, args: Datastore.IChangedArgs) => {
+      // Ignore changes that don't match the requested record.
+      if (!args.change[loc.schema.id]) {
+        return;
+      }
+      // Otherwise, call the slot.
+      const tc = args.change[loc.schema.id]! as Table.Change<S>;
+      slot.bind(thisArg)(source, tc);
+    };
+    datastore.changed.connect(wrapper);
+    return new DisposableDelegate(() => {
+      datastore.changed.disconnect(wrapper);
+    });
+  }
+
+  /**
+   * Listen to changes in a record in a table. Changes to other tables and
+   * other records in the same table are ignored.
+   *
+   * @param datastore: the datastore in which the record resides.
+   *
+   * @param loc: the record location.
+   *
+   * @param slot: a callback function to invoke when the record changes.
+   *
+   * @returns an `IDisposable` that can be disposed to remove the listener.
+   */
+  export function listenRecord<S extends Schema>(
+    datastore: Datastore,
+    loc: RecordLocation<S>,
+    slot: (source: Datastore, args: Record.Change<S>) => void,
+    thisArg?: any
+  ): IDisposable {
+    // A wrapper change signal connection function.
+    const wrapper = (source: Datastore, args: Datastore.IChangedArgs) => {
+      // Ignore changes that don't match the requested record.
+      if (
+        !args.change[loc.schema.id] ||
+        !args.change[loc.schema.id][loc.record]
+      ) {
+        return;
+      }
+      // Otherwise, call the slot.
+      const tc = args.change[loc.schema.id]! as Table.Change<S>;
+      slot.bind(thisArg)(source, tc[loc.record]);
+    };
+    datastore.changed.connect(wrapper);
+    return new DisposableDelegate(() => {
+      datastore.changed.disconnect(wrapper);
+    });
+  }
+
+  /**
+   * Listen to changes in a fields in a table. Changes to other tables, other
+   * records in the same table, and other fields in the same record are ignored.
+   *
+   * @param datastore: the datastore in which the field resides.
+   *
+   * @param loc: the field location.
+   *
+   * @param slot: a callback function to invoke when the field changes.
+   *
+   * @returns an `IDisposable` that can be disposed to remove the listener.
+   */
+  export function listenField<S extends Schema, F extends keyof S['fields']>(
+    datastore: Datastore,
+    loc: FieldLocation<S, F>,
+    slot: (source: Datastore, args: S['fields'][F]['ChangeType']) => void,
+    thisArg?: any
+  ): IDisposable {
+    const wrapper = (source: Datastore, args: Datastore.IChangedArgs) => {
+      // Ignore changes that don't match the requested field.
+      if (
+        !args.change[loc.schema.id] ||
+        !args.change[loc.schema.id][loc.record] ||
+        !args.change[loc.schema.id][loc.record][loc.field as string]
+      ) {
+        return;
+      }
+      // Otherwise, call the slot.
+      const tc = args.change[loc.schema.id]! as Table.Change<S>;
+      slot.bind(thisArg)(source, tc[loc.record][loc.field]);
+    };
+    datastore.changed.connect(wrapper);
+    return new DisposableDelegate(() => {
+      datastore.changed.disconnect(wrapper);
+    });
+  }
+}
diff --git a/packages/datastore/src/wsmessages.ts b/packages/datastore/src/wsmessages.ts
new file mode 100644
index 00000000000..e8eaf962761
--- /dev/null
+++ b/packages/datastore/src/wsmessages.ts
@@ -0,0 +1,349 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import { ReadonlyJSONObject, UUID } from '@phosphor/coreutils';
+
+import { Datastore } from '@phosphor/datastore';
+
+/**
+ * Namespace for datastore collaboration statics.
+ */
+export namespace Collaboration {
+  /**
+   * A transaction with a serial number.
+   */
+  export type SerialTransaction = Datastore.Transaction & {
+    /**
+     * A serial number given by the server.
+     */
+    serial: number;
+  };
+
+  /**
+   * A lookup for transactions by their transaction id.
+   */
+  export type SerialTransactionMap = { [key: string]: SerialTransaction };
+
+  /**
+   *
+   */
+  export type Base = ReadonlyJSONObject & {
+    /**
+     * The unique message id.
+     */
+    msgId: string;
+  };
+
+  /**
+   * Maps a msgType to the corresponding type.
+   */
+  export interface ITypeMap {
+    'transaction-broadcast': TransactionBroadcast;
+    'transaction-ack': TransactionAck;
+    'history-request': HistoryRequest;
+    'history-reply': HistoryReply;
+    'transaction-request': TransactionRequest;
+    'transaction-reply': TransactionReply;
+    'serial-request': SerialRequest;
+    'serial-reply': SerialReply;
+    'permissions-request': PermissionsRequest;
+    'permissions-reply': PermissionsReply;
+    'serial-update': SerialNotice;
+    'state-stable': StableStateNotice;
+    'error-reply': ErrorReply;
+  }
+
+  /**
+   * Maps a request msgType to the corresponding reply type.
+   */
+  export interface IReplyMap {
+    'transaction-broadcast': TransactionAck;
+    'history-request': HistoryReply;
+    'transaction-request': TransactionReply;
+    'serial-request': SerialReply;
+    'permissions-request': PermissionsReply;
+  }
+
+  export type BaseReply = Base & {
+    /**
+     * The msgId of the corresponding request message.
+     */
+    readonly parentId: string;
+  };
+
+  /**
+   * A message broadcasting some transactions to peers.
+   */
+  export type TransactionBroadcast = Base & {
+    readonly msgType: 'transaction-broadcast';
+    readonly content: {
+      /**
+       * The transactions being broadcast.
+       */
+      readonly transactions: ReadonlyArray<SerialTransaction>;
+    };
+  };
+
+  /**
+   * An ackowledgment of received transactions.
+   */
+  export type TransactionAck = BaseReply & {
+    readonly msgType: 'transaction-ack';
+    readonly content: {
+      /**
+       * The transaction ids that were received.
+       */
+      readonly transactionIds: ReadonlyArray<string>;
+
+      /**
+       * The serials assigned to the received messages.
+       */
+      readonly serials: ReadonlyArray<number>;
+    };
+  };
+
+  /**
+   * A message requesting specific transactions from the server.
+   */
+  export type TransactionRequest = Base & {
+    readonly msgType: 'transaction-request';
+    readonly content: {
+      /**
+       * The ids of the transactions that are requested.
+       */
+      readonly transactionIds: ReadonlyArray<string>;
+    };
+  };
+
+  /**
+   * A reply to a 'transaction-request'.
+   */
+  export type TransactionReply = BaseReply & {
+    readonly msgType: 'transaction-reply';
+    readonly content: {
+      /**
+       * The transactions that were requested.
+       */
+      readonly transactions: ReadonlyArray<SerialTransaction>;
+    };
+  };
+
+  /**
+   * A message requesting the full transaction history from the server.
+   */
+  export type HistoryRequest = Base & {
+    readonly msgType: 'history-request';
+    readonly content: {
+      /**
+       * The checkpoint to start from.
+       */
+      checkpointId: number | null;
+    };
+  };
+
+  /**
+   * A reply to a 'history-request'.
+   */
+  export type HistoryReply = BaseReply & {
+    readonly msgType: 'history-reply';
+    readonly content: {
+      /**
+       * The state at the checkpoint, if given.
+       */
+      readonly state: string | null;
+
+      /**
+       * The transactions that make up the history.
+       */
+      readonly transactions: ReadonlyArray<SerialTransaction>;
+    };
+  };
+
+  /**
+   * A message requesting specific transactions by serial number.
+   */
+  export type SerialRequest = Base & {
+    readonly msgType: 'serial-request';
+    readonly content: {
+      /**
+       * The serial numbers that are requested.
+       */
+      readonly serials: ReadonlyArray<number>;
+    };
+  };
+
+  /**
+   * A reply to a 'serial-request'.
+   */
+  export type SerialReply = BaseReply & {
+    readonly msgType: 'serial-reply';
+    readonly content: {
+      /**
+       * The transactions that were requested.
+       */
+      readonly transactions: ReadonlyArray<SerialTransaction>;
+    };
+  };
+
+  /**
+   * A message requesting which permission we have on the central store.
+   */
+  export type PermissionsRequest = Base & {
+    readonly msgType: 'permissions-request';
+    readonly content: {};
+  };
+
+  /**
+   * A reply to a `permission-request`.
+   */
+  export type PermissionsReply = BaseReply & {
+    readonly msgType: 'permissions-reply';
+    readonly content: {
+      /**
+       * Whether we can read transactions from the store.
+       */
+      readonly read: boolean;
+
+      /**
+       * Whether we can write transactions to the store.
+       */
+      readonly write: boolean;
+    };
+  };
+
+  /**
+   * An update to the server of the last applied server serial.
+   */
+  export type SerialNotice = Base & {
+    readonly msgType: 'serial-update';
+    readonly content: {
+      /**
+       * The server-side serial of last transaction applied.
+       */
+      readonly serial: number;
+    };
+  };
+
+  /**
+   * A notice that the datastore is *stable* up to the given serial.
+   *
+   * Stability here means that all concurrent transactions are known
+   * to have been applied.
+   */
+  export type StableStateNotice = Base & {
+    readonly msgType: 'state-stable';
+    readonly content: {
+      /**
+       * The server-side serial of the stable state.
+       */
+      serial: number;
+    };
+  };
+
+  /**
+   * An error reply message.
+   */
+  export type ErrorReply = BaseReply & {
+    readonly msgType: 'error-reply';
+    readonly content: {
+      /**
+       * The reason for the error.
+       */
+      readonly reason: string;
+    };
+  };
+
+  /**
+   * A union type for all request messages.
+   */
+  export type Request =
+    | TransactionBroadcast
+    | TransactionRequest
+    | HistoryRequest
+    | SerialRequest
+    | PermissionsRequest;
+
+  /**
+   * A union type for all reply messages.
+   */
+  export type RawReply =
+    | TransactionAck
+    | TransactionReply
+    | HistoryReply
+    | SerialReply
+    | PermissionsReply
+    | ErrorReply;
+
+  /**
+   * A union type for all successful reply messages.
+   */
+  export type Reply =
+    | TransactionAck
+    | TransactionReply
+    | HistoryReply
+    | SerialReply
+    | PermissionsReply;
+
+  /**
+   * A union type of all notice messages (no reply expected).
+   */
+  export type Notice = StableStateNotice | SerialNotice;
+
+  /**
+   * A union type for all messages.
+   */
+  export type Message = Request | RawReply | Notice;
+
+  /**
+   * Create a WSServerAdapter message.
+   *
+   * @param {string} msgType The message type.
+   * @param {ReadonlyJSONObject} content The content of the message.
+   * @param {string} parentId An optional id of the parent of this message.
+   * @returns {TransactionBroadcast} The created message.
+   */
+  export function createMessage<K extends Message['msgType']>(
+    msgType: K,
+    content: ITypeMap[K]['content'],
+    parentId?: ITypeMap[K]['parentId']
+  ): ITypeMap[K] {
+    const msgId = UUID.uuid4();
+    return {
+      msgId,
+      msgType,
+      parentId,
+      content
+    } as ITypeMap[K];
+  }
+
+  /**
+   * Create a WSServerAdapter message.
+   *
+   * @param {string} msgType The message type.
+   * @param {ReadonlyJSONObject} content The content of the message.
+   * @param {string} parentId The id of the parent of this reply.
+   * @returns {TransactionBroadcast} The created message.
+   */
+  export function createReply<T extends BaseReply>(
+    msgType: T['msgType'],
+    content: T['content'],
+    parentId: string
+  ): T {
+    const msgId = UUID.uuid4();
+    return ({
+      msgId,
+      msgType,
+      parentId,
+      content
+    } as unknown) as T;
+  }
+
+  /**
+   * Whether a message is a reply to a previous request.
+   * @param message - The message to consider.
+   * @returns Whether the message is a reply.
+   */
+  export function isReply(message: Message): message is RawReply {
+    return message.parentId !== undefined;
+  }
+}
diff --git a/packages/datastore/tdoptions.json b/packages/datastore/tdoptions.json
new file mode 100644
index 00000000000..49998f15a8f
--- /dev/null
+++ b/packages/datastore/tdoptions.json
@@ -0,0 +1,20 @@
+{
+  "excludeNotExported": true,
+  "mode": "file",
+  "target": "es5",
+  "module": "es5",
+  "lib": [
+    "lib.es2015.d.ts",
+    "lib.es2015.collection.d.ts",
+    "lib.es2015.promise.d.ts",
+    "lib.dom.d.ts"
+  ],
+  "out": "../../docs/api/datastore",
+  "baseUrl": ".",
+  "paths": {
+    "@jupyterlab/*": ["../packages/*"]
+  },
+  "esModuleInterop": true,
+  "jsx": "react",
+  "types": []
+}
diff --git a/packages/datastore/tsconfig.json b/packages/datastore/tsconfig.json
new file mode 100644
index 00000000000..0e80133761b
--- /dev/null
+++ b/packages/datastore/tsconfig.json
@@ -0,0 +1,16 @@
+{
+  "extends": "../../tsconfigbase",
+  "compilerOptions": {
+    "outDir": "lib",
+    "rootDir": "src"
+  },
+  "include": ["src/*"],
+  "references": [
+    {
+      "path": "../coreutils"
+    },
+    {
+      "path": "../services"
+    }
+  ]
+}
diff --git a/packages/docmanager-extension/src/index.ts b/packages/docmanager-extension/src/index.ts
index d1fec3d07a7..e70172909fc 100644
--- a/packages/docmanager-extension/src/index.ts
+++ b/packages/docmanager-extension/src/index.ts
@@ -420,7 +420,7 @@ function addCommands(
             return;
           }
           if (result.button.accept) {
-            if (context.model.readOnly) {
+            if (context.readOnly) {
               return context.revert();
             }
             return context.restoreCheckpoint().then(() => context.revert());
@@ -437,7 +437,7 @@ function addCommands(
     execute: () => {
       if (isEnabled()) {
         let context = docManager.contextForWidget(shell.currentWidget);
-        if (context.model.readOnly) {
+        if (context.readOnly) {
           return showDialog({
             title: 'Cannot Save',
             body: 'Document is read-only',
@@ -472,7 +472,7 @@ function addCommands(
       const paths = new Set<string>(); // Cache so we don't double save files.
       each(shell.widgets('main'), widget => {
         const context = docManager.contextForWidget(widget);
-        if (context && !context.model.readOnly && !paths.has(context.path)) {
+        if (context && !context.readOnly && !paths.has(context.path)) {
           paths.add(context.path);
           promises.push(context.save());
         }
@@ -646,8 +646,8 @@ function handleContext(
     }
   };
   void context.ready.then(() => {
-    context.model.stateChanged.connect(onStateChanged);
-    if (context.model.dirty) {
+    context.stateChanged.connect(onStateChanged);
+    if (context.dirty) {
       disposable = status.setDirty();
     }
   });
diff --git a/packages/docmanager/src/manager.ts b/packages/docmanager/src/manager.ts
index c17b68213e1..7849fafd1ba 100644
--- a/packages/docmanager/src/manager.ts
+++ b/packages/docmanager/src/manager.ts
@@ -456,15 +456,12 @@ export class DocumentManager implements IDocumentManager {
       this._widgetManager.adoptWidget(context, widget);
       this._opener.open(widget, options);
     };
-    let modelDBFactory =
-      this.services.contents.getModelDBFactory(path) || undefined;
     let context = new Context({
       opener: adopter,
       manager: this.services,
       factory,
       path,
       kernelPreference,
-      modelDBFactory,
       setBusy: this._setBusy
     });
     let handler = new SaveHandler({
diff --git a/packages/docmanager/src/savehandler.ts b/packages/docmanager/src/savehandler.ts
index 402887111ce..4025b3116be 100644
--- a/packages/docmanager/src/savehandler.ts
+++ b/packages/docmanager/src/savehandler.ts
@@ -111,7 +111,7 @@ export class SaveHandler implements IDisposable {
     // Bail if the model is not dirty or the file is not writable, or the dialog
     // is already showing.
     let writable = context.contentsModel && context.contentsModel.writable;
-    if (!writable || !context.model.dirty || this._inDialog) {
+    if (!writable || !context.dirty || this._inDialog) {
       return;
     }
 
diff --git a/packages/docmanager/src/widgetmanager.ts b/packages/docmanager/src/widgetmanager.ts
index 2507a012765..cecfd6f828d 100644
--- a/packages/docmanager/src/widgetmanager.ts
+++ b/packages/docmanager/src/widgetmanager.ts
@@ -278,7 +278,7 @@ export class DocumentWidgetManager implements IDisposable {
         let last = checkpoints[checkpoints.length - 1];
         let checkpoint = last ? Time.format(last.last_modified) : 'None';
         let caption = `Name: ${model.name}\nPath: ${model.path}\n`;
-        if (context.model.readOnly) {
+        if (context.readOnly) {
           caption += 'Read-only';
         } else {
           caption +=
@@ -351,8 +351,7 @@ export class DocumentWidgetManager implements IDisposable {
     if (!factory) {
       return Promise.resolve(true);
     }
-    let model = context.model;
-    if (!model.dirty || widgets.length > 1 || factory.readOnly) {
+    if (!context.dirty || widgets.length > 1 || factory.readOnly) {
       return Promise.resolve(true);
     }
     let fileName = widget.title.label;
diff --git a/packages/docregistry/package.json b/packages/docregistry/package.json
index af3bdd37c5e..1da8dbd33fb 100644
--- a/packages/docregistry/package.json
+++ b/packages/docregistry/package.json
@@ -39,7 +39,7 @@
     "@jupyterlab/codeeditor": "^1.0.0",
     "@jupyterlab/codemirror": "^1.0.1",
     "@jupyterlab/coreutils": "^3.0.0",
-    "@jupyterlab/observables": "^2.2.0",
+    "@jupyterlab/datastore": "^1.0.0",
     "@jupyterlab/rendermime": "^1.0.1",
     "@jupyterlab/rendermime-interfaces": "^1.3.0",
     "@jupyterlab/services": "^4.0.1",
diff --git a/packages/docregistry/src/context.ts b/packages/docregistry/src/context.ts
index 3618a08c553..62a2d89c130 100644
--- a/packages/docregistry/src/context.ts
+++ b/packages/docregistry/src/context.ts
@@ -23,9 +23,7 @@ import {
   showErrorMessage
 } from '@jupyterlab/apputils';
 
-import { PathExt } from '@jupyterlab/coreutils';
-
-import { IModelDB, ModelDB } from '@jupyterlab/observables';
+import { IChangedArgs, PathExt } from '@jupyterlab/coreutils';
 
 import { RenderMimeRegistry } from '@jupyterlab/rendermime';
 
@@ -51,17 +49,17 @@ export class Context<T extends DocumentRegistry.IModel>
     const localPath = this._manager.contents.localPath(this._path);
     let lang = this._factory.preferredLanguage(PathExt.basename(localPath));
 
-    let dbFactory = options.modelDBFactory;
-    if (dbFactory) {
-      const localPath = manager.contents.localPath(this._path);
-      this._modelDB = dbFactory.createNew(localPath);
-      this._model = this._factory.createNew(lang, this._modelDB);
-    } else {
-      this._model = this._factory.createNew(lang);
-    }
+    this._modelPromise = this._factory.createNew({
+      path: this._path,
+      languagePreference: lang
+    });
+    this._modelPromise.then(model => {
+      this._model = model;
+      this._model.contentChanged.connect(this._onModelContentChanged, this);
+    });
 
-    this._readyPromise = manager.ready.then(() => {
-      return this._populatedPromise.promise;
+    this._readyPromise = manager.ready.then(async () => {
+      await Promise.all([this._modelPromise, this._populatedPromise.promise]);
     });
 
     let ext = PathExt.extname(this._path);
@@ -96,6 +94,42 @@ export class Context<T extends DocumentRegistry.IModel>
     return this._fileChanged;
   }
 
+  /**
+   * A signal emitted when the document state changes.
+   */
+  get stateChanged(): ISignal<this, IChangedArgs<any>> {
+    return this._stateChanged;
+  }
+
+  /**
+   * The dirty state of the document.
+   */
+  get dirty(): boolean {
+    return this._dirty;
+  }
+  set dirty(newValue: boolean) {
+    if (newValue === this._dirty) {
+      return;
+    }
+    let oldValue = this._dirty;
+    this._dirty = newValue;
+    this._stateChanged.emit({ name: 'dirty', oldValue, newValue });
+  }
+
+  /**
+   * The read only state of the document.
+   */
+  get readOnly(): boolean {
+    return this._readOnly;
+  }
+  set readOnly(newValue: boolean) {
+    if (newValue === this._readOnly) {
+      return;
+    }
+    let oldValue = this._readOnly;
+    this._readOnly = newValue;
+    this._stateChanged.emit({ name: 'readOnly', oldValue, newValue });
+  }
   /**
    * A signal emitted on the start and end of a saving operation.
    */
@@ -113,7 +147,7 @@ export class Context<T extends DocumentRegistry.IModel>
   /**
    * Get the model associated with the document.
    */
-  get model(): T {
+  get model(): T | null {
     return this._model;
   }
 
@@ -175,9 +209,6 @@ export class Context<T extends DocumentRegistry.IModel>
     }
     this._isDisposed = true;
     this.session.dispose();
-    if (this._modelDB) {
-      this._modelDB.dispose();
-    }
     this._model.dispose();
     this._disposed.emit(void 0);
     Signal.clearData(this);
@@ -209,24 +240,20 @@ export class Context<T extends DocumentRegistry.IModel>
    *
    * @returns a promise that resolves upon initialization.
    */
-  initialize(isNew: boolean): Promise<void> {
+  async initialize(isNew: boolean): Promise<void> {
     if (isNew) {
-      this._model.initialize();
       return this._save();
     }
-    if (this._modelDB) {
-      return this._modelDB.connected.then(() => {
-        if (this._modelDB.isPrepopulated) {
-          this._model.initialize();
-          void this._save();
-          return void 0;
-        } else {
-          return this._revert(true);
-        }
-      });
-    } else {
-      return this._revert(true);
+    const model = await this._modelPromise;
+    if (
+      model.isCollaborative &&
+      ((model as any) as DocumentRegistry.ICollaborativeModel).isPrepopulated
+    ) {
+      this._populate();
+      return;
     }
+    // TODO how to handle prepopulated collaborative sessions?
+    return this._revert(true);
   }
 
   /**
@@ -408,6 +435,13 @@ export class Context<T extends DocumentRegistry.IModel>
     }
   }
 
+  /**
+   * Handle a change in the model content.
+   */
+  private _onModelContentChanged(): void {
+    this.dirty = true;
+  }
+
   /**
    * Update our contents model, without the content.
    */
@@ -482,17 +516,15 @@ export class Context<T extends DocumentRegistry.IModel>
 
     return this._manager.ready
       .then(() => {
-        if (!model.modelDB.isCollaborative) {
-          return this._maybeSave(options);
-        }
-        return this._manager.contents.save(this._path, options);
+        // TODO think about how saving works in collaborative environments.
+        return this._maybeSave(options);
       })
       .then(value => {
         if (this.isDisposed) {
           return;
         }
 
-        model.dirty = false;
+        this.dirty = false;
         this._updateContentsModel(value);
 
         if (!this._isPopulated) {
@@ -541,21 +573,19 @@ export class Context<T extends DocumentRegistry.IModel>
       content: true
     };
     let path = this._path;
-    let model = this._model;
     return this._manager.ready
       .then(() => {
         return this._manager.contents.get(path, opts);
       })
-      .then(contents => {
+      .then(async contents => {
         if (this.isDisposed) {
           return;
         }
+        let model = await this._modelPromise;
         let dirty = false;
         if (contents.format === 'json') {
           model.fromJSON(contents.content);
-          if (initializeModel) {
-            model.initialize();
-          }
+          // TODO figure out model initialization
         } else {
           let content = contents.content;
           // Convert line endings if necessary, marking the file
@@ -567,12 +597,9 @@ export class Context<T extends DocumentRegistry.IModel>
             this._useCRLF = false;
           }
           model.fromString(content);
-          if (initializeModel) {
-            model.initialize();
-          }
         }
         this._updateContentsModel(contents);
-        model.dirty = dirty;
+        this.dirty = dirty;
         if (!this._isPopulated) {
           return this._populate();
         }
@@ -763,8 +790,8 @@ export class Context<T extends DocumentRegistry.IModel>
     widget: Widget,
     options?: DocumentRegistry.IOpenOptions
   ) => void;
-  private _model: T;
-  private _modelDB: IModelDB;
+  private _model: T | null;
+  private _modelPromise: Promise<T>;
   private _path = '';
   private _useCRLF = false;
   private _factory: DocumentRegistry.IModelFactory<T>;
@@ -776,8 +803,11 @@ export class Context<T extends DocumentRegistry.IModel>
   private _isDisposed = false;
   private _pathChanged = new Signal<this, string>(this);
   private _fileChanged = new Signal<this, Contents.IModel>(this);
+  private _stateChanged = new Signal<this, IChangedArgs<any>>(this);
   private _saveState = new Signal<this, DocumentRegistry.SaveState>(this);
   private _disposed = new Signal<this, void>(this);
+  private _dirty = false;
+  private _readOnly = false;
 }
 
 /**
@@ -808,11 +838,6 @@ export namespace Context {
      */
     kernelPreference?: IClientSession.IKernelPreference;
 
-    /**
-     * An IModelDB factory method which may be used for the document.
-     */
-    modelDBFactory?: ModelDB.IFactory;
-
     /**
      * An optional callback for opening sibling widgets.
      */
diff --git a/packages/docregistry/src/default.ts b/packages/docregistry/src/default.ts
index fcb9cc3718a..187773c825f 100644
--- a/packages/docregistry/src/default.ts
+++ b/packages/docregistry/src/default.ts
@@ -1,40 +1,73 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
+import { MainAreaWidget } from '@jupyterlab/apputils';
+
+import {
+  CodeEditor,
+  CodeEditorData,
+  ICodeEditorData
+} from '@jupyterlab/codeeditor';
+
 import { Mode } from '@jupyterlab/codemirror';
 
+import { IChangedArgs, PathExt } from '@jupyterlab/coreutils';
+
+import { createDatastore, DatastoreExt } from '@jupyterlab/datastore';
+
 import { Contents } from '@jupyterlab/services';
 
 import { JSONValue } from '@phosphor/coreutils';
 
+import { IDisposable } from '@phosphor/disposable';
+
 import { ISignal, Signal } from '@phosphor/signaling';
 
 import { Widget } from '@phosphor/widgets';
 
-import { MainAreaWidget } from '@jupyterlab/apputils';
-
-import { CodeEditor } from '@jupyterlab/codeeditor';
-
-import { IChangedArgs, PathExt } from '@jupyterlab/coreutils';
-
-import { IModelDB } from '@jupyterlab/observables';
-
 import { DocumentRegistry, IDocumentWidget } from './index';
 
 /**
- * The default implementation of a document model.
+ * The default implementation of a text document model.
  */
-export class DocumentModel extends CodeEditor.Model
+export class TextDocumentModel extends CodeEditor.Model
   implements DocumentRegistry.ICodeModel {
   /**
    * Construct a new document model.
    */
-  constructor(languagePreference?: string, modelDB?: IModelDB) {
-    super({ modelDB });
-    this._defaultLang = languagePreference || '';
-    this.value.changed.connect(this.triggerContentChange, this);
+  constructor(options: TextDocumentModel.IOptions = {}) {
+    super({
+      data: options.data || {
+        datastore: CodeEditorData.createStore(),
+        record: {
+          schema: CodeEditorData.SCHEMA,
+          record: 'data'
+        }
+      }
+    });
+
+    this._defaultLang = options.languagePreference || '';
+    // We don't want to trigger a content change for text selection changes,
+    // only actual content changes to the data owned by the document
+    this._listener = DatastoreExt.listenField(
+      this.data.datastore,
+      { ...this.data.record, field: 'text' },
+      this.triggerContentChange,
+      this
+    );
+    this.ready = Promise.resolve(undefined);
   }
 
+  /**
+   * Whether the model is ready for collaboration.
+   */
+  readonly ready: Promise<void>;
+
+  /**
+   * Whether the model is collaborative.
+   */
+  readonly isCollaborative = true;
+
   /**
    * A signal emitted when the document content changes.
    */
@@ -43,51 +76,129 @@ export class DocumentModel extends CodeEditor.Model
   }
 
   /**
-   * A signal emitted when the document state changes.
+   * The default kernel name of the document.
+   *
+   * #### Notes
+   * This is a read-only property.
    */
-  get stateChanged(): ISignal<this, IChangedArgs<any>> {
-    return this._stateChanged;
+  get defaultKernelName(): string {
+    return '';
   }
 
   /**
-   * The dirty state of the document.
+   * The default kernel language of the document.
+   *
+   * #### Notes
+   * This is a read-only property.
    */
-  get dirty(): boolean {
-    return this._dirty;
+  get defaultKernelLanguage(): string {
+    return this._defaultLang;
   }
-  set dirty(newValue: boolean) {
-    if (newValue === this._dirty) {
-      return;
-    }
-    let oldValue = this._dirty;
-    this._dirty = newValue;
-    this.triggerStateChange({ name: 'dirty', oldValue, newValue });
+
+  /**
+   * Serialize the model to a string.
+   */
+  toString(): string {
+    return this.value;
   }
 
   /**
-   * The read only state of the document.
+   * Deserialize the model from a string.
+   *
+   * #### Notes
+   * Should emit a [contentChanged] signal.
    */
-  get readOnly(): boolean {
-    return this._readOnly;
+  fromString(value: string): void {
+    this.value = value;
+  }
+
+  /**
+   * Serialize the model to JSON.
+   */
+  toJSON(): JSONValue {
+    return JSON.parse(this.value || 'null');
+  }
+
+  /**
+   * Deserialize the model from JSON.
+   *
+   * #### Notes
+   * Should emit a [contentChanged] signal.
+   */
+  fromJSON(value: JSONValue): void {
+    this.fromString(JSON.stringify(value));
   }
-  set readOnly(newValue: boolean) {
-    if (newValue === this._readOnly) {
+
+  /**
+   * Dispose of resources held by the document model.
+   */
+  dispose(): void {
+    if (this.isDisposed) {
       return;
     }
-    let oldValue = this._readOnly;
-    this._readOnly = newValue;
-    this.triggerStateChange({ name: 'readOnly', oldValue, newValue });
+    if (this._listener) {
+      this._listener.dispose();
+    }
+    super.dispose();
+  }
+
+  /**
+   * Trigger a content changed signal.
+   */
+  protected triggerContentChange(): void {
+    this._contentChanged.emit(void 0);
+  }
+
+  private _contentChanged = new Signal<this, void>(this);
+  private _listener: IDisposable | null = null;
+  private _defaultLang = '';
+}
+
+/**
+ * A namespace for TextDocumentModel statics.
+ */
+export namespace TextDocumentModel {
+  /**
+   * Options for creating a new TextDocumentModel.
+   */
+  export interface IOptions {
+    /**
+     * A record in a datastore in which to hold the data.
+     */
+    data?: ICodeEditorData.DataLocation;
+
+    /**
+     * The preferred kernel language for the document.
+     */
+    languagePreference?: string;
+  }
+}
+
+/**
+ * An implementation of a string document model. Unlike the text document model,
+ * it is not intended to be collaborative, so it has a lighter memory footprint.
+ * It is intended to be used for large, static text data, such as CSVs.
+ */
+export class StringDocumentModel implements DocumentRegistry.IModel {
+  /**
+   * A signal emitted when the document content changes.
+   */
+  get contentChanged(): ISignal<this, void> {
+    return this._contentChanged;
   }
 
+  /**
+   * Whether the model is collaborative.
+   */
+  readonly isCollaborative = false;
+
   /**
    * The default kernel name of the document.
    *
    * #### Notes
    * This is a read-only property.
    */
-  get defaultKernelName(): string {
-    return '';
-  }
+  readonly defaultKernelName = '';
 
   /**
    * The default kernel language of the document.
@@ -95,15 +206,13 @@ export class DocumentModel extends CodeEditor.Model
    * #### Notes
    * This is a read-only property.
    */
-  get defaultKernelLanguage(): string {
-    return this._defaultLang;
-  }
+  readonly defaultKernelLanguage = '';
 
   /**
    * Serialize the model to a string.
    */
   toString(): string {
-    return this.value.text;
+    return this._value;
   }
 
   /**
@@ -113,14 +222,15 @@ export class DocumentModel extends CodeEditor.Model
    * Should emit a [contentChanged] signal.
    */
   fromString(value: string): void {
-    this.value.text = value;
+    this._value = value;
+    this._contentChanged.emit();
   }
 
   /**
    * Serialize the model to JSON.
    */
   toJSON(): JSONValue {
-    return JSON.parse(this.value.text || 'null');
+    return JSON.parse(this._value || 'null');
   }
 
   /**
@@ -134,32 +244,26 @@ export class DocumentModel extends CodeEditor.Model
   }
 
   /**
-   * Initialize the model with its current state.
-   */
-  initialize(): void {
-    return;
-  }
-
-  /**
-   * Trigger a state change signal.
+   * Whether the model has been disposed.
    */
-  protected triggerStateChange(args: IChangedArgs<any>): void {
-    this._stateChanged.emit(args);
+  get isDisposed(): boolean {
+    return this._isDisposed;
   }
 
   /**
-   * Trigger a content changed signal.
+   * Dispose of resources held by the document model.
    */
-  protected triggerContentChange(): void {
-    this._contentChanged.emit(void 0);
-    this.dirty = true;
+  dispose(): void {
+    if (this._isDisposed) {
+      return;
+    }
+    this._isDisposed = true;
+    this._value = '';
   }
 
-  private _defaultLang = '';
-  private _dirty = false;
-  private _readOnly = false;
   private _contentChanged = new Signal<this, void>(this);
-  private _stateChanged = new Signal<this, IChangedArgs<any>>(this);
+  private _isDisposed = false;
+  private _value = '';
 }
 
 /**
@@ -216,11 +320,22 @@ export class TextModelFactory implements DocumentRegistry.CodeModelFactory {
    *
    * @returns A new document model.
    */
-  createNew(
-    languagePreference?: string,
-    modelDB?: IModelDB
-  ): DocumentRegistry.ICodeModel {
-    return new DocumentModel(languagePreference, modelDB);
+  async createNew(
+    options: DocumentRegistry.IModelFactory.IOptions = {}
+  ): Promise<DocumentRegistry.ICodeModel> {
+    const { languagePreference, path } = options;
+    if (path) {
+      const datastore = await createDatastore(path, [CodeEditorData.SCHEMA]);
+      const data = {
+        datastore,
+        record: {
+          schema: CodeEditorData.SCHEMA,
+          record: 'data'
+        }
+      };
+      return new TextDocumentModel({ data, languagePreference });
+    }
+    return new TextDocumentModel({ languagePreference });
   }
 
   /**
@@ -235,9 +350,10 @@ export class TextModelFactory implements DocumentRegistry.CodeModelFactory {
 }
 
 /**
- * An implementation of a model factory for base64 files.
+ * An implementation of a model factory for string documents.
  */
-export class Base64ModelFactory extends TextModelFactory {
+export class StringModelFactory
+  implements DocumentRegistry.IModelFactory<StringDocumentModel> {
   /**
    * The name of the model type.
    *
@@ -245,7 +361,7 @@ export class Base64ModelFactory extends TextModelFactory {
    * This is a read-only property.
    */
   get name(): string {
-    return 'base64';
+    return 'string';
   }
 
   /**
@@ -258,6 +374,66 @@ export class Base64ModelFactory extends TextModelFactory {
     return 'file';
   }
 
+  /**
+   * The format of the file.
+   *
+   * This is a read-only property.
+   */
+  get fileFormat(): Contents.FileFormat {
+    return 'text';
+  }
+  /**
+   * Get whether the model factory has been disposed.
+   */
+  get isDisposed(): boolean {
+    return this._isDisposed;
+  }
+
+  /**
+   * Dispose of the resources held by the model factory.
+   */
+  dispose(): void {
+    this._isDisposed = true;
+  }
+
+  /**
+   * Create a new model.
+   *
+   * @param languagePreference - An optional kernel language preference.
+   *
+   * @returns A new document model.
+   */
+  async createNew(
+    options: DocumentRegistry.IModelFactory.IOptions = {}
+  ): Promise<StringDocumentModel> {
+    return new StringDocumentModel();
+  }
+
+  /**
+   * Get the preferred kernel language given the path.
+   * Returns an empty string.
+   */
+  preferredLanguage(path: string): string {
+    return '';
+  }
+
+  private _isDisposed = false;
+}
+
+/**
+ * An implementation of a model factory for base64-encoded documents.
+ */
+export class Base64ModelFactory extends StringModelFactory {
+  /**
+   * The name of the model type.
+   *
+   * #### Notes
+   * This is a read-only property.
+   */
+  get name(): string {
+    return 'base64';
+  }
+
   /**
    * The format of the file.
    *
@@ -463,7 +639,7 @@ export class DocumentWidget<
     this._onPathChanged(this.context, this.context.path);
 
     // Listen for changes in the dirty state.
-    this.context.model.stateChanged.connect(this._onModelStateChanged, this);
+    this.context.stateChanged.connect(this._onContextStateChanged, this);
     void this.context.ready.then(() => {
       this._handleDirtyState();
     });
@@ -487,10 +663,10 @@ export class DocumentWidget<
   }
 
   /**
-   * Handle a change to the context model state.
+   * Handle a change to the context state.
    */
-  private _onModelStateChanged(
-    sender: DocumentRegistry.IModel,
+  private _onContextStateChanged(
+    sender: DocumentRegistry.IContext<DocumentRegistry.IModel>,
     args: IChangedArgs<any>
   ): void {
     if (args.name === 'dirty') {
@@ -502,7 +678,7 @@ export class DocumentWidget<
    * Handle the dirty state of the context model.
    */
   private _handleDirtyState(): void {
-    if (this.context.model.dirty) {
+    if (this.context.dirty) {
       this.title.className += ` ${DIRTY_CLASS}`;
     } else {
       this.title.className = this.title.className.replace(DIRTY_CLASS, '');
diff --git a/packages/docregistry/src/mimedocument.ts b/packages/docregistry/src/mimedocument.ts
index b8225dd095c..3092eb2d26e 100644
--- a/packages/docregistry/src/mimedocument.ts
+++ b/packages/docregistry/src/mimedocument.ts
@@ -191,6 +191,7 @@ export class MimeContent extends Widget {
     } else {
       if (!JSONExt.deepEqual(data, this._context.model.toJSON())) {
         this._context.model.fromJSON(data);
+        this._context.dirty = false;
       }
     }
   };
diff --git a/packages/docregistry/src/registry.ts b/packages/docregistry/src/registry.ts
index f234672f596..bf3bb600bea 100644
--- a/packages/docregistry/src/registry.ts
+++ b/packages/docregistry/src/registry.ts
@@ -1,8 +1,6 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { Contents, Kernel } from '@jupyterlab/services';
-
 import {
   ArrayExt,
   ArrayIterator,
@@ -30,7 +28,7 @@ import {
   PathExt
 } from '@jupyterlab/coreutils';
 
-import { IModelDB } from '@jupyterlab/observables';
+import { Contents, Kernel } from '@jupyterlab/services';
 
 import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
 
@@ -659,23 +657,9 @@ export namespace DocumentRegistry {
     contentChanged: ISignal<this, void>;
 
     /**
-     * A signal emitted when the model state changes.
-     */
-    stateChanged: ISignal<this, IChangedArgsGeneric<any>>;
-
-    /**
-     * The dirty state of the model.
-     *
-     * #### Notes
-     * This should be cleared when the document is loaded from
-     * or saved to disk.
-     */
-    dirty: boolean;
-
-    /**
-     * The read-only state of the model.
+     * Whether the model is collaborative.
      */
-    readOnly: boolean;
+    readonly isCollaborative: boolean;
 
     /**
      * The default kernel name of the document.
@@ -687,16 +671,6 @@ export namespace DocumentRegistry {
      */
     readonly defaultKernelLanguage: string;
 
-    /**
-     * The underlying `IModelDB` instance in which model
-     * data is stored.
-     *
-     * ### Notes
-     * Making direct edits to the values stored in the`IModelDB`
-     * is not recommended, and may produce unpredictable results.
-     */
-    readonly modelDB: IModelDB;
-
     /**
      * Serialize the model to a string.
      */
@@ -722,21 +696,32 @@ export namespace DocumentRegistry {
      * Should emit a [contentChanged] signal.
      */
     fromJSON(value: any): void;
+  }
 
+  export interface ICollaborativeModel extends IModel {
     /**
-     * Initialize model state after initial data load.
-     *
-     * #### Notes
-     * This function must be called after the initial data is loaded to set up
-     * initial model state, such as an initial undo stack, etc.
+     * Whether the collaborative model is ready for use.
+     * This typically means it has made a connection with the server
+     * and received any history or context that it needs.
+     */
+    readonly ready: Promise<void>;
+
+    /**
+     * Whether the model is collaborative.
      */
-    initialize(): void;
+    readonly isCollaborative: true;
+
+    /**
+     * Whether the datastore for the model is prepopulated upon
+     * model construction time.
+     */
+    readonly isPrepopulated: boolean;
   }
 
   /**
    * The interface for a document model that represents code.
    */
-  export interface ICodeModel extends IModel, CodeEditor.IModel {}
+  export interface ICodeModel extends ICollaborativeModel, CodeEditor.IModel {}
 
   /**
    * The document context object.
@@ -752,6 +737,25 @@ export namespace DocumentRegistry {
      */
     fileChanged: ISignal<this, Contents.IModel>;
 
+    /**
+     * A signal emitted when the model state changes.
+     */
+    stateChanged: ISignal<this, IChangedArgsGeneric<any>>;
+
+    /**
+     * The dirty state of the model.
+     *
+     * #### Notes
+     * This should be cleared when the document is loaded from
+     * or saved to disk.
+     */
+    dirty: boolean;
+
+    /**
+     * The read-only state of the model.
+     */
+    readOnly: boolean;
+
     /**
      * A signal emitted on the start and end of a saving operation.
      */
@@ -1044,7 +1048,7 @@ export namespace DocumentRegistry {
      *
      * @returns A new document model.
      */
-    createNew(languagePreference?: string, modelDB?: IModelDB): T;
+    createNew(options: IModelFactory.IOptions): Promise<T>;
 
     /**
      * Get the preferred kernel language given a file path.
@@ -1052,6 +1056,26 @@ export namespace DocumentRegistry {
     preferredLanguage(path: string): string;
   }
 
+  /**
+   * A namespace for IModelFactory statics.
+   */
+  export namespace IModelFactory {
+    /**
+     * Options for creating a new document model.
+     */
+    export interface IOptions {
+      /**
+       * An optional path which can be used to set up a collaboration context.
+       */
+      path?: string;
+
+      /**
+       * A kernel language preference.
+       */
+      languagePreference?: string;
+    }
+  }
+
   /**
    * A type alias for a standard model factory.
    */
diff --git a/packages/docregistry/tsconfig.json b/packages/docregistry/tsconfig.json
index d23fa25fb13..91da8486719 100644
--- a/packages/docregistry/tsconfig.json
+++ b/packages/docregistry/tsconfig.json
@@ -19,7 +19,7 @@
       "path": "../coreutils"
     },
     {
-      "path": "../observables"
+      "path": "../datastore"
     },
     {
       "path": "../rendermime"
diff --git a/packages/documentsearch/package.json b/packages/documentsearch/package.json
index fe1d5ddaa16..9ea74f21ab9 100644
--- a/packages/documentsearch/package.json
+++ b/packages/documentsearch/package.json
@@ -37,6 +37,7 @@
     "@jupyterlab/codeeditor": "^1.0.0",
     "@jupyterlab/codemirror": "^1.0.1",
     "@jupyterlab/coreutils": "^3.0.0",
+    "@jupyterlab/datastore": "^1.0.0",
     "@jupyterlab/fileeditor": "^1.0.1",
     "@jupyterlab/notebook": "^1.0.1",
     "@phosphor/coreutils": "^1.3.1",
diff --git a/packages/documentsearch/src/providers/notebooksearchprovider.ts b/packages/documentsearch/src/providers/notebooksearchprovider.ts
index 20cf0e1b985..80703202321 100644
--- a/packages/documentsearch/src/providers/notebooksearchprovider.ts
+++ b/packages/documentsearch/src/providers/notebooksearchprovider.ts
@@ -3,10 +3,12 @@
 import { ISearchProvider, ISearchMatch } from '../index';
 import { CodeMirrorSearchProvider } from './codemirrorsearchprovider';
 
-import { NotebookPanel } from '@jupyterlab/notebook';
-import { CodeMirrorEditor } from '@jupyterlab/codemirror';
 import { Cell, MarkdownCell } from '@jupyterlab/cells';
+import { CodeMirrorEditor } from '@jupyterlab/codemirror';
+import { DatastoreExt } from '@jupyterlab/datastore';
+import { NotebookPanel } from '@jupyterlab/notebook';
 
+import { IDisposable } from '@phosphor/disposable';
 import { Signal, ISignal } from '@phosphor/signaling';
 import { Widget } from '@phosphor/widgets';
 
@@ -50,8 +52,13 @@ export class NotebookSearchProvider implements ISearchProvider<NotebookPanel> {
     this._query = query;
     // Listen for cell model change to redo the search in case of
     // new/pasted/deleted cells
-    const cellList = this._searchTarget.model.cells;
-    cellList.changed.connect(this._restartQuery.bind(this), this);
+    const { datastore, record } = this._searchTarget.content.model.data;
+    this._cellListener = DatastoreExt.listenField(
+      datastore,
+      { ...record, field: 'cells' },
+      this._restartQuery,
+      this
+    );
 
     let indexTotal = 0;
     const allMatches: ISearchMatch[] = [];
@@ -129,7 +136,10 @@ export class NotebookSearchProvider implements ISearchProvider<NotebookPanel> {
       queriesEnded.push(provider.endQuery());
       provider.changed.disconnect(this._onCmSearchProviderChanged, this);
     });
-    Signal.disconnectBetween(this._searchTarget.model.cells, this);
+    if (this._cellListener) {
+      this._cellListener.dispose();
+      this._cellListener = null;
+    }
 
     this._cmSearchProviders = [];
     this._unRenderedMarkdownCells.forEach((cell: MarkdownCell) => {
@@ -148,7 +158,10 @@ export class NotebookSearchProvider implements ISearchProvider<NotebookPanel> {
    * @returns A promise that resolves when all state has been cleaned up.
    */
   async endSearch(): Promise<void> {
-    Signal.disconnectBetween(this._searchTarget.model.cells, this);
+    if (this._cellListener) {
+      this._cellListener.dispose();
+      this._cellListener = null;
+    }
 
     const index = this._searchTarget.content.activeCellIndex;
     const searchEnded: Promise<void>[] = [];
@@ -368,4 +381,5 @@ export class NotebookSearchProvider implements ISearchProvider<NotebookPanel> {
   private _currentMatch: ISearchMatch;
   private _unRenderedMarkdownCells: MarkdownCell[] = [];
   private _changed = new Signal<this, void>(this);
+  private _cellListener: IDisposable;
 }
diff --git a/packages/documentsearch/tsconfig.json b/packages/documentsearch/tsconfig.json
index 219ad7850ee..eae26ac45e6 100644
--- a/packages/documentsearch/tsconfig.json
+++ b/packages/documentsearch/tsconfig.json
@@ -21,6 +21,9 @@
     {
       "path": "../coreutils"
     },
+    {
+      "path": "../datastore"
+    },
     {
       "path": "../fileeditor"
     },
diff --git a/packages/fileeditor-extension/src/index.ts b/packages/fileeditor-extension/src/index.ts
index 2379f659544..90521beb74e 100644
--- a/packages/fileeditor-extension/src/index.ts
+++ b/packages/fileeditor-extension/src/index.ts
@@ -249,6 +249,9 @@ function activate(
    */
   function updateWidget(widget: FileEditor): void {
     const editor = widget.editor;
+    if (!editor) {
+      return;
+    }
     Object.keys(config).forEach((key: keyof CodeEditor.IConfig) => {
       editor.setOption(key, config[key]);
     });
@@ -270,7 +273,7 @@ function activate(
       updateTracker();
     });
 
-  factory.widgetCreated.connect((sender, widget) => {
+  factory.widgetCreated.connect(async (sender, widget) => {
     widget.title.icon = EDITOR_ICON_CLASS;
 
     // Notify the widget tracker if restore data needs to update.
@@ -278,12 +281,14 @@ function activate(
       void tracker.save(widget);
     });
     void tracker.add(widget);
+    await widget.context.ready;
     updateWidget(widget.content);
   });
   app.docRegistry.addWidgetFactory(factory);
 
   // Handle the settings of new widgets.
-  tracker.widgetAdded.connect((sender, widget) => {
+  tracker.widgetAdded.connect(async (sender, widget) => {
+    await widget.context.ready;
     updateWidget(widget.content);
   });
 
@@ -448,9 +453,9 @@ function activate(
         const start = editor.getOffsetAt(selection.start);
         const end = editor.getOffsetAt(selection.end);
 
-        code = editor.model.value.text.substring(start, end);
+        code = editor.model.value.substring(start, end);
       } else if (MarkdownCodeBlocks.isMarkdown(extension)) {
-        const { text } = editor.model.value;
+        const text = editor.model.value;
         const blocks = MarkdownCodeBlocks.findMarkdownCodeBlocks(text);
 
         for (let block of blocks) {
@@ -467,8 +472,8 @@ function activate(
         code = editor.getLine(selection.start.line);
         const cursor = editor.getCursorPosition();
         if (cursor.line + 1 === editor.lineCount) {
-          let text = editor.model.value.text;
-          editor.model.value.text = text + '\n';
+          let text = editor.model.value;
+          editor.model.value = text + '\n';
         }
         editor.setCursorPosition({
           line: cursor.line + 1,
@@ -497,7 +502,7 @@ function activate(
 
       let code = '';
       let editor = widget.editor;
-      let text = editor.model.value.text;
+      let text = editor.model.value;
       let path = widget.context.path;
       let extension = PathExt.extname(path);
 
diff --git a/packages/fileeditor/package.json b/packages/fileeditor/package.json
index f71fd00f786..883d073c61e 100644
--- a/packages/fileeditor/package.json
+++ b/packages/fileeditor/package.json
@@ -37,6 +37,7 @@
   "dependencies": {
     "@jupyterlab/apputils": "^1.0.1",
     "@jupyterlab/codeeditor": "^1.0.0",
+    "@jupyterlab/datastore": "^1.0.0",
     "@jupyterlab/docregistry": "^1.0.1",
     "@jupyterlab/statusbar": "^1.0.1",
     "@phosphor/coreutils": "^1.3.1",
diff --git a/packages/fileeditor/src/widget.ts b/packages/fileeditor/src/widget.ts
index 84a7de4c906..dbf615b6310 100644
--- a/packages/fileeditor/src/widget.ts
+++ b/packages/fileeditor/src/widget.ts
@@ -1,7 +1,14 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { StackedLayout, Widget } from '@phosphor/widgets';
+import {
+  CodeEditor,
+  IEditorServices,
+  IEditorMimeTypeService,
+  CodeEditorWrapper
+} from '@jupyterlab/codeeditor';
+
+import { DatastoreExt } from '@jupyterlab/datastore';
 
 import {
   ABCWidgetFactory,
@@ -10,17 +17,12 @@ import {
   IDocumentWidget
 } from '@jupyterlab/docregistry';
 
-import {
-  CodeEditor,
-  IEditorServices,
-  IEditorMimeTypeService,
-  CodeEditorWrapper
-} from '@jupyterlab/codeeditor';
-
 import { PromiseDelegate } from '@phosphor/coreutils';
 
 import { Message } from '@phosphor/messaging';
 
+import { StackedLayout, Widget } from '@phosphor/widgets';
+
 /**
  * The data attribute added to a widget that can run code.
  */
@@ -45,39 +47,16 @@ export class FileEditorCodeWrapper extends CodeEditorWrapper {
     });
 
     const context = (this._context = options.context);
-    const editor = this.editor;
 
     this.addClass('jp-FileEditorCodeWrapper');
     this.node.dataset[CODE_RUNNER] = 'true';
     this.node.dataset[UNDOER] = 'true';
 
-    editor.model.value.text = context.model.toString();
     void context.ready.then(() => {
       this._onContextReady();
     });
 
-    if (context.model.modelDB.isCollaborative) {
-      let modelDB = context.model.modelDB;
-      void modelDB.connected.then(() => {
-        let collaborators = modelDB.collaborators;
-        if (!collaborators) {
-          return;
-        }
-
-        // Setup the selection style for collaborators
-        let localCollaborator = collaborators.localCollaborator;
-        this.editor.uuid = localCollaborator.sessionId;
-
-        this.editor.selectionStyle = {
-          ...CodeEditor.defaultSelectionStyle,
-          color: localCollaborator.color
-        };
-
-        collaborators.changed.connect(this._onCollaboratorsChanged, this);
-        // Trigger an initial onCollaboratorsChanged event.
-        this._onCollaboratorsChanged();
-      });
-    }
+    // TODO Let collaborators know who we are via a cursor.
   }
 
   /**
@@ -95,58 +74,44 @@ export class FileEditorCodeWrapper extends CodeEditorWrapper {
   }
 
   /**
-   * Handle actions that should be taken when the context is ready.
+   * Dispose of the resources held by the widget.
    */
-  private _onContextReady(): void {
+  dispose(): void {
     if (this.isDisposed) {
       return;
     }
-    const contextModel = this._context.model;
-    const editor = this.editor;
-    const editorModel = editor.model;
-
-    // Set the editor model value.
-    editorModel.value.text = contextModel.toString();
-
-    // Prevent the initial loading from disk from being in the editor history.
-    editor.clearHistory();
-
-    // Wire signal connections.
-    contextModel.contentChanged.connect(this._onContentChanged, this);
-
-    // Resolve the ready promise.
-    this._ready.resolve(undefined);
+    this._trimSelections();
+    super.dispose();
   }
 
   /**
-   * Handle a change in context model content.
+   * Remove selections from inactive cells to avoid
+   * spurious cursors.
    */
-  private _onContentChanged(): void {
-    const editorModel = this.editor.model;
-    const oldValue = editorModel.value.text;
-    const newValue = this._context.model.toString();
-
-    if (oldValue !== newValue) {
-      editorModel.value.text = newValue;
-    }
+  private _trimSelections(): void {
+    const { datastore, record } = this.model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'selections' },
+        { [this.editor.uuid]: null }
+      );
+    });
   }
 
   /**
-   * Handle a change to the collaborators on the model
-   * by updating UI elements associated with them.
+   * Handle actions that should be taken when the context is ready.
    */
-  private _onCollaboratorsChanged(): void {
-    // If there are selections corresponding to non-collaborators,
-    // they are stale and should be removed.
-    let collaborators = this._context.model.modelDB.collaborators;
-    if (!collaborators) {
+  private _onContextReady(): void {
+    if (this.isDisposed) {
       return;
     }
-    for (let key of this.editor.model.selections.keys()) {
-      if (!collaborators.has(key)) {
-        this.editor.model.selections.delete(key);
-      }
-    }
+    this.editor.model.value = this._context.model.toString();
+    // Prevent the initial loading from disk from being in the editor history.
+    this.editor.clearHistory();
+
+    // Resolve the ready promise.
+    this._ready.resolve(undefined);
   }
 
   protected _context: DocumentRegistry.Context;
@@ -167,30 +132,46 @@ export class FileEditor extends Widget {
     const context = (this._context = options.context);
     this._mimeTypeService = options.mimeTypeService;
 
-    let editorWidget = (this.editorWidget = new FileEditorCodeWrapper(options));
-    this.editor = editorWidget.editor;
-    this.model = editorWidget.model;
+    let layout = (this.layout = new StackedLayout());
+
+    context.ready.then(() => {
+      let editorWidget = (this._editorWidget = new FileEditorCodeWrapper(
+        options
+      ));
+      layout.addWidget(editorWidget);
+      this._onPathChanged();
+    });
 
     // Listen for changes to the path.
     context.pathChanged.connect(this._onPathChanged, this);
-    this._onPathChanged();
-
-    let layout = (this.layout = new StackedLayout());
-    layout.addWidget(editorWidget);
   }
 
   /**
    * Get the context for the editor widget.
    */
   get context(): DocumentRegistry.Context {
-    return this.editorWidget.context;
+    return this._context;
+  }
+
+  /**
+   * The code editor model associated with the file.
+   */
+  get model(): CodeEditor.IModel | null {
+    return this._editorWidget ? this._editorWidget.model : null;
+  }
+
+  /**
+   * The code editor widget associated with the file.
+   */
+  get editor(): CodeEditor.IEditor | null {
+    return this._editorWidget ? this._editorWidget.editor : null;
   }
 
   /**
    * A promise that resolves when the file editor is ready.
    */
   get ready(): Promise<void> {
-    return this.editorWidget.ready;
+    return this._editorWidget.ready;
   }
 
   /**
@@ -244,8 +225,8 @@ export class FileEditor extends Widget {
    * Ensure that the widget has focus.
    */
   private _ensureFocus(): void {
-    if (!this.editor.hasFocus()) {
-      this.editor.focus();
+    if (!this._editorWidget.editor.hasFocus()) {
+      this._editorWidget.editor.focus();
     }
   }
 
@@ -253,18 +234,14 @@ export class FileEditor extends Widget {
    * Handle a change to the path.
    */
   private _onPathChanged(): void {
-    const editor = this.editor;
     const localPath = this._context.localPath;
-
-    editor.model.mimeType = this._mimeTypeService.getMimeTypeByFilePath(
+    this.model.mimeType = this._mimeTypeService.getMimeTypeByFilePath(
       localPath
     );
   }
 
-  private editorWidget: FileEditorCodeWrapper;
-  public model: CodeEditor.IModel;
-  public editor: CodeEditor.IEditor;
-  protected _context: DocumentRegistry.Context;
+  private _context: DocumentRegistry.Context;
+  private _editorWidget: FileEditorCodeWrapper | null = null;
   private _mimeTypeService: IEditorMimeTypeService;
 }
 
diff --git a/packages/fileeditor/tsconfig.json b/packages/fileeditor/tsconfig.json
index daa66686b54..225f473c159 100644
--- a/packages/fileeditor/tsconfig.json
+++ b/packages/fileeditor/tsconfig.json
@@ -4,7 +4,9 @@
     "outDir": "lib",
     "rootDir": "src"
   },
-  "include": ["src/*"],
+  "include": [
+    "src/*"
+  ],
   "references": [
     {
       "path": "../apputils"
@@ -12,6 +14,9 @@
     {
       "path": "../codeeditor"
     },
+    {
+      "path": "../datastore"
+    },
     {
       "path": "../docregistry"
     },
diff --git a/packages/inspector/src/handler.ts b/packages/inspector/src/handler.ts
index e3c91aecd77..2eef879978e 100644
--- a/packages/inspector/src/handler.ts
+++ b/packages/inspector/src/handler.ts
@@ -69,8 +69,7 @@ export class InspectionHandler implements IDisposable, IInspector.IInspectable {
       // Call onEditorChange to cover the case where the user changes
       // the active cell
       this.onEditorChange();
-      editor.model.selections.changed.connect(this._onChange, this);
-      editor.model.value.changed.connect(this._onChange, this);
+      editor.model.data.datastore.changed.connect(this._onChange, this);
     }
   }
 
@@ -128,7 +127,7 @@ export class InspectionHandler implements IDisposable, IInspector.IInspectable {
       return;
     }
 
-    const text = editor.model.value.text;
+    const text = editor.model.value;
     const position = editor.getCursorPosition();
     const offset = Text.jsIndexToCharIndex(editor.getOffsetAt(position), text);
     const update: IInspector.IInspectorUpdate = { content: null };
diff --git a/packages/metapackage/package.json b/packages/metapackage/package.json
index ea9a39cb53f..084857d7841 100644
--- a/packages/metapackage/package.json
+++ b/packages/metapackage/package.json
@@ -47,6 +47,8 @@
     "@jupyterlab/coreutils": "^3.0.0",
     "@jupyterlab/csvviewer": "^1.0.1",
     "@jupyterlab/csvviewer-extension": "^1.0.1",
+    "@jupyterlab/datastore": "^1.0.0",
+    "@jupyterlab/datastore-extension": "^1.0.0",
     "@jupyterlab/docmanager": "^1.0.1",
     "@jupyterlab/docmanager-extension": "^1.0.1",
     "@jupyterlab/docregistry": "^1.0.1",
diff --git a/packages/metapackage/src/index.ts b/packages/metapackage/src/index.ts
index 38ee91d9b5c..aaeb8b47926 100644
--- a/packages/metapackage/src/index.ts
+++ b/packages/metapackage/src/index.ts
@@ -17,6 +17,8 @@ import '@jupyterlab/console-extension';
 import '@jupyterlab/coreutils';
 import '@jupyterlab/csvviewer';
 import '@jupyterlab/csvviewer-extension';
+import '@jupyterlab/datastore';
+import '@jupyterlab/datastore-extension';
 import '@jupyterlab/docmanager';
 import '@jupyterlab/docmanager-extension';
 import '@jupyterlab/docregistry';
diff --git a/packages/metapackage/tsconfig.json b/packages/metapackage/tsconfig.json
index dc0d758dfaf..7978a55f07c 100644
--- a/packages/metapackage/tsconfig.json
+++ b/packages/metapackage/tsconfig.json
@@ -54,6 +54,12 @@
     {
       "path": "../csvviewer-extension"
     },
+    {
+      "path": "../datastore"
+    },
+    {
+      "path": "../datastore-extension"
+    },
     {
       "path": "../docmanager"
     },
diff --git a/packages/notebook-extension/package.json b/packages/notebook-extension/package.json
index 36edff7a67d..91ff8f93508 100644
--- a/packages/notebook-extension/package.json
+++ b/packages/notebook-extension/package.json
@@ -41,6 +41,7 @@
     "@jupyterlab/cells": "^1.0.1",
     "@jupyterlab/codeeditor": "^1.0.0",
     "@jupyterlab/coreutils": "^3.0.0",
+    "@jupyterlab/datastore": "^1.0.0",
     "@jupyterlab/docmanager": "^1.0.1",
     "@jupyterlab/filebrowser": "^1.0.1",
     "@jupyterlab/launcher": "^1.0.1",
diff --git a/packages/notebook-extension/src/index.ts b/packages/notebook-extension/src/index.ts
index e88150e6230..1d475306910 100644
--- a/packages/notebook-extension/src/index.ts
+++ b/packages/notebook-extension/src/index.ts
@@ -28,6 +28,8 @@ import {
   URLExt
 } from '@jupyterlab/coreutils';
 
+import { DatastoreExt } from '@jupyterlab/datastore';
+
 import { IDocumentManager } from '@jupyterlab/docmanager';
 
 import { ArrayExt } from '@phosphor/algorithm';
@@ -956,10 +958,13 @@ function addCommands(
       const { context, content } = current;
 
       let cell = content.activeCell;
-      let metadata = cell.model.metadata.toJSON();
+      let metadata = DatastoreExt.getField(cell.data.datastore, {
+        ...cell.data.record,
+        field: 'metadata'
+      });
       let path = context.path;
       // ignore action in non-code cell
-      if (!cell || cell.model.type !== 'code') {
+      if (!cell || cell.type !== 'code') {
         return;
       }
 
@@ -973,11 +978,11 @@ function addCommands(
         // Get the selected code from the editor.
         const start = editor.getOffsetAt(selection.start);
         const end = editor.getOffsetAt(selection.end);
-        code = editor.model.value.text.substring(start, end);
+        code = editor.model.value.substring(start, end);
       } else {
         // no selection, find the complete statement around the current line
         const cursor = editor.getCursorPosition();
-        let srcLines = editor.model.value.text.split('\n');
+        let srcLines = editor.model.value.split('\n');
         let curLine = selection.start.line;
         while (
           curLine < editor.lineCount &&
@@ -1193,7 +1198,7 @@ function addCommands(
       const { context } = current;
 
       child.opener = null;
-      if (context.model.dirty && !context.model.readOnly) {
+      if (context.dirty && !context.readOnly) {
         return context.save().then(() => {
           child.location.assign(url);
         });
@@ -1626,11 +1631,18 @@ function addCommands(
         mode: 'split-bottom'
       });
 
+      // TODO: this needs some fixing as the model for how cells move
+      // has changed.
       const updateCloned = () => {
         void clonedOutputs.save(widget);
       };
       current.context.pathChanged.connect(updateCloned);
-      current.content.model.cells.changed.connect(updateCloned);
+      const { datastore, record } = current.content.model.data;
+      const cloneListener = DatastoreExt.listenField(
+        datastore,
+        { ...record, field: 'cells' },
+        updateCloned
+      );
 
       // Add the cloned output to the output widget tracker.
       void clonedOutputs.add(widget);
@@ -1638,7 +1650,7 @@ function addCommands(
       // Remove the output view if the parent notebook is closed.
       current.content.disposed.connect(() => {
         current.context.pathChanged.disconnect(updateCloned);
-        current.content.model.cells.changed.disconnect(updateCloned);
+        cloneListener.dispose();
         widget.dispose();
       });
     },
@@ -2238,7 +2250,7 @@ namespace Private {
         if (!this._cell) {
           this._cell = this._notebook.content.widgets[this._index] as CodeCell;
         }
-        if (!this._cell || this._cell.model.type !== 'code') {
+        if (!this._cell || this._cell.type !== 'code') {
           this.dispose();
           return;
         }
diff --git a/packages/notebook-extension/tsconfig.json b/packages/notebook-extension/tsconfig.json
index ff5d92896b3..3291e97884f 100644
--- a/packages/notebook-extension/tsconfig.json
+++ b/packages/notebook-extension/tsconfig.json
@@ -21,6 +21,9 @@
     {
       "path": "../coreutils"
     },
+    {
+      "path": "../datastore"
+    },
     {
       "path": "../docmanager"
     },
diff --git a/packages/notebook/package.json b/packages/notebook/package.json
index baedcceeb41..915d9bc0674 100644
--- a/packages/notebook/package.json
+++ b/packages/notebook/package.json
@@ -39,14 +39,17 @@
     "@jupyterlab/cells": "^1.0.1",
     "@jupyterlab/codeeditor": "^1.0.0",
     "@jupyterlab/coreutils": "^3.0.0",
+    "@jupyterlab/datastore": "^1.0.0",
     "@jupyterlab/docregistry": "^1.0.1",
-    "@jupyterlab/observables": "^2.2.0",
+    "@jupyterlab/outputarea": "^1.0.1",
     "@jupyterlab/rendermime": "^1.0.1",
     "@jupyterlab/services": "^4.0.1",
     "@jupyterlab/statusbar": "^1.0.1",
     "@jupyterlab/ui-components": "^1.0.0",
     "@phosphor/algorithm": "^1.1.3",
     "@phosphor/coreutils": "^1.3.1",
+    "@phosphor/datastore": "0.7.2",
+    "@phosphor/disposable": "^1.2.0",
     "@phosphor/domutils": "^1.1.3",
     "@phosphor/dragdrop": "^1.3.3",
     "@phosphor/messaging": "^1.2.3",
diff --git a/packages/notebook/src/actions.tsx b/packages/notebook/src/actions.tsx
index 3c1733ab633..b03605cbf75 100644
--- a/packages/notebook/src/actions.tsx
+++ b/packages/notebook/src/actions.tsx
@@ -1,8 +1,6 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { KernelMessage } from '@jupyterlab/services';
-
 import {
   IClientSession,
   Clipboard,
@@ -13,14 +11,23 @@ import {
 import { nbformat } from '@jupyterlab/coreutils';
 
 import {
-  ICellModel,
-  ICodeCellModel,
-  CodeCell,
   Cell,
-  MarkdownCell
+  CellData,
+  CodeCell,
+  CodeCellData,
+  ICellData,
+  MarkdownCell,
+  MarkdownCellData,
+  RawCellData
 } from '@jupyterlab/cells';
 
-import { ArrayExt, each, toArray } from '@phosphor/algorithm';
+import { DatastoreExt } from '@jupyterlab/datastore';
+
+import { OutputAreaData } from '@jupyterlab/outputarea';
+
+import { KernelMessage } from '@jupyterlab/services';
+
+import { ArrayExt, each } from '@phosphor/algorithm';
 
 import { JSONObject } from '@phosphor/coreutils';
 
@@ -99,6 +106,7 @@ export namespace NotebookActions {
    * The leading whitespace in the second cell will be removed.
    * If there is no content, two empty cells will be created.
    * Both cells will have the same type as the original cell.
+   * If the cells is are markdown cells, they will be unrendered.
    * This action can be undone.
    */
   export function splitCell(notebook: Notebook): void {
@@ -116,33 +124,51 @@ export namespace NotebookActions {
     const editor = child.editor;
     const position = editor.getCursorPosition();
     const offset = editor.getOffsetAt(position);
-    const orig = child.model.value.text;
+    const orig = child.editor.model.value;
 
     // Create new models to preserve history.
-    const clone0 = Private.cloneCell(nbModel, child.model);
-    const clone1 = Private.cloneCell(nbModel, child.model);
+    const clone0 = Private.cloneCell(nbModel, child);
+    const clone1 = Private.cloneCell(nbModel, child);
+
+    if (child.type === 'code') {
+      OutputAreaData.clear(clone0);
+    }
+    const datastore = nbModel.data.datastore;
+    DatastoreExt.withTransaction(datastore, () => {
+      const text0 = orig
+        .slice(0, offset)
+        .replace(/^\n+/, '')
+        .replace(/\n+$/, '');
+      const text1 = orig
+        .slice(offset)
+        .replace(/^\n+/, '')
+        .replace(/\n+$/, '');
+      DatastoreExt.updateField(
+        datastore,
+        { ...clone0.record, field: 'text' },
+        { index: 0, remove: orig.length, text: text0 }
+      );
+      DatastoreExt.updateField(
+        datastore,
+        { ...clone1.record, field: 'text' },
+        { index: 0, remove: orig.length, text: text1 }
+      );
+      DatastoreExt.updateField(
+        datastore,
+        { ...nbModel.data.record, field: 'cells' },
+        {
+          index,
+          remove: 1,
+          values: [clone0.record.record, clone1.record.record]
+        }
+      );
+    });
 
-    if (clone0.type === 'code') {
-      (clone0 as ICodeCellModel).outputs.clear();
+    if (child.type === 'markdown') {
+      (notebook.widgets[index] as MarkdownCell).rendered = false;
+      (notebook.widgets[index + 1] as MarkdownCell).rendered = false;
     }
-    clone0.value.text = orig
-      .slice(0, offset)
-      .replace(/^\n+/, '')
-      .replace(/\n+$/, '');
-    clone1.value.text = orig
-      .slice(offset)
-      .replace(/^\n+/, '')
-      .replace(/\n+$/, '');
-
-    // Make the changes while preserving history.
-    const cells = nbModel.cells;
-
-    cells.beginCompoundOperation();
-    cells.set(index, clone0);
-    cells.insert(index + 1, clone1);
-    cells.endCompoundOperation();
-
-    notebook.activeCellIndex++;
+    notebook.activeCellIndex = index + 1;
     Private.handleState(notebook, state);
   }
 
@@ -166,57 +192,68 @@ export namespace NotebookActions {
 
     const state = Private.getState(notebook);
     const toMerge: string[] = [];
-    const toDelete: ICellModel[] = [];
+    const toDelete: string[] = [];
     const model = notebook.model;
-    const cells = model.cells;
     const primary = notebook.activeCell;
     const active = notebook.activeCellIndex;
+    // The first active cell in the selection range.
+    const first = ArrayExt.findFirstIndex(notebook.widgets, w =>
+      notebook.isSelectedOrActive(w)
+    );
 
     // Get the cells to merge.
     notebook.widgets.forEach((child, index) => {
       if (notebook.isSelectedOrActive(child)) {
-        toMerge.push(child.model.value.text);
-        if (index !== active) {
-          toDelete.push(child.model);
-        }
+        toMerge.push(child.editor.model.value);
+        toDelete.push(child.data.record.record);
       }
     });
 
     // Check for only a single cell selected.
     if (toMerge.length === 1) {
       // Bail if it is the last cell.
-      if (active === cells.length - 1) {
+      if (active === notebook.widgets.length - 1) {
         return;
       }
 
       // Otherwise merge with the next cell.
-      const cellModel = cells.get(active + 1);
+      const next = notebook.widgets[active + 1];
 
-      toMerge.push(cellModel.value.text);
-      toDelete.push(cellModel);
+      toMerge.push(next.editor.model.value);
+      toDelete.push(next.data.record.record);
     }
 
     notebook.deselectAll();
 
     // Create a new cell for the source to preserve history.
-    const newModel = Private.cloneCell(model, primary.model);
-
-    newModel.value.text = toMerge.join('\n\n');
-    if (newModel.type === 'code') {
-      (newModel as ICodeCellModel).outputs.clear();
-    }
+    const clone = Private.cloneCell(model, primary);
+    const datastore = model.data.datastore;
 
-    // Make the changes while preserving history.
-    cells.beginCompoundOperation();
-    cells.set(active, newModel);
-    toDelete.forEach(cell => {
-      cells.removeValue(cell);
+    DatastoreExt.withTransaction(datastore, () => {
+      const text = toMerge.join('\n\n');
+      if (primary.type === 'code') {
+        OutputAreaData.clear(clone);
+      }
+      DatastoreExt.updateField(
+        datastore,
+        { ...clone.record, field: 'text' },
+        { index: 0, remove: primary.editor.model.value.length, text }
+      );
+      DatastoreExt.updateField(
+        datastore,
+        { ...model.data.record, field: 'cells' },
+        {
+          index: first,
+          remove: toDelete.length,
+          values: [clone.record.record]
+        }
+      );
     });
-    cells.endCompoundOperation();
 
     // If the original cell is a markdown cell, make sure
     // the new cell is unrendered.
-    if (primary instanceof MarkdownCell) {
+    notebook.activeCellIndex = first;
+    if (primary.type === 'markdown') {
       (notebook.activeCell as MarkdownCell).rendered = false;
     }
 
@@ -262,13 +299,19 @@ export namespace NotebookActions {
 
     const state = Private.getState(notebook);
     const model = notebook.model;
-    const cell = model.contentFactory.createCell(
-      notebook.notebookConfig.defaultCell,
-      {}
+    const cellId = model.contentFactory.createCell(
+      notebook.notebookConfig.defaultCell
     );
     const active = notebook.activeCellIndex;
 
-    model.cells.insert(active, cell);
+    const { datastore, record } = model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'cells' },
+        { index: active, remove: 0, values: [cellId] }
+      );
+    });
 
     // Make the newly inserted cell active.
     notebook.activeCellIndex = active;
@@ -294,12 +337,19 @@ export namespace NotebookActions {
 
     const state = Private.getState(notebook);
     const model = notebook.model;
-    const cell = model.contentFactory.createCell(
-      notebook.notebookConfig.defaultCell,
-      {}
+    const active = notebook.activeCellIndex;
+    const cellId = model.contentFactory.createCell(
+      notebook.notebookConfig.defaultCell
     );
 
-    model.cells.insert(notebook.activeCellIndex + 1, cell);
+    const { datastore, record } = model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'cells' },
+        { index: active + 1, remove: 0, values: [cellId] }
+      );
+    });
 
     // Make the newly inserted cell active.
     notebook.activeCellIndex++;
@@ -310,7 +360,7 @@ export namespace NotebookActions {
   /**
    * Move the selected cell(s) down.
    *
-   * @param notebook = The target notebook widget.
+   * @param widget - The target notebook widget.
    */
   export function moveDown(notebook: Notebook): void {
     if (!notebook.model || !notebook.activeCell) {
@@ -318,23 +368,47 @@ export namespace NotebookActions {
     }
 
     const state = Private.getState(notebook);
-    const cells = notebook.model.cells;
     const widgets = notebook.widgets;
 
-    cells.beginCompoundOperation();
-    for (let i = cells.length - 2; i > -1; i--) {
-      if (notebook.isSelectedOrActive(widgets[i])) {
-        if (!notebook.isSelectedOrActive(widgets[i + 1])) {
-          cells.move(i, i + 1);
-          if (notebook.activeCellIndex === i) {
-            notebook.activeCellIndex++;
-          }
-          notebook.select(widgets[i + 1]);
-          notebook.deselect(widgets[i]);
-        }
+    const toMove: string[] = [];
+    const indices: number[] = [];
+    const active = notebook.activeCellIndex;
+    widgets.forEach((cell, index) => {
+      if (notebook.isSelectedOrActive(cell)) {
+        toMove.push(cell.data.record.record);
+        indices.push(index);
       }
+    });
+    if (indices.length && indices[indices.length - 1] === widgets.length) {
+      return;
     }
-    cells.endCompoundOperation();
+    const { datastore, record } = notebook.model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      // Proceed through the toMove list in the reverse direction
+      // so we get the final ordering right.
+      toMove.reverse();
+      indices.reverse();
+      toMove.forEach((id, idx) => {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'cells' },
+          { index: indices[idx], remove: 1, values: [] }
+        );
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'cells' },
+          { index: indices[idx] + 1, remove: 0, values: [id] }
+        );
+      });
+    });
+
+    // Reselect the original cells.
+    widgets.forEach((cell, index) => {
+      if (toMove.indexOf(cell.data.record.record) !== -1) {
+        notebook.select(cell);
+      }
+    });
+    notebook.activeCellIndex = active + 1;
     Private.handleState(notebook, state, true);
   }
 
@@ -349,23 +423,44 @@ export namespace NotebookActions {
     }
 
     const state = Private.getState(notebook);
-    const cells = notebook.model.cells;
     const widgets = notebook.widgets;
 
-    cells.beginCompoundOperation();
-    for (let i = 1; i < cells.length; i++) {
-      if (notebook.isSelectedOrActive(widgets[i])) {
-        if (!notebook.isSelectedOrActive(widgets[i - 1])) {
-          cells.move(i, i - 1);
-          if (notebook.activeCellIndex === i) {
-            notebook.activeCellIndex--;
-          }
-          notebook.select(widgets[i - 1]);
-          notebook.deselect(widgets[i]);
-        }
+    const toMove: string[] = [];
+    const indices: number[] = [];
+    const active = notebook.activeCellIndex;
+    widgets.forEach((cell, index) => {
+      if (notebook.isSelectedOrActive(cell)) {
+        toMove.push(cell.data.record.record);
+        indices.push(index);
       }
+    });
+    if (indices.length && indices[0] === 0) {
+      return;
     }
-    cells.endCompoundOperation();
+    const { datastore, record } = notebook.model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      // Proceed through the toMove list in the forward direction
+      // so we get the final ordering right.
+      toMove.forEach((id, idx) => {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'cells' },
+          { index: indices[idx], remove: 1, values: [] }
+        );
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'cells' },
+          { index: indices[idx] - 1, remove: 0, values: [id] }
+        );
+      });
+    });
+    // Reselect the original cells.
+    widgets.forEach((cell, index) => {
+      if (toMove.indexOf(cell.data.record.record) !== -1) {
+        notebook.select(cell);
+      }
+    });
+    notebook.activeCellIndex = active - 1;
     Private.handleState(notebook, state, true);
   }
 
@@ -391,7 +486,6 @@ export namespace NotebookActions {
     }
 
     const state = Private.getState(notebook);
-
     Private.changeCellType(notebook, value);
     Private.handleState(notebook, state);
   }
@@ -452,12 +546,18 @@ export namespace NotebookActions {
     const model = notebook.model;
 
     if (notebook.activeCellIndex === notebook.widgets.length - 1) {
-      const cell = model.contentFactory.createCell(
-        notebook.notebookConfig.defaultCell,
-        {}
+      const cellId = model.contentFactory.createCell(
+        notebook.notebookConfig.defaultCell
       );
 
-      model.cells.push(cell);
+      const { datastore, record } = model.data;
+      DatastoreExt.withTransaction(datastore, () => {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'cells' },
+          { index: notebook.activeCellIndex + 1, remove: 0, values: [cellId] }
+        );
+      });
       notebook.activeCellIndex++;
       notebook.mode = 'edit';
     } else {
@@ -493,12 +593,18 @@ export namespace NotebookActions {
     const state = Private.getState(notebook);
     const promise = Private.runSelected(notebook, session);
     const model = notebook.model;
-    const cell = model.contentFactory.createCell(
-      notebook.notebookConfig.defaultCell,
-      {}
+    const cellId = model.contentFactory.createCell(
+      notebook.notebookConfig.defaultCell
     );
 
-    model.cells.insert(notebook.activeCellIndex + 1, cell);
+    const { datastore, record } = model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'cells' },
+        { index: notebook.activeCellIndex + 1, remove: 0, values: [cellId] }
+      );
+    });
     notebook.activeCellIndex++;
     notebook.mode = 'edit';
     Private.handleRunState(notebook, state, true);
@@ -548,14 +654,14 @@ export namespace NotebookActions {
     const previousIndex = notebook.activeCellIndex;
     const state = Private.getState(notebook);
     notebook.widgets.forEach((child, index) => {
-      if (child.model.type === 'markdown') {
+      if (child.type === 'markdown') {
         notebook.select(child);
         // This is to make sure that the activeCell
         // does not get executed
         notebook.activeCellIndex = index;
       }
     });
-    if (notebook.activeCell.model.type !== 'markdown') {
+    if (notebook.activeCell.type !== 'markdown') {
       return Promise.resolve(true);
     }
     const promise = Private.runSelected(notebook, session);
@@ -851,56 +957,70 @@ export namespace NotebookActions {
     const newCells = values.map(cell => {
       switch (cell.cell_type) {
         case 'code':
-          return model.contentFactory.createCodeCell({ cell });
+          return model.contentFactory.createCodeCell(
+            cell as nbformat.ICodeCell
+          );
         case 'markdown':
-          return model.contentFactory.createMarkdownCell({ cell });
+          return model.contentFactory.createMarkdownCell(
+            cell as nbformat.IMarkdownCell
+          );
         default:
-          return model.contentFactory.createRawCell({ cell });
+          return model.contentFactory.createRawCell(cell as nbformat.IRawCell);
       }
     });
 
-    const cells = notebook.model.cells;
     let index: number;
+    const { datastore, record } = model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      // Set the starting index of the paste operation depending upon the mode.
+      switch (mode) {
+        case 'below':
+          index = notebook.activeCellIndex;
+          break;
+        case 'above':
+          index = notebook.activeCellIndex - 1;
+          break;
+        case 'replace':
+          // Find the cells to delete.
+          const toDelete: number[] = [];
+
+          notebook.widgets.forEach((child, index) => {
+            const metadata = DatastoreExt.getField(child.data.datastore, {
+              ...child.data.record,
+              field: 'metadata'
+            });
+            const deletable = metadata['deletable'] !== false;
 
-    cells.beginCompoundOperation();
-
-    // Set the starting index of the paste operation depending upon the mode.
-    switch (mode) {
-      case 'below':
-        index = notebook.activeCellIndex;
-        break;
-      case 'above':
-        index = notebook.activeCellIndex - 1;
-        break;
-      case 'replace':
-        // Find the cells to delete.
-        const toDelete: number[] = [];
-
-        notebook.widgets.forEach((child, index) => {
-          const deletable = child.model.metadata.get('deletable') !== false;
+            if (notebook.isSelectedOrActive(child) && deletable) {
+              toDelete.push(index);
+            }
+          });
 
-          if (notebook.isSelectedOrActive(child) && deletable) {
-            toDelete.push(index);
+          // If cells are not deletable, we may not have anything to delete.
+          if (toDelete.length > 0) {
+            // Delete the cells as one undo event.
+            toDelete.reverse().forEach(i => {
+              DatastoreExt.updateField(
+                datastore,
+                { ...record, field: 'cells' },
+                { index: i, remove: 1, values: [] }
+              );
+            });
           }
-        });
-
-        // If cells are not deletable, we may not have anything to delete.
-        if (toDelete.length > 0) {
-          // Delete the cells as one undo event.
-          toDelete.reverse().forEach(i => {
-            cells.remove(i);
-          });
-        }
-        index = toDelete[0];
-        break;
-      default:
-        break;
-    }
+          index = toDelete[0]; // Now the last cell.
+          break;
+        default:
+          break;
+      }
 
-    newCells.forEach(cell => {
-      cells.insert(++index, cell);
+      newCells.forEach(cellId => {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'cells' },
+          { index: ++index, remove: 0, values: [cellId] }
+        );
+      });
     });
-    cells.endCompoundOperation();
 
     notebook.activeCellIndex += newCells.length;
     notebook.deselectAll();
@@ -919,13 +1039,7 @@ export namespace NotebookActions {
     if (!notebook.model || !notebook.activeCell) {
       return;
     }
-
-    const state = Private.getState(notebook);
-
-    notebook.mode = 'command';
-    notebook.model.cells.undo();
-    notebook.deselectAll();
-    Private.handleState(notebook, state);
+    // TODO
   }
 
   /**
@@ -940,13 +1054,7 @@ export namespace NotebookActions {
     if (!notebook.model || !notebook.activeCell) {
       return;
     }
-
-    const state = Private.getState(notebook);
-
-    notebook.mode = 'command';
-    notebook.model.cells.redo();
-    notebook.deselectAll();
-    Private.handleState(notebook, state);
+    // TODO
   }
 
   /**
@@ -995,13 +1103,20 @@ export namespace NotebookActions {
 
     const state = Private.getState(notebook);
 
-    each(notebook.model.cells, (cell: ICodeCellModel, index) => {
+    each(notebook.widgets, (cell: Cell, index) => {
       const child = notebook.widgets[index];
 
       if (notebook.isSelectedOrActive(child) && cell.type === 'code') {
-        cell.outputs.clear();
         (child as CodeCell).outputHidden = false;
-        cell.executionCount = null;
+        const { datastore, record } = cell.data;
+        DatastoreExt.withTransaction(datastore, () => {
+          OutputAreaData.clear(cell.data);
+          DatastoreExt.updateField(
+            datastore,
+            { ...record, field: 'executionCount' },
+            null
+          );
+        });
       }
     });
     Private.handleState(notebook, state);
@@ -1022,13 +1137,17 @@ export namespace NotebookActions {
 
     const state = Private.getState(notebook);
 
-    each(notebook.model.cells, (cell: ICodeCellModel, index) => {
-      const child = notebook.widgets[index];
-
+    each(notebook.widgets, (cell: Cell, index) => {
       if (cell.type === 'code') {
-        cell.outputs.clear();
-        cell.executionCount = null;
-        (child as CodeCell).outputHidden = false;
+        const { datastore, record } = cell.data;
+        DatastoreExt.withTransaction(datastore, () => {
+          OutputAreaData.clear(cell.data);
+          DatastoreExt.updateField(
+            datastore,
+            { ...record, field: 'executionCount' },
+            null
+          );
+        });
       }
     });
     Private.handleState(notebook, state);
@@ -1047,7 +1166,7 @@ export namespace NotebookActions {
     const state = Private.getState(notebook);
 
     notebook.widgets.forEach(cell => {
-      if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {
+      if (notebook.isSelectedOrActive(cell) && cell.type === 'code') {
         cell.inputHidden = true;
       }
     });
@@ -1067,7 +1186,7 @@ export namespace NotebookActions {
     const state = Private.getState(notebook);
 
     notebook.widgets.forEach(cell => {
-      if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {
+      if (notebook.isSelectedOrActive(cell) && cell.type === 'code') {
         cell.inputHidden = false;
       }
     });
@@ -1087,7 +1206,7 @@ export namespace NotebookActions {
     const state = Private.getState(notebook);
 
     notebook.widgets.forEach(cell => {
-      if (cell.model.type === 'code') {
+      if (cell.type === 'code') {
         cell.inputHidden = true;
       }
     });
@@ -1107,7 +1226,7 @@ export namespace NotebookActions {
     const state = Private.getState(notebook);
 
     notebook.widgets.forEach(cell => {
-      if (cell.model.type === 'code') {
+      if (cell.type === 'code') {
         cell.inputHidden = false;
       }
     });
@@ -1127,7 +1246,7 @@ export namespace NotebookActions {
     const state = Private.getState(notebook);
 
     notebook.widgets.forEach(cell => {
-      if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {
+      if (notebook.isSelectedOrActive(cell) && cell.type === 'code') {
         (cell as CodeCell).outputHidden = true;
       }
     });
@@ -1147,7 +1266,7 @@ export namespace NotebookActions {
     const state = Private.getState(notebook);
 
     notebook.widgets.forEach(cell => {
-      if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {
+      if (notebook.isSelectedOrActive(cell) && cell.type === 'code') {
         (cell as CodeCell).outputHidden = false;
       }
     });
@@ -1167,7 +1286,7 @@ export namespace NotebookActions {
     const state = Private.getState(notebook);
 
     notebook.widgets.forEach(cell => {
-      if (cell.model.type === 'code') {
+      if (cell.type === 'code') {
         (cell as CodeCell).outputHidden = true;
       }
     });
@@ -1187,7 +1306,7 @@ export namespace NotebookActions {
     const state = Private.getState(notebook);
 
     notebook.widgets.forEach(cell => {
-      if (cell.model.type === 'code') {
+      if (cell.type === 'code') {
         (cell as CodeCell).outputHidden = false;
       }
     });
@@ -1207,7 +1326,7 @@ export namespace NotebookActions {
     const state = Private.getState(notebook);
 
     notebook.widgets.forEach(cell => {
-      if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {
+      if (notebook.isSelectedOrActive(cell) && cell.type === 'code') {
         (cell as CodeCell).outputsScrolled = true;
       }
     });
@@ -1227,7 +1346,7 @@ export namespace NotebookActions {
     const state = Private.getState(notebook);
 
     notebook.widgets.forEach(cell => {
-      if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {
+      if (notebook.isSelectedOrActive(cell) && cell.type === 'code') {
         (cell as CodeCell).outputsScrolled = false;
       }
     });
@@ -1254,12 +1373,11 @@ export namespace NotebookActions {
     }
 
     const state = Private.getState(notebook);
-    const cells = notebook.model.cells;
 
     level = Math.min(Math.max(level, 1), 6);
     notebook.widgets.forEach((child, index) => {
       if (notebook.isSelectedOrActive(child)) {
-        Private.setMarkdownHeader(cells.get(index), level);
+        Private.setMarkdownHeader(child, level);
       }
     });
     Private.changeCellType(notebook, 'markdown');
@@ -1277,14 +1395,17 @@ export namespace NotebookActions {
    * No dialog will be presented if the notebook is already trusted.
    */
   export function trust(notebook: Notebook): Promise<void> {
-    if (!notebook.model) {
+    const model = notebook.model;
+    if (!model) {
       return Promise.resolve();
     }
     // Do nothing if already trusted.
-
-    const cells = toArray(notebook.model.cells);
-    const trusted = cells.every(cell => cell.trusted);
-
+    const trusted = notebook.widgets.every(cell =>
+      DatastoreExt.getField(cell.data.datastore, {
+        ...cell.data.record,
+        field: 'trusted'
+      })
+    );
     if (trusted) {
       return showDialog({
         body: 'Notebook is already trusted',
@@ -1298,8 +1419,15 @@ export namespace NotebookActions {
       buttons: [Dialog.cancelButton(), Dialog.warnButton()]
     }).then(result => {
       if (result.button.accept) {
-        cells.forEach(cell => {
-          cell.trusted = true;
+        DatastoreExt.withTransaction(model.data.datastore, () => {
+          notebook.widgets.forEach(cell => {
+            DatastoreExt.updateField(
+              cell.data.datastore,
+              { ...cell.data.record, field: 'trusted' },
+              true
+            );
+            OutputAreaData.setTrusted(cell.data, true);
+          });
         });
       }
     });
@@ -1385,19 +1513,28 @@ namespace Private {
    */
   export function cloneCell(
     model: INotebookModel,
-    cell: ICellModel
-  ): ICellModel {
-    switch (cell.type) {
+    cell: Cell
+  ): ICellData.DataLocation {
+    let id = '';
+    const { type, data } = cell;
+    switch (type) {
       case 'code':
-        // TODO why isn't modeldb or id passed here?
-        return model.contentFactory.createCodeCell({ cell: cell.toJSON() });
+        id = model.contentFactory.createCodeCell(CodeCellData.toJSON(data));
+        break;
       case 'markdown':
-        // TODO why isn't modeldb or id passed here?
-        return model.contentFactory.createMarkdownCell({ cell: cell.toJSON() });
+        id = model.contentFactory.createMarkdownCell(
+          MarkdownCellData.toJSON(data)
+        );
+        break;
       default:
-        // TODO why isn't modeldb or id passed here?
-        return model.contentFactory.createRawCell({ cell: cell.toJSON() });
+        id = model.contentFactory.createRawCell(RawCellData.toJSON(data));
+        break;
     }
+    return {
+      datastore: data.datastore,
+      record: { ...data.record, record: id },
+      outputs: data.outputs
+    };
   }
 
   /**
@@ -1438,10 +1575,11 @@ namespace Private {
         if (reason.message === 'KernelReplyNotOK') {
           selected.map(cell => {
             // Remove '*' prompt from cells that didn't execute
-            if (
-              cell.model.type === 'code' &&
-              (cell as CodeCell).model.executionCount == null
-            ) {
+            const executionCount = DatastoreExt.getField(cell.data.datastore, {
+              ...cell.data.record,
+              field: 'executionCount'
+            });
+            if (cell.type === 'code' && executionCount == null) {
               cell.setPrompt('');
             }
           });
@@ -1458,12 +1596,12 @@ namespace Private {
   /**
    * Run a cell.
    */
-  function runCell(
+  export function runCell(
     notebook: Notebook,
     cell: Cell,
     session?: IClientSession
   ): Promise<boolean> {
-    switch (cell.model.type) {
+    switch (cell.type) {
       case 'markdown':
         (cell as MarkdownCell).rendered = true;
         cell.inputHidden = false;
@@ -1514,7 +1652,7 @@ namespace Private {
               return ran;
             });
         }
-        (cell.model as ICodeCellModel).executionCount = null;
+        // (cell.model as ICodeCellData).executionCount = null;
         break;
       default:
         break;
@@ -1548,21 +1686,27 @@ namespace Private {
     const replace = (setNextInput as any).replace;
 
     if (replace) {
-      cell.model.value.text = text;
+      cell.editor.model.value = text;
       return;
     }
 
     // Create a new code cell and add as the next cell.
-    const newCell = notebook.model.contentFactory.createCodeCell({});
-    const cells = notebook.model.cells;
-    const index = ArrayExt.firstIndexOf(toArray(cells), cell.model);
-
-    newCell.value.text = text;
-    if (index === -1) {
-      cells.push(newCell);
-    } else {
-      cells.insert(index + 1, newCell);
-    }
+    const newCell = notebook.model.contentFactory.createCodeCell();
+    let index = ArrayExt.firstIndexOf(notebook.widgets, cell);
+    index = index === -1 ? notebook.widgets.length : index;
+    const { datastore, record, cells } = notebook.model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'cells' },
+        { index, remove: 0, values: [newCell] }
+      );
+      DatastoreExt.updateField(
+        datastore,
+        { ...cells, record: newCell, field: 'text' },
+        { index: 0, remove: 0, text }
+      );
+    });
   }
 
   /**
@@ -1585,7 +1729,7 @@ namespace Private {
 
     let data = notebook.widgets
       .filter(cell => notebook.isSelectedOrActive(cell))
-      .map(cell => cell.model.toJSON())
+      .map(cell => CellData.toJSON(cell.data))
       .map(cellJSON => {
         if ((cellJSON.metadata as JSONObject).deletable !== undefined) {
           delete (cellJSON.metadata as JSONObject).deletable;
@@ -1620,43 +1764,50 @@ namespace Private {
     value: nbformat.CellType
   ): void {
     const model = notebook.model;
-    const cells = model.cells;
+    const index = notebook.activeCellIndex;
 
-    cells.beginCompoundOperation();
-    notebook.widgets.forEach((child, index) => {
-      if (!notebook.isSelectedOrActive(child)) {
-        return;
-      }
-      if (child.model.type !== value) {
-        const cell = child.model.toJSON();
-        let newCell: ICellModel;
-
-        switch (value) {
-          case 'code':
-            newCell = model.contentFactory.createCodeCell({ cell });
-            break;
-          case 'markdown':
-            newCell = model.contentFactory.createMarkdownCell({ cell });
-            if (child.model.type === 'code') {
-              newCell.trusted = false;
-            }
-            break;
-          default:
-            newCell = model.contentFactory.createRawCell({ cell });
-            if (child.model.type === 'code') {
-              newCell.trusted = false;
-            }
+    const { datastore, record } = model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      notebook.widgets.forEach((child, index) => {
+        if (!notebook.isSelectedOrActive(child)) {
+          return;
         }
-        cells.set(index, newCell);
-      }
-      if (value === 'markdown') {
-        // Fetch the new widget and unrender it.
-        child = notebook.widgets[index];
-        (child as MarkdownCell).rendered = false;
-      }
+        if (child.type !== value) {
+          let cellId = '';
+          let cell = CellData.toJSON(child.data);
+          if (cell.type === 'code') {
+            // When we convert to another cell type,
+            // make sure it is flagged as untrusted.
+            cell['metadata']['trusted'] = false;
+          }
+          switch (value) {
+            case 'code':
+              cellId = model.contentFactory.createCodeCell(
+                cell as nbformat.ICodeCell
+              );
+              break;
+            case 'markdown':
+              cellId = model.contentFactory.createMarkdownCell(
+                cell as nbformat.IMarkdownCell
+              );
+              break;
+            default:
+              cellId = model.contentFactory.createRawCell(
+                cell as nbformat.IRawCell
+              );
+              break;
+          }
+          DatastoreExt.updateField(
+            datastore,
+            { ...record, field: 'cells' },
+            { index, remove: 1, values: [cellId] }
+          );
+        }
+      });
     });
-    cells.endCompoundOperation();
+    // TODO: unrender the new markdown cells.
     notebook.deselectAll();
+    notebook.activeCellIndex = index;
   }
 
   /**
@@ -1672,41 +1823,51 @@ namespace Private {
    */
   export function deleteCells(notebook: Notebook): void {
     const model = notebook.model;
-    const cells = model.cells;
     const toDelete: number[] = [];
 
     notebook.mode = 'command';
 
     // Find the cells to delete.
     notebook.widgets.forEach((child, index) => {
-      const deletable = child.model.metadata.get('deletable') !== false;
+      const { datastore, record } = child.data;
+      const metadata = DatastoreExt.getField(datastore, {
+        ...record,
+        field: 'metadata'
+      });
+      const deletable = metadata['deletable'] !== false;
 
       if (notebook.isSelectedOrActive(child) && deletable) {
         toDelete.push(index);
-        notebook.model.deletedCells.push(child.model.id);
+        notebook.model.deletedCells.push(child.data.record.record);
       }
     });
 
     // If cells are not deletable, we may not have anything to delete.
     if (toDelete.length > 0) {
-      // Delete the cells as one undo event.
-      cells.beginCompoundOperation();
-      // Delete cells in reverse order to maintain the correct indices.
-      toDelete.reverse().forEach(index => {
-        cells.remove(index);
+      const { datastore, record } = model.data;
+      DatastoreExt.withTransaction(datastore, () => {
+        // Delete cells in reverse order to maintain the correct indices.
+        toDelete.reverse().forEach(index => {
+          DatastoreExt.updateField(
+            datastore,
+            { ...record, field: 'cells' },
+            { index, remove: 1, values: [] }
+          );
+        });
+        // Add a new cell if the notebook is empty. This is done
+        // within the compound operation to make the deletion of
+        // a notebook's last cell undoable.
+        if (toDelete.length === notebook.widgets.length) {
+          const cellId = model.contentFactory.createCell(
+            notebook.notebookConfig.defaultCell
+          );
+          DatastoreExt.updateField(
+            datastore,
+            { ...record, field: 'cells' },
+            { index: 0, remove: 0, values: [cellId] }
+          );
+        }
       });
-      // Add a new cell if the notebook is empty. This is done
-      // within the compound operation to make the deletion of
-      // a notebook's last cell undoable.
-      if (!cells.length) {
-        cells.push(
-          model.contentFactory.createCell(
-            notebook.notebookConfig.defaultCell,
-            {}
-          )
-        );
-      }
-      cells.endCompoundOperation();
 
       // Select the *first* interior cell not deleted or the cell
       // *after* the last selected cell.
@@ -1725,9 +1886,9 @@ namespace Private {
   /**
    * Set the markdown header level of a cell.
    */
-  export function setMarkdownHeader(cell: ICellModel, level: number) {
+  export function setMarkdownHeader(cell: Cell, level: number) {
     // Remove existing header or leading white space.
-    let source = cell.value.text;
+    let source = cell.editor.model.value;
     const regex = /^(#+\s*)|^(\s*)/;
     const newHeader = Array(level + 1).join('#') + ' ';
     const matches = regex.exec(source);
@@ -1735,6 +1896,6 @@ namespace Private {
     if (matches) {
       source = source.slice(matches[0].length);
     }
-    cell.value.text = newHeader + source;
+    cell.editor.model.value = newHeader + source;
   }
 }
diff --git a/packages/notebook/src/celllist.ts b/packages/notebook/src/celllist.ts
deleted file mode 100644
index 72c0793040b..00000000000
--- a/packages/notebook/src/celllist.ts
+++ /dev/null
@@ -1,516 +0,0 @@
-// Copyright (c) Jupyter Development Team.
-// Distributed under the terms of the Modified BSD License.
-
-import {
-  ArrayExt,
-  IIterator,
-  IterableOrArrayLike,
-  each,
-  toArray,
-  ArrayIterator
-} from '@phosphor/algorithm';
-
-import { ISignal, Signal } from '@phosphor/signaling';
-
-import { ICellModel } from '@jupyterlab/cells';
-
-import {
-  IObservableMap,
-  ObservableMap,
-  IObservableList,
-  IObservableUndoableList,
-  IModelDB
-} from '@jupyterlab/observables';
-
-import { NotebookModel } from './model';
-
-/**
- * A cell list object that supports undo/redo.
- */
-export class CellList implements IObservableUndoableList<ICellModel> {
-  /**
-   * Construct the cell list.
-   */
-  constructor(modelDB: IModelDB, factory: NotebookModel.IContentFactory) {
-    this._factory = factory;
-    this._cellOrder = modelDB.createList<string>('cellOrder');
-    this._cellMap = new ObservableMap<ICellModel>();
-
-    this._cellOrder.changed.connect(this._onOrderChanged, this);
-  }
-
-  type: 'List';
-
-  /**
-   * A signal emitted when the cell list has changed.
-   */
-  get changed(): ISignal<this, IObservableList.IChangedArgs<ICellModel>> {
-    return this._changed;
-  }
-
-  /**
-   * Test whether the cell list has been disposed.
-   */
-  get isDisposed(): boolean {
-    return this._isDisposed;
-  }
-
-  /**
-   * Test whether the list is empty.
-   *
-   * @returns `true` if the cell list is empty, `false` otherwise.
-   *
-   * #### Notes
-   * This is a read-only property.
-   *
-   * #### Complexity
-   * Constant.
-   *
-   * #### Iterator Validity
-   * No changes.
-   */
-  get isEmpty(): boolean {
-    return this._cellOrder.length === 0;
-  }
-
-  /**
-   * Get the length of the cell list.
-   *
-   * @return The number of cells in the cell list.
-   *
-   * #### Notes
-   * This is a read-only property.
-   *
-   * #### Complexity
-   * Constant.
-   *
-   * #### Iterator Validity
-   * No changes.
-   */
-  get length(): number {
-    return this._cellOrder.length;
-  }
-
-  /**
-   * Create an iterator over the cells in the cell list.
-   *
-   * @returns A new iterator starting at the front of the cell list.
-   *
-   * #### Complexity
-   * Constant.
-   *
-   * #### Iterator Validity
-   * No changes.
-   */
-  iter(): IIterator<ICellModel> {
-    let arr: ICellModel[] = [];
-    for (let id of toArray(this._cellOrder)) {
-      arr.push(this._cellMap.get(id));
-    }
-    return new ArrayIterator<ICellModel>(arr);
-  }
-
-  /**
-   * Dispose of the resources held by the cell list.
-   */
-  dispose(): void {
-    if (this._isDisposed) {
-      return;
-    }
-    this._isDisposed = true;
-    Signal.clearData(this);
-    // Clean up the cell map and cell order objects.
-    for (let cell of this._cellMap.values()) {
-      cell.dispose();
-    }
-    this._cellMap.dispose();
-    this._cellOrder.dispose();
-  }
-
-  /**
-   * Get the cell at the specified index.
-   *
-   * @param index - The positive integer index of interest.
-   *
-   * @returns The cell at the specified index.
-   *
-   * #### Complexity
-   * Constant.
-   *
-   * #### Iterator Validity
-   * No changes.
-   *
-   * #### Undefined Behavior
-   * An `index` which is non-integral or out of range.
-   */
-  get(index: number): ICellModel {
-    return this._cellMap.get(this._cellOrder.get(index)) as ICellModel;
-  }
-
-  /**
-   * Set the cell at the specified index.
-   *
-   * @param index - The positive integer index of interest.
-   *
-   * @param cell - The cell to set at the specified index.
-   *
-   * #### Complexity
-   * Constant.
-   *
-   * #### Iterator Validity
-   * No changes.
-   *
-   * #### Undefined Behavior
-   * An `index` which is non-integral or out of range.
-   *
-   * #### Notes
-   * This should be considered to transfer ownership of the
-   * cell to the `CellList`. As such, `cell.dispose()` should
-   * not be called by other actors.
-   */
-  set(index: number, cell: ICellModel): void {
-    // Set the internal data structures.
-    this._cellMap.set(cell.id, cell);
-    this._cellOrder.set(index, cell.id);
-  }
-
-  /**
-   * Add a cell to the back of the cell list.
-   *
-   * @param cell - The cell to add to the back of the cell list.
-   *
-   * @returns The new length of the cell list.
-   *
-   * #### Complexity
-   * Constant.
-   *
-   * #### Iterator Validity
-   * No changes.
-   *
-   * #### Notes
-   * This should be considered to transfer ownership of the
-   * cell to the `CellList`. As such, `cell.dispose()` should
-   * not be called by other actors.
-   */
-  push(cell: ICellModel): number {
-    // Set the internal data structures.
-    this._cellMap.set(cell.id, cell);
-    let num = this._cellOrder.push(cell.id);
-    return num;
-  }
-
-  /**
-   * Insert a cell into the cell list at a specific index.
-   *
-   * @param index - The index at which to insert the cell.
-   *
-   * @param cell - The cell to set at the specified index.
-   *
-   * @returns The new length of the cell list.
-   *
-   * #### Complexity
-   * Linear.
-   *
-   * #### Iterator Validity
-   * No changes.
-   *
-   * #### Notes
-   * The `index` will be clamped to the bounds of the cell list.
-   *
-   * #### Undefined Behavior
-   * An `index` which is non-integral.
-   *
-   * #### Notes
-   * This should be considered to transfer ownership of the
-   * cell to the `CellList`. As such, `cell.dispose()` should
-   * not be called by other actors.
-   */
-  insert(index: number, cell: ICellModel): void {
-    // Set the internal data structures.
-    this._cellMap.set(cell.id, cell);
-    this._cellOrder.insert(index, cell.id);
-  }
-
-  /**
-   * Remove the first occurrence of a cell from the cell list.
-   *
-   * @param cell - The cell of interest.
-   *
-   * @returns The index of the removed cell, or `-1` if the cell
-   *   is not contained in the cell list.
-   *
-   * #### Complexity
-   * Linear.
-   *
-   * #### Iterator Validity
-   * Iterators pointing at the removed cell and beyond are invalidated.
-   */
-  removeValue(cell: ICellModel): number {
-    let index = ArrayExt.findFirstIndex(
-      toArray(this._cellOrder),
-      id => this._cellMap.get(id) === cell
-    );
-    this.remove(index);
-    return index;
-  }
-
-  /**
-   * Remove and return the cell at a specific index.
-   *
-   * @param index - The index of the cell of interest.
-   *
-   * @returns The cell at the specified index, or `undefined` if the
-   *   index is out of range.
-   *
-   * #### Complexity
-   * Constant.
-   *
-   * #### Iterator Validity
-   * Iterators pointing at the removed cell and beyond are invalidated.
-   *
-   * #### Undefined Behavior
-   * An `index` which is non-integral.
-   */
-  remove(index: number): ICellModel {
-    let id = this._cellOrder.get(index);
-    this._cellOrder.remove(index);
-    let cell = this._cellMap.get(id);
-    return cell;
-  }
-
-  /**
-   * Remove all cells from the cell list.
-   *
-   * #### Complexity
-   * Linear.
-   *
-   * #### Iterator Validity
-   * All current iterators are invalidated.
-   */
-  clear(): void {
-    this._cellOrder.clear();
-  }
-
-  /**
-   * Move a cell from one index to another.
-   *
-   * @parm fromIndex - The index of the element to move.
-   *
-   * @param toIndex - The index to move the element to.
-   *
-   * #### Complexity
-   * Constant.
-   *
-   * #### Iterator Validity
-   * Iterators pointing at the lesser of the `fromIndex` and the `toIndex`
-   * and beyond are invalidated.
-   *
-   * #### Undefined Behavior
-   * A `fromIndex` or a `toIndex` which is non-integral.
-   */
-  move(fromIndex: number, toIndex: number): void {
-    this._cellOrder.move(fromIndex, toIndex);
-  }
-
-  /**
-   * Push a set of cells to the back of the cell list.
-   *
-   * @param cells - An iterable or array-like set of cells to add.
-   *
-   * @returns The new length of the cell list.
-   *
-   * #### Complexity
-   * Linear.
-   *
-   * #### Iterator Validity
-   * No changes.
-   *
-   * #### Notes
-   * This should be considered to transfer ownership of the
-   * cells to the `CellList`. As such, `cell.dispose()` should
-   * not be called by other actors.
-   */
-  pushAll(cells: IterableOrArrayLike<ICellModel>): number {
-    let newValues = toArray(cells);
-    each(newValues, cell => {
-      // Set the internal data structures.
-      this._cellMap.set(cell.id, cell);
-      this._cellOrder.push(cell.id);
-    });
-    return this.length;
-  }
-
-  /**
-   * Insert a set of items into the cell list at the specified index.
-   *
-   * @param index - The index at which to insert the cells.
-   *
-   * @param cells - The cells to insert at the specified index.
-   *
-   * @returns The new length of the cell list.
-   *
-   * #### Complexity.
-   * Linear.
-   *
-   * #### Iterator Validity
-   * No changes.
-   *
-   * #### Notes
-   * The `index` will be clamped to the bounds of the cell list.
-   *
-   * #### Undefined Behavior.
-   * An `index` which is non-integral.
-   *
-   * #### Notes
-   * This should be considered to transfer ownership of the
-   * cells to the `CellList`. As such, `cell.dispose()` should
-   * not be called by other actors.
-   */
-  insertAll(index: number, cells: IterableOrArrayLike<ICellModel>): number {
-    let newValues = toArray(cells);
-    each(newValues, cell => {
-      this._cellMap.set(cell.id, cell);
-      this._cellOrder.beginCompoundOperation();
-      this._cellOrder.insert(index++, cell.id);
-      this._cellOrder.endCompoundOperation();
-    });
-    return this.length;
-  }
-
-  /**
-   * Remove a range of items from the cell list.
-   *
-   * @param startIndex - The start index of the range to remove (inclusive).
-   *
-   * @param endIndex - The end index of the range to remove (exclusive).
-   *
-   * @returns The new length of the cell list.
-   *
-   * #### Complexity
-   * Linear.
-   *
-   * #### Iterator Validity
-   * Iterators pointing to the first removed cell and beyond are invalid.
-   *
-   * #### Undefined Behavior
-   * A `startIndex` or `endIndex` which is non-integral.
-   */
-  removeRange(startIndex: number, endIndex: number): number {
-    this._cellOrder.removeRange(startIndex, endIndex);
-    return this.length;
-  }
-
-  /**
-   * Whether the object can redo changes.
-   */
-  get canRedo(): boolean {
-    return this._cellOrder.canRedo;
-  }
-
-  /**
-   * Whether the object can undo changes.
-   */
-  get canUndo(): boolean {
-    return this._cellOrder.canUndo;
-  }
-
-  /**
-   * Begin a compound operation.
-   *
-   * @param isUndoAble - Whether the operation is undoable.
-   *   The default is `true`.
-   */
-  beginCompoundOperation(isUndoAble?: boolean): void {
-    this._cellOrder.beginCompoundOperation(isUndoAble);
-  }
-
-  /**
-   * End a compound operation.
-   */
-  endCompoundOperation(): void {
-    this._cellOrder.endCompoundOperation();
-  }
-
-  /**
-   * Undo an operation.
-   */
-  undo(): void {
-    this._cellOrder.undo();
-  }
-
-  /**
-   * Redo an operation.
-   */
-  redo(): void {
-    this._cellOrder.redo();
-  }
-
-  /**
-   * Clear the change stack.
-   */
-  clearUndo(): void {
-    // Dispose of cells not in the current
-    // cell order.
-    for (let key of this._cellMap.keys()) {
-      if (
-        ArrayExt.findFirstIndex(toArray(this._cellOrder), id => id === key) ===
-        -1
-      ) {
-        let cell = this._cellMap.get(key) as ICellModel;
-        cell.dispose();
-        this._cellMap.delete(key);
-      }
-    }
-    this._cellOrder.clearUndo();
-  }
-
-  private _onOrderChanged(
-    order: IObservableUndoableList<string>,
-    change: IObservableList.IChangedArgs<string>
-  ): void {
-    if (change.type === 'add' || change.type === 'set') {
-      each(change.newValues, id => {
-        if (!this._cellMap.has(id)) {
-          let cellDB = this._factory.modelDB;
-          let cellType = cellDB.createValue(id + '.type');
-          let cell: ICellModel;
-          switch (cellType.get()) {
-            case 'code':
-              cell = this._factory.createCodeCell({ id: id });
-              break;
-            case 'markdown':
-              cell = this._factory.createMarkdownCell({ id: id });
-              break;
-            default:
-              cell = this._factory.createRawCell({ id: id });
-              break;
-          }
-          this._cellMap.set(id, cell);
-        }
-      });
-    }
-    let newValues: ICellModel[] = [];
-    let oldValues: ICellModel[] = [];
-    each(change.newValues, id => {
-      newValues.push(this._cellMap.get(id));
-    });
-    each(change.oldValues, id => {
-      oldValues.push(this._cellMap.get(id));
-    });
-    this._changed.emit({
-      type: change.type,
-      oldIndex: change.oldIndex,
-      newIndex: change.newIndex,
-      oldValues,
-      newValues
-    });
-  }
-
-  private _isDisposed: boolean = false;
-  private _cellOrder: IObservableUndoableList<string> = null;
-  private _cellMap: IObservableMap<ICellModel> = null;
-  private _changed = new Signal<this, IObservableList.IChangedArgs<ICellModel>>(
-    this
-  );
-  private _factory: NotebookModel.IContentFactory = null;
-}
diff --git a/packages/notebook/src/data.ts b/packages/notebook/src/data.ts
new file mode 100644
index 00000000000..f82889cfd13
--- /dev/null
+++ b/packages/notebook/src/data.ts
@@ -0,0 +1,113 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import { DatastoreExt } from '@jupyterlab/datastore';
+
+import { ICellData, CellData } from '@jupyterlab/cells';
+
+import { IOutputData, OutputData } from '@jupyterlab/rendermime';
+
+import { ReadonlyJSONValue } from '@phosphor/coreutils';
+
+import {
+  Datastore,
+  Fields,
+  ListField,
+  MapField,
+  RegisterField
+} from '@phosphor/datastore';
+
+/**
+ * Interfaces for specifying how notebooks store data in datastores.
+ */
+export namespace INotebookData {
+  /**
+   * A specification for where notebook data is stored in a datastore.
+   */
+  export type DataLocation = DatastoreExt.DataLocation & {
+    /**
+     * The top-level record for the notebook data.
+     */
+    record: DatastoreExt.RecordLocation<Schema>;
+
+    /**
+     * The table holding cell data.
+     */
+    cells: DatastoreExt.TableLocation<ICellData.Schema>;
+
+    /**
+     * The table holding output data.
+     */
+    outputs: DatastoreExt.TableLocation<IOutputData.Schema>;
+  };
+
+  /**
+   * An type alias for a notebook data schema.
+   */
+  export type Schema = {
+    /**
+     * The schema id.
+     */
+    id: string;
+
+    /**
+     * The schema fields.
+     */
+    fields: {
+      /**
+       * The major nbformat version number.
+       */
+      readonly nbformat: RegisterField<number>;
+
+      /**
+       * The minor nbformat version number.
+       */
+      readonly nbformatMinor: RegisterField<number>;
+
+      /**
+       * The list of cell IDs in the notebook.
+       */
+      readonly cells: ListField<string>;
+
+      /**
+       * The metadata for the notebook.
+       */
+      readonly metadata: MapField<ReadonlyJSONValue>;
+    };
+  };
+}
+
+/**
+ * Utilities for working with notebook data.
+ */
+export namespace NotebookData {
+  /**
+   * Create an in-memory datastore capable of holding the data for an output area.
+   */
+  export function createStore(id: number = 1): Datastore {
+    return Datastore.create({
+      id,
+      schemas: [SCHEMA, CellData.SCHEMA, OutputData.SCHEMA]
+    });
+  }
+
+  /**
+   * A concrete notebook schema, available at runtime.
+   */
+  export const SCHEMA: INotebookData.Schema = {
+    /**
+     * The schema id.
+     */
+    id: '@jupyterlab/notebook:notebookmodel.v1',
+
+    /**
+     * Concrete realizations of the schema fields, available at runtime.
+     */
+    fields: {
+      nbformat: Fields.Number(),
+      nbformatMinor: Fields.Number(),
+      cells: Fields.List<string>(),
+      metadata: Fields.Map<ReadonlyJSONValue>()
+    }
+  };
+}
diff --git a/packages/notebook/src/default-toolbar.tsx b/packages/notebook/src/default-toolbar.tsx
index 8e1b4e634a5..1651c31555b 100644
--- a/packages/notebook/src/default-toolbar.tsx
+++ b/packages/notebook/src/default-toolbar.tsx
@@ -77,7 +77,7 @@ export namespace ToolbarItems {
    */
   export function createSaveButton(panel: NotebookPanel): Widget {
     function onClick() {
-      if (panel.context.model.readOnly) {
+      if (panel.context.readOnly) {
         return showDialog({
           title: 'Cannot Save',
           body: 'Document is read-only',
@@ -270,11 +270,11 @@ export class CellTypeSwitcher extends ReactWidget {
   render() {
     let value = '-';
     if (this._notebook.activeCell) {
-      value = this._notebook.activeCell.model.type;
+      value = this._notebook.activeCell.type;
     }
     for (let widget of this._notebook.widgets) {
       if (this._notebook.isSelectedOrActive(widget)) {
-        if (widget.model.type !== value) {
+        if (widget.type !== value) {
           value = '-';
           break;
         }
diff --git a/packages/notebook/src/model.ts b/packages/notebook/src/model.ts
index 40206731324..64d1a1aebe5 100644
--- a/packages/notebook/src/model.ts
+++ b/packages/notebook/src/model.ts
@@ -1,42 +1,36 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { DocumentModel, DocumentRegistry } from '@jupyterlab/docregistry';
+import { showDialog, Dialog } from '@jupyterlab/apputils';
+
+import { DatastoreExt } from '@jupyterlab/datastore';
+
+import { DocumentRegistry } from '@jupyterlab/docregistry';
 
 import {
-  ICellModel,
-  ICodeCellModel,
-  IRawCellModel,
-  IMarkdownCellModel,
-  CodeCellModel,
-  RawCellModel,
-  MarkdownCellModel,
-  CellModel
+  CellData,
+  CodeCellData,
+  ICellData,
+  RawCellData,
+  MarkdownCellData
 } from '@jupyterlab/cells';
 
 import { nbformat } from '@jupyterlab/coreutils';
 
-import { UUID } from '@phosphor/coreutils';
+import { IOutputData, OutputData } from '@jupyterlab/rendermime';
 
-import {
-  IObservableJSON,
-  IObservableUndoableList,
-  IObservableList,
-  IModelDB
-} from '@jupyterlab/observables';
+import { ReadonlyJSONObject, UUID } from '@phosphor/coreutils';
 
-import { CellList } from './celllist';
-import { showDialog, Dialog } from '@jupyterlab/apputils';
+import { Datastore } from '@phosphor/datastore';
+
+import { ISignal, Signal } from '@phosphor/signaling';
+
+import { INotebookData, NotebookData } from './data';
 
 /**
  * The definition of a model object for a notebook widget.
  */
 export interface INotebookModel extends DocumentRegistry.IModel {
-  /**
-   * The list of cells in the notebook.
-   */
-  readonly cells: IObservableUndoableList<ICellModel>;
-
   /**
    * The cell model factory for the notebook.
    */
@@ -55,7 +49,12 @@ export interface INotebookModel extends DocumentRegistry.IModel {
   /**
    * The metadata associated with the notebook.
    */
-  readonly metadata: IObservableJSON;
+  readonly metadata: ReadonlyJSONObject;
+
+  /**
+   * The location of the notebook data in a datastore.
+   */
+  readonly data: INotebookData.DataLocation;
 
   /**
    * The array of deleted cells since the notebook was last run.
@@ -66,25 +65,51 @@ export interface INotebookModel extends DocumentRegistry.IModel {
 /**
  * An implementation of a notebook Model.
  */
-export class NotebookModel extends DocumentModel implements INotebookModel {
+export class NotebookModel implements INotebookModel {
   /**
    * Construct a new notebook model.
    */
   constructor(options: NotebookModel.IOptions = {}) {
-    super(options.languagePreference, options.modelDB);
     let factory = options.contentFactory || NotebookModel.defaultContentFactory;
-    this.contentFactory = factory.clone(this.modelDB.view('cells'));
-    this._cells = new CellList(this.modelDB, this.contentFactory);
-    this._cells.changed.connect(this._onCellsChanged, this);
-
-    // Handle initial metadata.
-    let metadata = this.modelDB.createMap('metadata');
-    if (!metadata.has('language_info')) {
-      let name = options.languagePreference || '';
-      metadata.set('language_info', { name });
+    if (!options.data) {
+      const datastore = (this._store = NotebookData.createStore());
+      this.data = {
+        datastore,
+        record: {
+          schema: NotebookData.SCHEMA,
+          record: 'data'
+        },
+        cells: {
+          schema: CellData.SCHEMA
+        },
+        outputs: {
+          schema: OutputData.SCHEMA
+        }
+      };
+    } else {
+      this.data = options.data;
     }
-    this._ensureMetadata();
-    metadata.changed.connect(this.triggerContentChange, this);
+    const { datastore, record } = this.data;
+    if (!DatastoreExt.getRecord(datastore, record)) {
+      this.isPrepopulated = false;
+      // Handle initialization of data.
+      DatastoreExt.withTransaction(datastore, () => {
+        DatastoreExt.updateRecord(datastore, record, {
+          nbformat: nbformat.MAJOR_VERSION,
+          nbformatMinor: nbformat.MINOR_VERSION
+        });
+        this._ensureMetadata();
+      });
+    } else {
+      this.isPrepopulated = true;
+    }
+
+    // Get a content factory that will create new content in the notebook
+    // data location.
+    this.contentFactory = factory.clone(this.data);
+
+    // Trigger a content change when appropriate.
+    datastore.changed.connect(this._onGenericChange, this);
     this._deletedCells = [];
   }
 
@@ -94,38 +119,52 @@ export class NotebookModel extends DocumentModel implements INotebookModel {
   readonly contentFactory: NotebookModel.IContentFactory;
 
   /**
-   * The metadata associated with the notebook.
+   * The location of the data in the notebook.
    */
-  get metadata(): IObservableJSON {
-    return this.modelDB.get('metadata') as IObservableJSON;
-  }
+  readonly data: INotebookData.DataLocation;
 
   /**
-   * Get the observable list of notebook cells.
+   * Whether the notebook model is collaborative.
    */
-  get cells(): IObservableUndoableList<ICellModel> {
-    return this._cells;
+  readonly isCollaborative = true;
+
+  /**
+   * Whether the notebook model comes prepopulated.
+   */
+  readonly isPrepopulated: boolean;
+
+  /**
+   * The metadata associated with the notebook.
+   */
+  get metadata(): ReadonlyJSONObject {
+    const { datastore, record } = this.data;
+    return DatastoreExt.getField(datastore, { ...record, field: 'metadata' });
   }
 
   /**
    * The major version number of the nbformat.
    */
   get nbformat(): number {
-    return this._nbformat;
+    const { datastore, record } = this.data;
+    return DatastoreExt.getField(datastore, { ...record, field: 'nbformat' });
   }
 
   /**
    * The minor version number of the nbformat.
    */
   get nbformatMinor(): number {
-    return this._nbformatMinor;
+    const { datastore, record } = this.data;
+    return DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'nbformatMinor'
+    });
   }
 
   /**
    * The default kernel name of the document.
    */
   get defaultKernelName(): string {
-    let spec = this.metadata.get('kernelspec') as nbformat.IKernelspecMetadata;
+    let spec = this.metadata['kernelspec'] as nbformat.IKernelspecMetadata;
     return spec ? spec.name : '';
   }
 
@@ -136,28 +175,47 @@ export class NotebookModel extends DocumentModel implements INotebookModel {
     return this._deletedCells;
   }
 
+  /**
+   * A signal emitted when the document content changes.
+   */
+  get contentChanged(): ISignal<this, void> {
+    return this._contentChanged;
+  }
+
+  /**
+   * The default kernel name of the document.
+   *
+   * #### Notes
+   * This is a read-only property.
+   */
+
   /**
    * The default kernel language of the document.
    */
   get defaultKernelLanguage(): string {
-    let info = this.metadata.get(
-      'language_info'
-    ) as nbformat.ILanguageInfoMetadata;
+    let info = this.metadata['language_info'] as nbformat.ILanguageInfoMetadata;
     return info ? info.name : '';
   }
 
+  /**
+   * Whether the model has been disposed.
+   */
+  get isDisposed(): boolean {
+    return this._isDisposed;
+  }
+
   /**
    * Dispose of the resources held by the model.
    */
   dispose(): void {
     // Do nothing if already disposed.
-    if (this.cells === null) {
+    if (this._isDisposed) {
       return;
     }
-    let cells = this.cells;
-    this._cells = null;
-    cells.dispose();
-    super.dispose();
+    if (this._store) {
+      this._store.dispose();
+      this._store = null;
+    }
   }
 
   /**
@@ -175,27 +233,34 @@ export class NotebookModel extends DocumentModel implements INotebookModel {
    */
   fromString(value: string): void {
     this.fromJSON(JSON.parse(value));
+    this._contentChanged.emit();
   }
 
   /**
    * Serialize the model to JSON.
    */
   toJSON(): nbformat.INotebookContent {
-    let cells: nbformat.ICell[] = [];
-    for (let i = 0; i < this.cells.length; i++) {
-      let cell = this.cells.get(i);
-      cells.push(cell.toJSON());
+    let cellsJSON: nbformat.ICell[] = [];
+    let { datastore, record, cells, outputs } = this.data;
+    let data = DatastoreExt.getRecord(datastore, record);
+    for (let i = 0; i < data.cells.length; i++) {
+      let cell = CellData.toJSON({
+        datastore,
+        record: { ...cells, record: data.cells[i] },
+        outputs
+      });
+      cellsJSON.push(cell);
     }
     this._ensureMetadata();
     let metadata = Object.create(null) as nbformat.INotebookMetadata;
-    for (let key of this.metadata.keys()) {
-      metadata[key] = JSON.parse(JSON.stringify(this.metadata.get(key)));
+    for (let key of Object.keys(this.metadata)) {
+      metadata[key] = JSON.parse(JSON.stringify(this.metadata[key]));
     }
     return {
       metadata,
-      nbformat_minor: this._nbformatMinor,
-      nbformat: this._nbformat,
-      cells
+      nbformat_minor: data.nbformatMinor,
+      nbformat: data.nbformat,
+      cells: cellsJSON
     };
   }
 
@@ -206,131 +271,181 @@ export class NotebookModel extends DocumentModel implements INotebookModel {
    * Should emit a [contentChanged] signal.
    */
   fromJSON(value: nbformat.INotebookContent): void {
-    let cells: ICellModel[] = [];
-    let factory = this.contentFactory;
-    for (let cell of value.cells) {
-      switch (cell.cell_type) {
-        case 'code':
-          cells.push(factory.createCodeCell({ cell }));
-          break;
-        case 'markdown':
-          cells.push(factory.createMarkdownCell({ cell }));
-          break;
-        case 'raw':
-          cells.push(factory.createRawCell({ cell }));
-          break;
-        default:
-          continue;
+    let { datastore, record, cells, outputs } = this.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      const cellIds: string[] = [];
+      for (let cell of value.cells) {
+        const id = UUID.uuid4();
+        cellIds.push(id);
+        const loc = {
+          datastore,
+          record: { ...cells, record: id },
+          outputs
+        };
+        switch (cell.cell_type) {
+          case 'code':
+            CodeCellData.fromJSON(loc, cell as nbformat.ICodeCell);
+            break;
+          case 'markdown':
+            MarkdownCellData.fromJSON(loc, cell as nbformat.IMarkdownCell);
+            break;
+          case 'raw':
+            RawCellData.fromJSON(loc, cell as nbformat.IRawCell);
+            break;
+          default:
+            continue;
+        }
       }
-    }
-    this.cells.beginCompoundOperation();
-    this.cells.clear();
-    this.cells.pushAll(cells);
-    this.cells.endCompoundOperation();
-
-    let oldValue = 0;
-    let newValue = 0;
-    this._nbformatMinor = nbformat.MINOR_VERSION;
-    this._nbformat = nbformat.MAJOR_VERSION;
-    const origNbformat = value.metadata.orig_nbformat;
-
-    if (value.nbformat !== this._nbformat) {
-      oldValue = this._nbformat;
-      this._nbformat = newValue = value.nbformat;
-      this.triggerStateChange({ name: 'nbformat', oldValue, newValue });
-    }
-    if (value.nbformat_minor > this._nbformatMinor) {
-      oldValue = this._nbformatMinor;
-      this._nbformatMinor = newValue = value.nbformat_minor;
-      this.triggerStateChange({ name: 'nbformatMinor', oldValue, newValue });
-    }
-
-    // Alert the user if the format changes.
-    if (origNbformat !== undefined && this._nbformat !== origNbformat) {
-      const newer = this._nbformat > origNbformat;
-      const msg = `This notebook has been converted from ${
-        newer ? 'an older' : 'a newer'
-      } notebook format (v${origNbformat}) to the current notebook format (v${
-        this._nbformat
-      }). The next time you save this notebook, the current notebook format (v${
-        this._nbformat
-      }) will be used. ${
-        newer
-          ? 'Older versions of Jupyter may not be able to read the new format.'
-          : 'Some features of the original notebook may not be available.'
-      }  To preserve the original format version, close the notebook without saving it.`;
-      void showDialog({
-        title: 'Notebook converted',
-        body: msg,
-        buttons: [Dialog.okButton()]
+      const cellLoc: DatastoreExt.FieldLocation<
+        INotebookData.Schema,
+        'cells'
+      > = { ...record, field: 'cells' };
+      const oldCells = DatastoreExt.getField(datastore, cellLoc);
+      DatastoreExt.updateField(datastore, cellLoc, {
+        index: 0,
+        remove: oldCells.length,
+        values: cellIds
       });
-    }
+      oldCells.forEach(cell =>
+        CellData.clear({
+          datastore,
+          outputs: this.data.outputs,
+          record: { ...this.data.cells, record: cell }
+        })
+      );
+
+      let newValue = 0;
+      const origNbformat = value.metadata.orig_nbformat;
+
+      if (value.nbformat !== nbformat.MAJOR_VERSION) {
+        newValue = value.nbformat;
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'nbformat' },
+          newValue
+        );
+      }
+      if (value.nbformat_minor > nbformat.MINOR_VERSION) {
+        newValue = value.nbformat_minor;
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'nbformatMinor' },
+          newValue
+        );
+      }
+
+      // Alert the user if the format changes.
+      if (origNbformat !== undefined && newValue !== origNbformat) {
+        const newer = newValue > origNbformat;
+        const msg = `This notebook has been converted from ${
+          newer ? 'an older' : 'a newer'
+        } notebook format (v${origNbformat}) to the current notebook format (v${newValue}). The next time you save this notebook, the current notebook format (v${newValue}) will be used. ${
+          newer
+            ? 'Older versions of Jupyter may not be able to read the new format.'
+            : 'Some features of the original notebook may not be available.'
+        }  To preserve the original format version, close the notebook without saving it.`;
+        void showDialog({
+          title: 'Notebook converted',
+          body: msg,
+          buttons: [Dialog.okButton()]
+        });
+      }
 
-    // Update the metadata.
-    this.metadata.clear();
-    let metadata = value.metadata;
-    for (let key in metadata) {
+      // Update the metadata.
+      let metadata = { ...value.metadata };
       // orig_nbformat is not intended to be stored per spec.
-      if (key === 'orig_nbformat') {
-        continue;
+      delete metadata['orig_nbformat'];
+      let oldMetadata = { ...this.metadata };
+      for (let key in oldMetadata) {
+        oldMetadata[key] = null;
       }
-      this.metadata.set(key, metadata[key]);
-    }
-    this._ensureMetadata();
-    this.dirty = true;
+      let update = { ...oldMetadata, ...metadata };
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'metadata' },
+        update
+      );
+      this._ensureMetadata();
+    });
   }
 
   /**
    * Initialize the model with its current state.
    */
   initialize(): void {
-    super.initialize();
-    this.cells.clearUndo();
-  }
-
-  /**
-   * Handle a change in the cells list.
-   */
-  private _onCellsChanged(
-    list: IObservableList<ICellModel>,
-    change: IObservableList.IChangedArgs<ICellModel>
-  ): void {
-    switch (change.type) {
-      case 'add':
-        change.newValues.forEach(cell => {
-          cell.contentChanged.connect(this.triggerContentChange, this);
-        });
-        break;
-      case 'remove':
-        break;
-      case 'set':
-        change.newValues.forEach(cell => {
-          cell.contentChanged.connect(this.triggerContentChange, this);
-        });
-        break;
-      default:
-        break;
-    }
-    this.triggerContentChange();
+    /* No-op */
   }
 
   /**
    * Make sure we have the required metadata fields.
    */
   private _ensureMetadata(): void {
-    let metadata = this.metadata;
-    if (!metadata.has('language_info')) {
-      metadata.set('language_info', { name: '' });
+    const { datastore, record } = this.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      let metadata = { ...this.metadata };
+      metadata['language_info'] = metadata['language_info'] || { name: '' };
+      metadata['kernelspec'] = metadata['kernelspec'] || {
+        name: '',
+        display_name: ''
+      };
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'metadata' },
+        metadata
+      );
+    });
+  }
+
+  private _onGenericChange(
+    sender: Datastore,
+    args: Datastore.IChangedArgs
+  ): void {
+    const change = args.change;
+    // Grab the changes for the schemas we are interested in.
+    const recordChange = change[this.data.record.schema.id];
+    const cellChange = change[this.data.cells.schema.id];
+    const outputChange = change[this.data.outputs.schema.id];
+    // If there was a change to any of the top-level items, emit a
+    // contentChanged signal.
+    if (recordChange) {
+      this._contentChanged.emit();
+      return;
     }
-    if (!metadata.has('kernelspec')) {
-      metadata.set('kernelspec', { name: '', display_name: '' });
+    // If there were any changes to the outputs, emit a contentChanged signal.
+    // TODO: maybe filter for outputs that are definitely in a current cell.
+    if (outputChange) {
+      this._contentChanged.emit();
+      return;
+    }
+
+    // Check the cells for changes, ignoring cursors and mimetype.
+    const { datastore, record } = this.data;
+    const cells = DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'cells'
+    });
+    // Check the cell changes to see if some should be considered content.
+    if (
+      Object.keys(cellChange).some(cell => {
+        return (
+          // Only count cells that are currently in the notebook.
+          cells.indexOf(cell) !== -1 &&
+          Object.keys(cellChange[cell]).some(field => {
+            // Only count fields that are content fields.
+            return Private.CELL_CONTENT_FIELDS.indexOf(field) !== -1;
+          })
+        );
+      })
+    ) {
+      this._contentChanged.emit();
+      return;
     }
   }
 
-  private _cells: CellList;
-  private _nbformat = nbformat.MAJOR_VERSION;
-  private _nbformatMinor = nbformat.MINOR_VERSION;
   private _deletedCells: string[];
+  private _store: Datastore | null = null;
+  private _isDisposed = false;
+  private _contentChanged = new Signal<this, void>(this);
 }
 
 /**
@@ -354,25 +469,15 @@ export namespace NotebookModel {
     contentFactory?: IContentFactory;
 
     /**
-     * A modelDB for storing notebook data.
+     * The location for data stored in the notebook model.
      */
-    modelDB?: IModelDB;
+    data?: INotebookData.DataLocation;
   }
 
   /**
    * A factory for creating notebook model content.
    */
   export interface IContentFactory {
-    /**
-     * The factory for output area models.
-     */
-    readonly codeCellContentFactory: CodeCellModel.IContentFactory;
-
-    /**
-     * The IModelDB in which to put data for the notebook model.
-     */
-    modelDB: IModelDB;
-
     /**
      * Create a new cell by cell type.
      *
@@ -384,7 +489,7 @@ export namespace NotebookModel {
      * This method is intended to be a convenience method to programmaticaly
      * call the other cell creation methods in the factory.
      */
-    createCell(type: nbformat.CellType, opts: CellModel.IOptions): ICellModel;
+    createCell(type: nbformat.CellType, cell?: nbformat.IBaseCell): string;
 
     /**
      * Create a new code cell.
@@ -394,7 +499,7 @@ export namespace NotebookModel {
      * @returns A new code cell. If a source cell is provided, the
      *   new cell will be initialized with the data from the source.
      */
-    createCodeCell(options: CodeCellModel.IOptions): ICodeCellModel;
+    createCodeCell(cell?: nbformat.ICodeCell): string;
 
     /**
      * Create a new markdown cell.
@@ -404,7 +509,7 @@ export namespace NotebookModel {
      * @returns A new markdown cell. If a source cell is provided, the
      *   new cell will be initialized with the data from the source.
      */
-    createMarkdownCell(options: CellModel.IOptions): IMarkdownCellModel;
+    createMarkdownCell(cell?: nbformat.IMarkdownCell): string;
 
     /**
      * Create a new raw cell.
@@ -414,12 +519,12 @@ export namespace NotebookModel {
      * @returns A new raw cell. If a source cell is provided, the
      *   new cell will be initialized with the data from the source.
      */
-    createRawCell(options: CellModel.IOptions): IRawCellModel;
+    createRawCell(cell?: nbformat.IRawCell): string;
 
     /**
-     * Clone the content factory with a new IModelDB.
+     * Clone the content factory with a data location.
      */
-    clone(modelDB: IModelDB): IContentFactory;
+    clone(data: ContentFactory.DataLocation): IContentFactory;
   }
 
   /**
@@ -430,21 +535,9 @@ export namespace NotebookModel {
      * Create a new cell model factory.
      */
     constructor(options: ContentFactory.IOptions) {
-      this.codeCellContentFactory =
-        options.codeCellContentFactory || CodeCellModel.defaultContentFactory;
-      this.modelDB = options.modelDB;
+      this._data = options.data;
     }
 
-    /**
-     * The factory for code cell content.
-     */
-    readonly codeCellContentFactory: CodeCellModel.IContentFactory;
-
-    /**
-     * The IModelDB in which to put the notebook data.
-     */
-    readonly modelDB: IModelDB | undefined;
-
     /**
      * Create a new cell by cell type.
      *
@@ -456,17 +549,17 @@ export namespace NotebookModel {
      * This method is intended to be a convenience method to programmaticaly
      * call the other cell creation methods in the factory.
      */
-    createCell(type: nbformat.CellType, opts: CellModel.IOptions): ICellModel {
+    createCell(type: nbformat.CellType, cell?: nbformat.IBaseCell): string {
       switch (type) {
         case 'code':
-          return this.createCodeCell(opts);
+          return this.createCodeCell(cell as nbformat.ICodeCell);
           break;
         case 'markdown':
-          return this.createMarkdownCell(opts);
+          return this.createMarkdownCell(cell as nbformat.IMarkdownCell);
           break;
         case 'raw':
         default:
-          return this.createRawCell(opts);
+          return this.createRawCell(cell as nbformat.IRawCell);
       }
     }
 
@@ -475,22 +568,18 @@ export namespace NotebookModel {
      *
      * @param source - The data to use for the original source data.
      *
-     * @returns A new code cell. If a source cell is provided, the
-     *   new cell will be initialized with the data from the source.
-     *   If the contentFactory is not provided, the instance
-     *   `codeCellContentFactory` will be used.
+     * @returns A cell id.
      */
-    createCodeCell(options: CodeCellModel.IOptions): ICodeCellModel {
-      if (options.contentFactory) {
-        options.contentFactory = this.codeCellContentFactory;
-      }
-      if (this.modelDB) {
-        if (!options.id) {
-          options.id = UUID.uuid4();
-        }
-        options.modelDB = this.modelDB.view(options.id);
-      }
-      return new CodeCellModel(options);
+    createCodeCell(value?: nbformat.ICodeCell): string {
+      const id = UUID.uuid4();
+      const { datastore, cells, outputs } = this._data;
+      const loc = {
+        datastore,
+        record: { ...cells, record: id },
+        outputs
+      };
+      CodeCellData.fromJSON(loc, value);
+      return id;
     }
 
     /**
@@ -501,14 +590,16 @@ export namespace NotebookModel {
      * @returns A new markdown cell. If a source cell is provided, the
      *   new cell will be initialized with the data from the source.
      */
-    createMarkdownCell(options: CellModel.IOptions): IMarkdownCellModel {
-      if (this.modelDB) {
-        if (!options.id) {
-          options.id = UUID.uuid4();
-        }
-        options.modelDB = this.modelDB.view(options.id);
-      }
-      return new MarkdownCellModel(options);
+    createMarkdownCell(value?: nbformat.IMarkdownCell): string {
+      const id = UUID.uuid4();
+      const { datastore, cells, outputs } = this._data;
+      const loc = {
+        datastore,
+        record: { ...cells, record: id },
+        outputs
+      };
+      MarkdownCellData.fromJSON(loc, value);
+      return id;
     }
 
     /**
@@ -519,25 +610,28 @@ export namespace NotebookModel {
      * @returns A new raw cell. If a source cell is provided, the
      *   new cell will be initialized with the data from the source.
      */
-    createRawCell(options: CellModel.IOptions): IRawCellModel {
-      if (this.modelDB) {
-        if (!options.id) {
-          options.id = UUID.uuid4();
-        }
-        options.modelDB = this.modelDB.view(options.id);
-      }
-      return new RawCellModel(options);
+    createRawCell(value?: nbformat.IRawCell): string {
+      const id = UUID.uuid4();
+      const { datastore, cells, outputs } = this._data;
+      const loc = {
+        datastore,
+        record: { ...cells, record: id },
+        outputs
+      };
+      RawCellData.fromJSON(loc, value);
+      return id;
     }
 
     /**
-     * Clone the content factory with a new IModelDB.
+     * Clone the content factory with a new data location.
      */
-    clone(modelDB: IModelDB): ContentFactory {
+    clone(data: ContentFactory.DataLocation): ContentFactory {
       return new ContentFactory({
-        modelDB: modelDB,
-        codeCellContentFactory: this.codeCellContentFactory
+        data
       });
     }
+
+    private _data: ContentFactory.DataLocation;
   }
 
   /**
@@ -549,15 +643,25 @@ export namespace NotebookModel {
      */
     export interface IOptions {
       /**
-       * The factory for code cell model content.
+       * The data in which to place new content.
        */
-      codeCellContentFactory?: CodeCellModel.IContentFactory;
+      data?: DataLocation;
+    }
 
+    /**
+     * Data location for a cell content factory.
+     */
+    export type DataLocation = DatastoreExt.DataLocation & {
       /**
-       * The modelDB in which to place new content.
+       * A cell table.
        */
-      modelDB?: IModelDB;
-    }
+      cells: DatastoreExt.TableLocation<ICellData.Schema>;
+
+      /**
+       * An outputs table.
+       */
+      outputs: DatastoreExt.TableLocation<IOutputData.Schema>;
+    };
   }
 
   /**
@@ -565,3 +669,16 @@ export namespace NotebookModel {
    */
   export const defaultContentFactory = new ContentFactory({});
 }
+
+/**
+ * A namespace for module private functionality.
+ */
+namespace Private {
+  /**
+   * Cell fields for which changes should be considered changes
+   * to the notebook content.
+   */
+  export const CELL_CONTENT_FIELDS = Object.keys(CellData.SCHEMA.fields).filter(
+    key => key !== 'mimeType' && key !== 'selections'
+  );
+}
diff --git a/packages/notebook/src/modelfactory.ts b/packages/notebook/src/modelfactory.ts
index 8f4c395d05f..cffa8d2d7f1 100644
--- a/packages/notebook/src/modelfactory.ts
+++ b/packages/notebook/src/modelfactory.ts
@@ -1,14 +1,18 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { CodeCellModel } from '@jupyterlab/cells';
+import { CellData } from '@jupyterlab/cells';
+
+import { createDatastore } from '@jupyterlab/datastore';
 
 import { DocumentRegistry } from '@jupyterlab/docregistry';
 
-import { IModelDB } from '@jupyterlab/observables';
+import { OutputData } from '@jupyterlab/rendermime';
 
 import { Contents } from '@jupyterlab/services';
 
+import { NotebookData } from './data';
+
 import { INotebookModel, NotebookModel } from './model';
 
 /**
@@ -20,10 +24,8 @@ export class NotebookModelFactory
    * Construct a new notebook model factory.
    */
   constructor(options: NotebookModelFactory.IOptions) {
-    let codeCellContentFactory = options.codeCellContentFactory;
     this.contentFactory =
-      options.contentFactory ||
-      new NotebookModel.ContentFactory({ codeCellContentFactory });
+      options.contentFactory || new NotebookModel.ContentFactory({});
   }
 
   /**
@@ -73,9 +75,26 @@ export class NotebookModelFactory
    *
    * @returns A new document model.
    */
-  createNew(languagePreference?: string, modelDB?: IModelDB): INotebookModel {
-    let contentFactory = this.contentFactory;
-    return new NotebookModel({ languagePreference, contentFactory, modelDB });
+  async createNew(
+    options: DocumentRegistry.IModelFactory.IOptions = {}
+  ): Promise<INotebookModel> {
+    const contentFactory = this.contentFactory;
+    const { languagePreference, path } = options;
+    if (path) {
+      const datastore = await createDatastore(path, [
+        NotebookData.SCHEMA,
+        OutputData.SCHEMA,
+        CellData.SCHEMA
+      ]);
+      const data = {
+        datastore,
+        record: { schema: NotebookData.SCHEMA, record: 'data' },
+        cells: { schema: CellData.SCHEMA },
+        outputs: { schema: OutputData.SCHEMA }
+      };
+      return new NotebookModel({ data, languagePreference, contentFactory });
+    }
+    return new NotebookModel({ languagePreference, contentFactory });
   }
 
   /**
@@ -96,11 +115,6 @@ export namespace NotebookModelFactory {
    * The options used to initialize a NotebookModelFactory.
    */
   export interface IOptions {
-    /**
-     * The factory for code cell content.
-     */
-    codeCellContentFactory?: CodeCellModel.IContentFactory;
-
     /**
      * The content factory used by the NotebookModelFactory.  If
      * given, it will supersede the `codeCellContentFactory`.
diff --git a/packages/notebook/src/notebooktools.ts b/packages/notebook/src/notebooktools.ts
index 421166e002b..36262a3f8d1 100644
--- a/packages/notebook/src/notebooktools.ts
+++ b/packages/notebook/src/notebooktools.ts
@@ -1,19 +1,9 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { ArrayExt, each, chain } from '@phosphor/algorithm';
-
-import { JSONObject, JSONValue } from '@phosphor/coreutils';
-
-import { ConflatableMessage, Message, MessageLoop } from '@phosphor/messaging';
-
-import { h, VirtualDOM, VirtualNode } from '@phosphor/virtualdom';
-
-import { PanelLayout, Widget } from '@phosphor/widgets';
-
 import { Collapse, Styling } from '@jupyterlab/apputils';
 
-import { Cell, ICellModel } from '@jupyterlab/cells';
+import { Cell, ICellData } from '@jupyterlab/cells';
 
 import {
   CodeEditor,
@@ -23,10 +13,26 @@ import {
 
 import { nbformat } from '@jupyterlab/coreutils';
 
-import { IObservableMap, ObservableJSON } from '@jupyterlab/observables';
+import { DatastoreExt } from '@jupyterlab/datastore';
+
+import { ArrayExt, each, chain } from '@phosphor/algorithm';
+
+import { JSONObject, JSONValue, ReadonlyJSONValue } from '@phosphor/coreutils';
+
+import { Datastore, MapField } from '@phosphor/datastore';
+
+import { IDisposable } from '@phosphor/disposable';
+
+import { ConflatableMessage, Message, MessageLoop } from '@phosphor/messaging';
+
+import { h, VirtualDOM, VirtualNode } from '@phosphor/virtualdom';
+
+import { PanelLayout, Widget } from '@phosphor/widgets';
+
+import { INotebookData } from './data';
 
 import { NotebookPanel } from './panel';
-import { INotebookModel } from './model';
+
 import { INotebookTools, INotebookTracker } from './tokens';
 
 class RankedPanel<T extends Widget = Widget> extends Widget {
@@ -148,22 +154,19 @@ export class NotebookTools extends Widget implements INotebookTools {
    * Handle a change to the notebook panel.
    */
   private _onActiveNotebookPanelChanged(): void {
-    if (
-      this._prevActiveNotebookModel &&
-      !this._prevActiveNotebookModel.isDisposed
-    ) {
-      this._prevActiveNotebookModel.metadata.changed.disconnect(
-        this._onActiveNotebookPanelMetadataChanged,
-        this
-      );
+    if (this._nbMetadataListener) {
+      this._nbMetadataListener.dispose();
+      this._nbMetadataListener = null;
     }
     const activeNBModel =
       this.activeNotebookPanel && this.activeNotebookPanel.content
         ? this.activeNotebookPanel.content.model
         : null;
-    this._prevActiveNotebookModel = activeNBModel;
     if (activeNBModel) {
-      activeNBModel.metadata.changed.connect(
+      const { datastore, record } = activeNBModel.data;
+      this._nbMetadataListener = DatastoreExt.listenField(
+        datastore,
+        { ...record, field: 'metadata' },
         this._onActiveNotebookPanelMetadataChanged,
         this
       );
@@ -177,16 +180,17 @@ export class NotebookTools extends Widget implements INotebookTools {
    * Handle a change to the active cell.
    */
   private _onActiveCellChanged(): void {
-    if (this._prevActiveCell && !this._prevActiveCell.isDisposed) {
-      this._prevActiveCell.metadata.changed.disconnect(
-        this._onActiveCellMetadataChanged,
-        this
-      );
+    if (this._cellListener) {
+      this._cellListener.dispose();
+      this._cellListener = null;
     }
-    const activeCell = this.activeCell ? this.activeCell.model : null;
+    const activeCell = this.activeCell ? this.activeCell.data : null;
     this._prevActiveCell = activeCell;
     if (activeCell) {
-      activeCell.metadata.changed.connect(
+      const { datastore, record } = this._prevActiveCell;
+      DatastoreExt.listenField(
+        datastore,
+        { ...record, field: 'metadata' },
         this._onActiveCellMetadataChanged,
         this
       );
@@ -209,10 +213,10 @@ export class NotebookTools extends Widget implements INotebookTools {
    * Handle a change in the active cell metadata.
    */
   private _onActiveNotebookPanelMetadataChanged(
-    sender: IObservableMap<JSONValue>,
-    args: IObservableMap.IChangedArgs<JSONValue>
+    sender: Datastore,
+    args: MapField.Change<JSONValue>
   ): void {
-    let message = new ObservableJSON.ChangeMessage(
+    let message = new NotebookTools.MetadataChangeMessage(
       'activenotebookpanel-metadata-changed',
       args
     );
@@ -225,10 +229,10 @@ export class NotebookTools extends Widget implements INotebookTools {
    * Handle a change in the notebook model metadata.
    */
   private _onActiveCellMetadataChanged(
-    sender: IObservableMap<JSONValue>,
-    args: IObservableMap.IChangedArgs<JSONValue>
+    sender: Datastore,
+    args: MapField.Change<JSONValue>
   ): void {
-    let message = new ObservableJSON.ChangeMessage(
+    let message = new NotebookTools.MetadataChangeMessage(
       'activecell-metadata-changed',
       args
     );
@@ -241,11 +245,12 @@ export class NotebookTools extends Widget implements INotebookTools {
     return chain(this._commonTools.children(), this._advancedTools.children());
   }
 
+  private _cellListener: IDisposable;
   private _commonTools: RankedPanel<NotebookTools.Tool>;
   private _advancedTools: RankedPanel<NotebookTools.Tool>;
   private _tracker: INotebookTracker;
-  private _prevActiveCell: ICellModel | null;
-  private _prevActiveNotebookModel: INotebookModel | null;
+  private _prevActiveCell: ICellData.DataLocation | null;
+  private _nbMetadataListener: IDisposable | null = null;
 }
 
 /**
@@ -262,6 +267,24 @@ export namespace NotebookTools {
     tracker: INotebookTracker;
   }
 
+  /**
+   * An JSON field change message.
+   */
+  export class MetadataChangeMessage extends Message {
+    /**
+     * Create a new metadata changed message.
+     */
+    constructor(type: string, args: MapField.Change<JSONValue>) {
+      super(type);
+      this.args = args;
+    }
+
+    /**
+     * The arguments of the change.
+     */
+    readonly args: MapField.Change<JSONValue>;
+  }
+
   /**
    * The options used to add an item to the notebook tools.
    */
@@ -331,11 +354,13 @@ export namespace NotebookTools {
           this.onSelectionChanged(msg);
           break;
         case 'activecell-metadata-changed':
-          this.onActiveCellMetadataChanged(msg as ObservableJSON.ChangeMessage);
+          this.onActiveCellMetadataChanged(
+            msg as NotebookTools.MetadataChangeMessage
+          );
           break;
         case 'activenotebookpanel-metadata-changed':
           this.onActiveNotebookPanelMetadataChanged(
-            msg as ObservableJSON.ChangeMessage
+            msg as NotebookTools.MetadataChangeMessage
           );
           break;
         default:
@@ -380,7 +405,7 @@ export namespace NotebookTools {
      * The default implementation is a no-op.
      */
     protected onActiveCellMetadataChanged(
-      msg: ObservableJSON.ChangeMessage
+      msg: NotebookTools.MetadataChangeMessage
     ): void {
       /* no-op */
     }
@@ -392,7 +417,7 @@ export namespace NotebookTools {
      * The default implementation is a no-op.
      */
     protected onActiveNotebookPanelMetadataChanged(
-      msg: ObservableJSON.ChangeMessage
+      msg: NotebookTools.MetadataChangeMessage
     ): void {
       /* no-op */
     }
@@ -434,12 +459,13 @@ export namespace NotebookTools {
       for (let i = 0; i < count; i++) {
         layout.widgets[0].dispose();
       }
-      if (this._cellModel && !this._cellModel.isDisposed) {
-        this._cellModel.value.changed.disconnect(this._onValueChanged, this);
-        this._cellModel.mimeTypeChanged.disconnect(
-          this._onMimeTypeChanged,
-          this
-        );
+      if (this._mimeTypeListener) {
+        this._mimeTypeListener.dispose();
+        this._mimeTypeListener = null;
+      }
+      if (this._valueListener) {
+        this._valueListener.dispose();
+        this._valueListener = null;
       }
       if (!activeCell) {
         let cell = new Widget();
@@ -455,11 +481,21 @@ export namespace NotebookTools {
       let prompt = new Widget({ node: promptNode });
       let factory = activeCell.contentFactory.editorFactory;
 
-      let cellModel = (this._cellModel = activeCell.model);
-      cellModel.value.changed.connect(this._onValueChanged, this);
-      cellModel.mimeTypeChanged.connect(this._onMimeTypeChanged, this);
-      this._model.value.text = cellModel.value.text.split('\n')[0];
-      this._model.mimeType = cellModel.mimeType;
+      let cellLoc = (this._cellModel = activeCell.editor.model);
+      this._valueListener = DatastoreExt.listenField(
+        cellLoc.data.datastore,
+        { ...cellLoc.data.record, field: 'text' },
+        this._onValueChanged,
+        this
+      );
+      this._mimeTypeListener = DatastoreExt.listenField(
+        cellLoc.data.datastore,
+        { ...cellLoc.data.record, field: 'mimeType' },
+        this._onMimeTypeChanged,
+        this
+      );
+      this._model.value = activeCell.editor.model.value.split('\n')[0];
+      this._model.mimeType = activeCell.editor.model.mimeType;
 
       let model = this._model;
       let editorWidget = new CodeEditorWrapper({ model, factory });
@@ -474,7 +510,7 @@ export namespace NotebookTools {
      * Handle a change to the current editor value.
      */
     private _onValueChanged(): void {
-      this._model.value.text = this._cellModel.value.text.split('\n')[0];
+      this._model.value = this._cellModel.value.split('\n')[0];
     }
 
     /**
@@ -486,6 +522,8 @@ export namespace NotebookTools {
 
     private _model = new CodeEditor.Model();
     private _cellModel: CodeEditor.IModel;
+    private _mimeTypeListener: IDisposable | null = null;
+    private _valueListener: IDisposable | null = null;
   }
 
   /**
@@ -500,7 +538,10 @@ export namespace NotebookTools {
       const { editorFactory } = options;
       this.addClass('jp-MetadataEditorTool');
       let layout = (this.layout = new PanelLayout());
-      this.editor = new JSONEditor({
+      this.editor = new JSONEditor<
+        INotebookData.Schema | ICellData.Schema,
+        'metadata'
+      >({
         editorFactory
       });
       this.editor.title.label = options.label || 'Edit Metadata';
@@ -513,7 +554,10 @@ export namespace NotebookTools {
     /**
      * The editor used by the tool.
      */
-    readonly editor: JSONEditor;
+    readonly editor: JSONEditor<
+      ICellData.Schema | INotebookData.Schema,
+      'metadata'
+    >;
   }
 
   /**
@@ -568,7 +612,15 @@ export namespace NotebookTools {
       const nb =
         this.notebookTools.activeNotebookPanel &&
         this.notebookTools.activeNotebookPanel.content;
-      this.editor.source = nb ? nb.model.metadata : null;
+      if (!nb || !nb.model) {
+        return;
+      }
+      this.editor.source = nb
+        ? {
+            datastore: nb.model.data.datastore,
+            field: { ...nb.model.data.record, field: 'metadata' }
+          }
+        : null;
     }
   }
 
@@ -591,13 +643,20 @@ export namespace NotebookTools {
     /**
      * Handle a change to the active cell metadata.
      */
-    protected onActiveCellMetadataChanged(msg: Message): void {
+    protected onActiveCellMetadataChanged(
+      msg: NotebookTools.MetadataChangeMessage
+    ): void {
       this._update();
     }
 
     private _update() {
       let cell = this.notebookTools.activeCell;
-      this.editor.source = cell ? cell.model.metadata : null;
+      this.editor.source = cell
+        ? {
+            datastore: cell.data.datastore,
+            field: { ...cell.data.record, field: 'metadata' }
+          }
+        : null;
     }
   }
 
@@ -678,7 +737,7 @@ export namespace NotebookTools {
         select.value = '';
         return;
       }
-      let cellType = activeCell.model.type;
+      let cellType = activeCell.type;
       if (
         this._validCellTypes.length &&
         this._validCellTypes.indexOf(cellType) === -1
@@ -697,13 +756,15 @@ export namespace NotebookTools {
     /**
      * Handle a change to the metadata of the active cell.
      */
-    protected onActiveCellMetadataChanged(msg: ObservableJSON.ChangeMessage) {
+    protected onActiveCellMetadataChanged(
+      msg: NotebookTools.MetadataChangeMessage
+    ) {
       if (this._changeGuard) {
         return;
       }
       let select = this.selectNode;
       let cell = this.notebookTools.activeCell;
-      if (msg.args.key === this.key && cell) {
+      if (cell && msg.args.current[this.key]) {
         this._changeGuard = true;
         let getter = this._getter;
         select.value = JSON.stringify(getter(cell));
@@ -730,7 +791,12 @@ export namespace NotebookTools {
      * Get the value for the data.
      */
     private _getValue = (cell: Cell) => {
-      let value = cell.model.metadata.get(this.key);
+      const { datastore, record } = cell.data;
+      const metadata = DatastoreExt.getField(datastore, {
+        ...record,
+        field: 'metadata'
+      });
+      let value = metadata[this.key];
       if (value === undefined) {
         value = this._default;
       }
@@ -741,17 +807,28 @@ export namespace NotebookTools {
      * Set the value for the data.
      */
     private _setValue = (cell: Cell, value: JSONValue) => {
-      if (value === this._default) {
-        cell.model.metadata.delete(this.key);
-      } else {
-        cell.model.metadata.set(this.key, value);
-      }
+      const { datastore, record } = cell.data;
+      DatastoreExt.withTransaction(datastore, () => {
+        if (value === this._default) {
+          DatastoreExt.updateField(
+            datastore,
+            { ...record, field: 'metadata' },
+            { [this.key]: null }
+          );
+        } else {
+          DatastoreExt.updateField(
+            datastore,
+            { ...record, field: 'metadata' },
+            { [this.key]: value }
+          );
+        }
+      });
     };
 
     private _changeGuard = false;
     private _validCellTypes: string[];
-    private _getter: (cell: Cell) => JSONValue;
-    private _setter: (cell: Cell, value: JSONValue) => void;
+    private _getter: (cell: Cell) => ReadonlyJSONValue;
+    private _setter: (cell: Cell, value: ReadonlyJSONValue) => void;
     private _default: JSONValue;
   }
 
@@ -832,11 +909,21 @@ export namespace NotebookTools {
         Notes: 'notes'
       },
       getter: cell => {
-        let value = cell.model.metadata.get('slideshow');
+        let { datastore, record } = cell.data;
+        let metadata = DatastoreExt.getField(datastore, {
+          ...record,
+          field: 'metadata'
+        });
+        let value = metadata['slideshow'];
         return value && (value as JSONObject)['slide_type'];
       },
       setter: (cell, value) => {
-        let data = cell.model.metadata.get('slideshow') || Object.create(null);
+        let { datastore, record } = cell.data;
+        let metadata = DatastoreExt.getField(datastore, {
+          ...record,
+          field: 'metadata'
+        });
+        let data = metadata['slideshow'] || Object.create(null);
         if (value === null) {
           // Make a shallow copy so we aren't modifying the original metadata.
           data = { ...data };
@@ -844,11 +931,13 @@ export namespace NotebookTools {
         } else {
           data = { ...data, slide_type: value };
         }
-        if (Object.keys(data).length > 0) {
-          cell.model.metadata.set('slideshow', data);
-        } else {
-          cell.model.metadata.delete('slideshow');
-        }
+        DatastoreExt.withTransaction(datastore, () => {
+          DatastoreExt.updateField(
+            datastore,
+            { ...record, field: 'metadata' },
+            { slideshow: Object.keys(data).length > 0 ? data : null }
+          );
+        });
       }
     };
     return new KeySelector(options);
diff --git a/packages/notebook/src/panel.ts b/packages/notebook/src/panel.ts
index d9405ab73ff..7d48b8b7d22 100644
--- a/packages/notebook/src/panel.ts
+++ b/packages/notebook/src/panel.ts
@@ -16,6 +16,8 @@ import {
   Dialog
 } from '@jupyterlab/apputils';
 
+import { DatastoreExt } from '@jupyterlab/datastore';
+
 import { DocumentWidget } from '@jupyterlab/docregistry';
 
 import { INotebookModel } from './model';
@@ -52,7 +54,9 @@ export class NotebookPanel extends DocumentWidget<Notebook, INotebookModel> {
     this.content.addClass(NOTEBOOK_PANEL_NOTEBOOK_CLASS);
 
     // Set up things related to the context
-    this.content.model = this.context.model;
+    this.context.ready.then(() => {
+      this.content.model = this.context.model;
+    });
     this.context.session.kernelChanged.connect(this._onKernelChanged, this);
     this.context.session.statusChanged.connect(
       this._onSessionStatusChanged,
@@ -62,8 +66,8 @@ export class NotebookPanel extends DocumentWidget<Notebook, INotebookModel> {
     void this.revealed.then(() => {
       // Set the document edit mode on initial open if it looks like a new document.
       if (this.content.widgets.length === 1) {
-        let cellModel = this.content.widgets[0].model;
-        if (cellModel.type === 'code' && cellModel.value.text === '') {
+        let cell = this.content.widgets[0];
+        if (cell.type === 'code' && cell.editor.model.value === '') {
           this.content.mode = 'edit';
         }
       }
@@ -145,7 +149,7 @@ export class NotebookPanel extends DocumentWidget<Notebook, INotebookModel> {
   [Printing.symbol]() {
     return async () => {
       // Save before generating HTML
-      if (this.context.model.dirty && !this.context.model.readOnly) {
+      if (this.context.dirty && !this.context.readOnly) {
         await this.context.save();
       }
 
@@ -207,7 +211,14 @@ export class NotebookPanel extends DocumentWidget<Notebook, INotebookModel> {
    * Update the kernel language.
    */
   private _updateLanguage(language: KernelMessage.ILanguageInfo): void {
-    this.model.metadata.set('language_info', language);
+    const { datastore, record } = this.model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'metadata' },
+        { language_info: language }
+      );
+    });
   }
 
   /**
@@ -218,10 +229,19 @@ export class NotebookPanel extends DocumentWidget<Notebook, INotebookModel> {
       if (this.isDisposed) {
         return;
       }
-      this.model.metadata.set('kernelspec', {
-        name: kernel.name,
-        display_name: spec.display_name,
-        language: spec.language
+      const { datastore, record } = this.model.data;
+      DatastoreExt.withTransaction(datastore, () => {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'metadata' },
+          {
+            kernelspec: {
+              name: kernel.name,
+              display_name: spec.display_name,
+              language: spec.language
+            }
+          }
+        );
       });
     });
   }
diff --git a/packages/notebook/src/truststatus.tsx b/packages/notebook/src/truststatus.tsx
index 99d7b0d0e24..17fbdc3b476 100644
--- a/packages/notebook/src/truststatus.tsx
+++ b/packages/notebook/src/truststatus.tsx
@@ -2,7 +2,7 @@ import React from 'react';
 
 import { VDomRenderer, VDomModel } from '@jupyterlab/apputils';
 
-import { INotebookModel, Notebook } from '.';
+import { DatastoreExt } from '@jupyterlab/datastore';
 
 import { Cell } from '@jupyterlab/cells';
 
@@ -10,6 +10,8 @@ import { IconItem } from '@jupyterlab/statusbar';
 
 import { toArray } from '@phosphor/algorithm';
 
+import { Notebook } from '.';
+
 /**
  * Determine the notebook trust status message.
  */
@@ -174,15 +176,18 @@ export namespace NotebookTrustStatus {
         this._notebook.modelContentChanged.connect(this._onModelChanged, this);
 
         // Derive values
-        if (this._notebook.activeCell !== undefined) {
-          this._activeCellTrusted = this._notebook!.activeCell!.model.trusted;
+        if (this._notebook.activeCell) {
+          const { datastore, record } = this._notebook.activeCell.data;
+          let trusted = DatastoreExt.getField(datastore, {
+            ...record,
+            field: 'trusted'
+          });
+          this._activeCellTrusted = trusted;
         } else {
           this._activeCellTrusted = false;
         }
 
-        const { total, trusted } = this._deriveCellTrustState(
-          this._notebook.model
-        );
+        const { total, trusted } = this._deriveCellTrustState(this._notebook);
 
         this._totalCells = total;
         this._trustedCells = trusted;
@@ -196,7 +201,7 @@ export namespace NotebookTrustStatus {
      */
     private _onModelChanged(notebook: Notebook): void {
       const oldState = this._getAllState();
-      const { total, trusted } = this._deriveCellTrustState(notebook.model);
+      const { total, trusted } = this._deriveCellTrustState(notebook);
 
       this._totalCells = total;
       this._trustedCells = trusted;
@@ -209,7 +214,11 @@ export namespace NotebookTrustStatus {
     private _onActiveCellChanged(model: Notebook, cell: Cell | null): void {
       const oldState = this._getAllState();
       if (cell) {
-        this._activeCellTrusted = cell.model.trusted;
+        let trusted = DatastoreExt.getField(cell.data.datastore, {
+          ...cell.data.record,
+          field: 'trusted'
+        });
+        this._activeCellTrusted = trusted;
       } else {
         this._activeCellTrusted = false;
       }
@@ -220,12 +229,16 @@ export namespace NotebookTrustStatus {
      * Given a notebook model, figure out how many of the cells are trusted.
      */
     private _deriveCellTrustState(
-      model: INotebookModel
+      notebook: Notebook
     ): { total: number; trusted: number } {
-      let cells = toArray(model.cells);
+      let cells = toArray(notebook.widgets);
 
       let trusted = cells.reduce((accum, current) => {
-        if (current.trusted) {
+        let trusted = DatastoreExt.getField(current.data.datastore, {
+          ...current.data.record,
+          field: 'trusted'
+        });
+        if (trusted) {
           return accum + 1;
         } else {
           return accum;
diff --git a/packages/notebook/src/widget.ts b/packages/notebook/src/widget.ts
index 94bffc3b031..2b15af4adf4 100644
--- a/packages/notebook/src/widget.ts
+++ b/packages/notebook/src/widget.ts
@@ -3,38 +3,38 @@
 
 import { ArrayExt, each } from '@phosphor/algorithm';
 
-import { JSONValue } from '@phosphor/coreutils';
+import { JSONValue, MimeData } from '@phosphor/coreutils';
 
-import { Message } from '@phosphor/messaging';
+import { Datastore, ListField, MapField } from '@phosphor/datastore';
+
+import { IDisposable } from '@phosphor/disposable';
 
-import { MimeData } from '@phosphor/coreutils';
+import { IDragEvent, Drag } from '@phosphor/dragdrop';
+
+import { Message } from '@phosphor/messaging';
 
 import { AttachedProperty } from '@phosphor/properties';
 
 import { ISignal, Signal } from '@phosphor/signaling';
 
-import { Drag, IDragEvent } from '@phosphor/dragdrop';
-
 import { PanelLayout, Widget } from '@phosphor/widgets';
 
 import { h, VirtualDOM } from '@phosphor/virtualdom';
 
 import {
-  ICellModel,
   Cell,
-  IMarkdownCellModel,
+  CellData,
   CodeCell,
+  ICellData,
   MarkdownCell,
-  ICodeCellModel,
-  RawCell,
-  IRawCellModel
+  RawCell
 } from '@jupyterlab/cells';
 
 import { IEditorMimeTypeService, CodeEditor } from '@jupyterlab/codeeditor';
 
 import { IChangedArgs, nbformat } from '@jupyterlab/coreutils';
 
-import { IObservableMap, IObservableList } from '@jupyterlab/observables';
+import { DatastoreExt } from '@jupyterlab/datastore';
 
 import { IRenderMimeRegistry } from '@jupyterlab/rendermime';
 
@@ -215,23 +215,6 @@ export class StaticNotebook extends Widget {
     let oldValue = this._model;
     this._model = newValue;
 
-    if (oldValue && oldValue.modelDB.isCollaborative) {
-      void oldValue.modelDB.connected.then(() => {
-        oldValue.modelDB.collaborators.changed.disconnect(
-          this._onCollaboratorsChanged,
-          this
-        );
-      });
-    }
-    if (newValue && newValue.modelDB.isCollaborative) {
-      void newValue.modelDB.connected.then(() => {
-        newValue.modelDB.collaborators.changed.connect(
-          this._onCollaboratorsChanged,
-          this
-        );
-      });
-    }
-
     // Trigger private, protected, and public changes.
     this._onModelChanged(oldValue, newValue);
     this.onModelChanged(oldValue, newValue);
@@ -319,15 +302,11 @@ export class StaticNotebook extends Widget {
    * when the `language_info` metadata changes.
    */
   protected onMetadataChanged(
-    sender: IObservableMap<JSONValue>,
-    args: IObservableMap.IChangedArgs<JSONValue>
+    sender: Datastore,
+    args: MapField.Change<JSONValue>
   ): void {
-    switch (args.key) {
-      case 'language_info':
-        this._updateMimetype();
-        break;
-      default:
-        break;
+    if (args.current['language_info']) {
+      this._updateMimetype();
     }
   }
 
@@ -367,8 +346,14 @@ export class StaticNotebook extends Widget {
   ): void {
     let layout = this.layout as PanelLayout;
     if (oldValue) {
-      oldValue.cells.changed.disconnect(this._onCellsChanged, this);
-      oldValue.metadata.changed.disconnect(this.onMetadataChanged, this);
+      if (this._cellListener) {
+        this._cellListener.dispose();
+        this._cellListener = null;
+      }
+      if (this._metadataListener) {
+        this._metadataListener.dispose();
+        this._metadataListener = null;
+      }
       oldValue.contentChanged.disconnect(this.onModelContentChanged, this);
       // TODO: reuse existing cell widgets if possible. Remember to initially
       // clear the history of each cell if we do this.
@@ -381,94 +366,109 @@ export class StaticNotebook extends Widget {
       return;
     }
     this._updateMimetype();
-    let cells = newValue.cells;
-    if (!cells.length) {
-      cells.push(
-        newValue.contentFactory.createCell(this.notebookConfig.defaultCell, {})
-      );
-    }
-    each(cells, (cell: ICellModel, i: number) => {
-      this._insertCell(i, cell);
+    const { datastore, record, cells, outputs } = newValue.data;
+    let cellIds = DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'cells'
+    });
+    cellIds.forEach((id: string, i: number) => {
+      this._insertCell(i, {
+        datastore,
+        record: { ...cells, record: id },
+        outputs
+      });
     });
-    cells.changed.connect(this._onCellsChanged, this);
-    newValue.contentChanged.connect(this.onModelContentChanged, this);
-    newValue.metadata.changed.connect(this.onMetadataChanged, this);
+    this._cellListener = DatastoreExt.listenField(
+      datastore,
+      {
+        ...record,
+        field: 'cells'
+      },
+      this._onCellsChanged,
+      this
+    );
+    this._metadataListener = DatastoreExt.listenField(
+      datastore,
+      { ...record, field: 'metadata' },
+      this.onMetadataChanged,
+      this
+    );
+    if (!cellIds.length) {
+      DatastoreExt.withTransaction(datastore, () => {
+        const cellId = newValue.contentFactory.createCell(
+          this.notebookConfig.defaultCell
+        );
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'cells' },
+          { index: 0, remove: 0, values: [cellId] }
+        );
+      });
+    }
   }
 
   /**
    * Handle a change cells event.
    */
-  private _onCellsChanged(
-    sender: IObservableList<ICellModel>,
-    args: IObservableList.IChangedArgs<ICellModel>
-  ) {
-    let index = 0;
-    switch (args.type) {
-      case 'add':
-        index = args.newIndex;
-        each(args.newValues, value => {
-          this._insertCell(index++, value);
-        });
-        break;
-      case 'move':
-        this._moveCell(args.oldIndex, args.newIndex);
-        break;
-      case 'remove':
-        each(args.oldValues, value => {
-          this._removeCell(args.oldIndex);
-        });
-        // Add default cell if there are no cells remaining.
-        if (!sender.length) {
-          const model = this.model;
-          // Add the cell in a new context to avoid triggering another
-          // cell changed event during the handling of this signal.
-          requestAnimationFrame(() => {
-            if (!model.isDisposed && !model.cells.length) {
-              model.cells.push(
-                model.contentFactory.createCell(
-                  this.notebookConfig.defaultCell,
-                  {}
-                )
-              );
-            }
+  private _onCellsChanged(sender: Datastore, args: ListField.Change<string>) {
+    const { datastore, record, cells, outputs } = this.model.data;
+    args.forEach(change => {
+      for (let i = 0; i < change.removed.length; i++) {
+        this._removeCell(change.index);
+      }
+      for (let i = 0; i < change.inserted.length; i++) {
+        const loc = {
+          datastore,
+          record: {
+            ...cells,
+            record: change.inserted[i]
+          },
+          outputs
+        };
+        this._insertCell(change.index + i, loc);
+      }
+      const cellIds = DatastoreExt.getField(datastore, {
+        ...record,
+        field: 'cells'
+      });
+      if (!cellIds.length) {
+        requestAnimationFrame(() => {
+          // Add a new cell in a new frame so we don't trigger the
+          // same change listener in this one.
+          DatastoreExt.withTransaction(datastore, () => {
+            const cellId = this.model.contentFactory.createCell(
+              this.notebookConfig.defaultCell
+            );
+            DatastoreExt.updateField(
+              datastore,
+              { ...record, field: 'cells' },
+              { index: 0, remove: 0, values: [cellId] }
+            );
           });
-        }
-        break;
-      case 'set':
-        // TODO: reuse existing widgets if possible.
-        index = args.newIndex;
-        each(args.newValues, value => {
-          // Note: this ordering (insert then remove)
-          // is important for getting the active cell
-          // index for the editable notebook correct.
-          this._insertCell(index, value);
-          this._removeCell(index + 1);
-          index++;
         });
-        break;
-      default:
-        return;
-    }
+      }
+    });
   }
 
   /**
    * Create a cell widget and insert into the notebook.
    */
-  private _insertCell(index: number, cell: ICellModel): void {
+  private _insertCell(index: number, cell: ICellData.DataLocation): void {
     let widget: Cell;
-    switch (cell.type) {
+    const cellData = DatastoreExt.getRecord(cell.datastore, cell.record);
+    switch (cellData.type) {
       case 'code':
-        widget = this._createCodeCell(cell as ICodeCellModel);
-        widget.model.mimeType = this._mimetype;
+        widget = this._createCodeCell(cell);
+        widget.editor.model.mimeType = this._mimetype;
         break;
       case 'markdown':
-        widget = this._createMarkdownCell(cell as IMarkdownCellModel);
-        if (cell.value.text === '') {
+        widget = this._createMarkdownCell(cell);
+        if (widget.editor.model.value === '') {
           (widget as MarkdownCell).rendered = false;
         }
         break;
       default:
-        widget = this._createRawCell(cell as IRawCellModel);
+        widget = this._createRawCell(cell);
     }
     widget.addClass(NB_CELL_CLASS);
     let layout = this.layout as PanelLayout;
@@ -479,13 +479,13 @@ export class StaticNotebook extends Widget {
   /**
    * Create a code cell widget from a code cell model.
    */
-  private _createCodeCell(model: ICodeCellModel): CodeCell {
+  private _createCodeCell(data: ICellData.DataLocation): CodeCell {
     let rendermime = this.rendermime;
     let contentFactory = this.contentFactory;
     const editorConfig = this.editorConfig.code;
     let options = {
       editorConfig,
-      model,
+      data,
       rendermime,
       contentFactory,
       updateEditorOnShow: false
@@ -500,13 +500,13 @@ export class StaticNotebook extends Widget {
   /**
    * Create a markdown cell widget from a markdown cell model.
    */
-  private _createMarkdownCell(model: IMarkdownCellModel): MarkdownCell {
+  private _createMarkdownCell(data: ICellData.DataLocation): MarkdownCell {
     let rendermime = this.rendermime;
     let contentFactory = this.contentFactory;
     const editorConfig = this.editorConfig.markdown;
     let options = {
       editorConfig,
-      model,
+      data,
       rendermime,
       contentFactory,
       updateEditorOnShow: false
@@ -520,12 +520,12 @@ export class StaticNotebook extends Widget {
   /**
    * Create a raw cell widget from a raw cell model.
    */
-  private _createRawCell(model: IRawCellModel): RawCell {
+  private _createRawCell(data: ICellData.DataLocation): RawCell {
     let contentFactory = this.contentFactory;
     const editorConfig = this.editorConfig.raw;
     let options = {
       editorConfig,
-      model,
+      data,
       contentFactory,
       updateEditorOnShow: false
     };
@@ -535,15 +535,6 @@ export class StaticNotebook extends Widget {
     return cell;
   }
 
-  /**
-   * Move a cell widget.
-   */
-  private _moveCell(fromIndex: number, toIndex: number): void {
-    let layout = this.layout as PanelLayout;
-    layout.insertWidget(toIndex, layout.widgets[fromIndex]);
-    this.onCellMoved(fromIndex, toIndex);
-  }
-
   /**
    * Remove a cell widget.
    */
@@ -559,36 +550,25 @@ export class StaticNotebook extends Widget {
    * Update the mimetype of the notebook.
    */
   private _updateMimetype(): void {
-    let info = this._model.metadata.get(
+    let info = this._model.metadata[
       'language_info'
-    ) as nbformat.ILanguageInfoMetadata;
+    ] as nbformat.ILanguageInfoMetadata;
     if (!info) {
       return;
     }
     this._mimetype = this._mimetypeService.getMimeTypeByLanguage(info);
     each(this.widgets, widget => {
-      if (widget.model.type === 'code') {
-        widget.model.mimeType = this._mimetype;
+      const { datastore, record } = widget.data;
+      const cellType = DatastoreExt.getField(datastore, {
+        ...record,
+        field: 'type'
+      });
+      if (cellType === 'code') {
+        widget.editor.model.mimeType = this._mimetype;
       }
     });
   }
 
-  /**
-   * Handle an update to the collaborators.
-   */
-  private _onCollaboratorsChanged(): void {
-    // If there are selections corresponding to non-collaborators,
-    // they are stale and should be removed.
-    for (let i = 0; i < this.widgets.length; i++) {
-      let cell = this.widgets[i];
-      for (let key of cell.model.selections.keys()) {
-        if (!this._model.modelDB.collaborators.has(key)) {
-          cell.model.selections.delete(key);
-        }
-      }
-    }
-  }
-
   /**
    * Update editor settings for notebook cells.
    */
@@ -596,7 +576,7 @@ export class StaticNotebook extends Widget {
     for (let i = 0; i < this.widgets.length; i++) {
       const cell = this.widgets[i];
       let config: Partial<CodeEditor.IConfig>;
-      switch (cell.model.type) {
+      switch (cell.type) {
         case 'code':
           config = this._editorConfig.code;
           break;
@@ -627,6 +607,8 @@ export class StaticNotebook extends Widget {
 
   private _editorConfig = StaticNotebook.defaultEditorConfig;
   private _notebookConfig = StaticNotebook.defaultNotebookConfig;
+  private _metadataListener: IDisposable | null = null;
+  private _cellListener: IDisposable | null = null;
   private _mimetype = 'text/plain';
   private _model: INotebookModel = null;
   private _mimetypeService: IEditorMimeTypeService;
@@ -925,15 +907,15 @@ export class Notebook extends StaticNotebook {
     if (!this.model) {
       return -1;
     }
-    return this.model.cells.length ? this._activeCellIndex : -1;
+    return this.widgets.length ? this._activeCellIndex : -1;
   }
   set activeCellIndex(newValue: number) {
     let oldValue = this._activeCellIndex;
-    if (!this.model || !this.model.cells.length) {
+    if (!this.model || !this.widgets.length) {
       newValue = -1;
     } else {
       newValue = Math.max(newValue, 0);
-      newValue = Math.min(newValue, this.model.cells.length - 1);
+      newValue = Math.min(newValue, this.widgets.length - 1);
     }
 
     this._activeCellIndex = newValue;
@@ -973,6 +955,8 @@ export class Notebook extends StaticNotebook {
       return;
     }
     this._activeCell = null;
+    this._activeCellIndex = -1;
+    this._trimSelections();
     super.dispose();
   }
 
@@ -1432,20 +1416,7 @@ export class Notebook extends StaticNotebook {
    * Handle a cell being inserted.
    */
   protected onCellInserted(index: number, cell: Cell): void {
-    if (this.model && this.model.modelDB.isCollaborative) {
-      let modelDB = this.model.modelDB;
-      void modelDB.connected.then(() => {
-        if (!cell.isDisposed) {
-          // Setup the selection style for collaborators.
-          let localCollaborator = modelDB.collaborators.localCollaborator;
-          cell.editor.uuid = localCollaborator.sessionId;
-          cell.editor.selectionStyle = {
-            ...CodeEditor.defaultSelectionStyle,
-            color: localCollaborator.color
-          };
-        }
-      });
-    }
+    // TODO: let collaborators know who you are based on cursor!
     cell.editor.edgeRequested.connect(this._onEdgeRequest, this);
     // If the insertion happened above, increment the active cell
     // index, otherwise it stays the same.
@@ -1917,17 +1888,44 @@ export class Notebook extends StaticNotebook {
       }
 
       // Move the cells one by one
-      this.model.cells.beginCompoundOperation();
-      if (fromIndex < toIndex) {
-        each(toMove, cellWidget => {
-          this.model.cells.move(fromIndex, toIndex);
-        });
-      } else if (fromIndex > toIndex) {
-        each(toMove, cellWidget => {
-          this.model.cells.move(fromIndex++, toIndex++);
-        });
-      }
-      this.model.cells.endCompoundOperation();
+      const { datastore, record } = this.model.data;
+      DatastoreExt.withTransaction(datastore, () => {
+        if (fromIndex < toIndex) {
+          each(toMove, cellWidget => {
+            DatastoreExt.updateField(
+              datastore,
+              { ...record, field: 'cells' },
+              { index: fromIndex, remove: 1, values: [] }
+            );
+            DatastoreExt.updateField(
+              datastore,
+              { ...record, field: 'cells' },
+              {
+                index: toIndex,
+                remove: 0,
+                values: [cellWidget.data.record.record]
+              }
+            );
+          });
+        } else if (fromIndex > toIndex) {
+          each(toMove, cellWidget => {
+            DatastoreExt.updateField(
+              datastore,
+              { ...record, field: 'cells' },
+              { index: fromIndex++, remove: 1, values: [] }
+            );
+            DatastoreExt.updateField(
+              datastore,
+              { ...record, field: 'cells' },
+              {
+                index: toIndex++,
+                remove: 0,
+                values: [cellWidget.data.record.record]
+              }
+            );
+          });
+        }
+      });
     } else {
       // Handle the case where we are copying cells between
       // notebooks.
@@ -1943,23 +1941,30 @@ export class Notebook extends StaticNotebook {
       let factory = model.contentFactory;
 
       // Insert the copies of the original cells.
-      model.cells.beginCompoundOperation();
-      each(values, (cell: nbformat.ICell) => {
-        let value: ICellModel;
-        switch (cell.cell_type) {
-          case 'code':
-            value = factory.createCodeCell({ cell });
-            break;
-          case 'markdown':
-            value = factory.createMarkdownCell({ cell });
-            break;
-          default:
-            value = factory.createRawCell({ cell });
-            break;
-        }
-        model.cells.insert(index++, value);
+      const { datastore, record } = this.model.data;
+      DatastoreExt.withTransaction(datastore, () => {
+        each(values, (cell: nbformat.ICell) => {
+          let value: string;
+          switch (cell.cell_type) {
+            case 'code':
+              value = factory.createCodeCell(cell as nbformat.ICodeCell);
+              break;
+            case 'markdown':
+              value = factory.createMarkdownCell(
+                cell as nbformat.IMarkdownCell
+              );
+              break;
+            default:
+              value = factory.createRawCell(cell as nbformat.IRawCell);
+              break;
+          }
+          DatastoreExt.updateField(
+            datastore,
+            { ...record, field: 'cells' },
+            { index: index++, remove: 0, values: [value] }
+          );
+        });
       });
-      model.cells.endCompoundOperation();
       // Select the inserted cells.
       this.deselectAll();
       this.activeCellIndex = start;
@@ -1971,23 +1976,24 @@ export class Notebook extends StaticNotebook {
    * Start a drag event.
    */
   private _startDrag(index: number, clientX: number, clientY: number): void {
-    let cells = this.model.cells;
     let selected: nbformat.ICell[] = [];
     let toMove: Cell[] = [];
 
     each(this.widgets, (widget, i) => {
-      let cell = cells.get(i);
       if (this.isSelectedOrActive(widget)) {
         widget.addClass(DROP_SOURCE_CLASS);
-        selected.push(cell.toJSON());
+        selected.push(CellData.toJSON(widget.data));
         toMove.push(widget);
       }
     });
     let activeCell = this.activeCell;
     let dragImage: HTMLElement = null;
     let countString: string;
-    if (activeCell.model.type === 'code') {
-      let executionCount = (activeCell.model as ICodeCellModel).executionCount;
+    if (activeCell.type === 'code') {
+      let executionCount = DatastoreExt.getField(activeCell.data.datastore, {
+        ...activeCell.data.record,
+        field: 'executionCount'
+      });
       countString = ' ';
       if (executionCount) {
         countString = executionCount.toString();
@@ -2000,7 +2006,7 @@ export class Notebook extends StaticNotebook {
     dragImage = Private.createDragImage(
       selected.length,
       countString,
-      activeCell.model.value.text.split('\n')[0].slice(0, 26)
+      activeCell.editor.model.value.split('\n')[0].slice(0, 26)
     );
 
     // Set up the drag event.
@@ -2018,7 +2024,7 @@ export class Notebook extends StaticNotebook {
     this._drag.mimeData.setData('internal:cells', toMove);
     // Add mimeData for the text content of the selected cells,
     // allowing for drag/drop into plain text fields.
-    const textContent = toMove.map(cell => cell.model.value.text).join('\n');
+    const textContent = toMove.map(cell => cell.editor.model.value).join('\n');
     this._drag.mimeData.setData('text/plain', textContent);
 
     // Remove mousemove and mouseup listeners and start the drag.
@@ -2128,7 +2134,17 @@ export class Notebook extends StaticNotebook {
       return;
     }
     this.activeCellIndex = i;
-    if (model.cells.get(i).type === 'markdown') {
+    const { datastore, record, cells } = model.data;
+    const cellIds = DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'cells'
+    });
+    const cellType = DatastoreExt.getField(datastore, {
+      ...cells,
+      record: cellIds[i],
+      field: 'type'
+    });
+    if (cellType === 'markdown') {
       let widget = this.widgets[i] as MarkdownCell;
       widget.rendered = false;
     } else if (target.localName === 'img') {
@@ -2144,7 +2160,14 @@ export class Notebook extends StaticNotebook {
     for (let i = 0; i < this.widgets.length; i++) {
       if (i !== this._activeCellIndex) {
         let cell = this.widgets[i];
-        cell.model.selections.delete(cell.editor.uuid);
+        let { datastore, record } = cell.data;
+        DatastoreExt.withTransaction(datastore, () => {
+          DatastoreExt.updateField(
+            datastore,
+            { ...record, field: 'selections' },
+            { [cell.editor.uuid]: null }
+          );
+        });
       }
     }
   }
diff --git a/packages/notebook/style/index.css b/packages/notebook/style/index.css
index 9927f8adda6..2b3cd8bed50 100644
--- a/packages/notebook/style/index.css
+++ b/packages/notebook/style/index.css
@@ -11,6 +11,7 @@
 @import url('~@jupyterlab/codeeditor/style/index.css');
 @import url('~@jupyterlab/statusbar/style/index.css');
 @import url('~@jupyterlab/rendermime/style/index.css');
+@import url('~@jupyterlab/outputarea/style/index.css');
 @import url('~@jupyterlab/cells/style/index.css');
 @import url('~@jupyterlab/docregistry/style/index.css');
 
diff --git a/packages/notebook/tsconfig.json b/packages/notebook/tsconfig.json
index 76cf38a985b..4de341dccaa 100644
--- a/packages/notebook/tsconfig.json
+++ b/packages/notebook/tsconfig.json
@@ -18,11 +18,14 @@
     {
       "path": "../coreutils"
     },
+    {
+      "path": "../datastore"
+    },
     {
       "path": "../docregistry"
     },
     {
-      "path": "../observables"
+      "path": "../outputarea"
     },
     {
       "path": "../rendermime"
diff --git a/packages/outputarea/package.json b/packages/outputarea/package.json
index e0699df8f62..9584188ea10 100644
--- a/packages/outputarea/package.json
+++ b/packages/outputarea/package.json
@@ -37,13 +37,12 @@
   "dependencies": {
     "@jupyterlab/apputils": "^1.0.1",
     "@jupyterlab/coreutils": "^3.0.0",
-    "@jupyterlab/observables": "^2.2.0",
+    "@jupyterlab/datastore": "^1.0.0",
     "@jupyterlab/rendermime": "^1.0.1",
     "@jupyterlab/rendermime-interfaces": "^1.3.0",
     "@jupyterlab/services": "^4.0.1",
-    "@phosphor/algorithm": "^1.1.3",
     "@phosphor/coreutils": "^1.3.1",
-    "@phosphor/disposable": "^1.2.0",
+    "@phosphor/datastore": "0.7.2",
     "@phosphor/messaging": "^1.2.3",
     "@phosphor/signaling": "^1.2.3",
     "@phosphor/widgets": "^1.8.0"
diff --git a/packages/outputarea/src/data.ts b/packages/outputarea/src/data.ts
new file mode 100644
index 00000000000..cf973ca7b3e
--- /dev/null
+++ b/packages/outputarea/src/data.ts
@@ -0,0 +1,324 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import { nbformat } from '@jupyterlab/coreutils';
+
+import { DatastoreExt } from '@jupyterlab/datastore';
+
+import { IOutputData, OutputData, OutputModel } from '@jupyterlab/rendermime';
+
+import { UUID } from '@phosphor/coreutils';
+
+import {
+  Datastore,
+  Fields,
+  ListField,
+  RegisterField
+} from '@phosphor/datastore';
+
+/**
+ * The namespace for IOutputAreaData interfaces.
+ */
+export namespace IOutputAreaData {
+  /**
+   * An type alias for an output area data schema.
+   */
+  export type Schema = {
+    /**
+     * The id for the schema.
+     */
+    id: string;
+
+    /**
+     * The data fields in the schema.
+     */
+    fields: {
+      /**
+       * Whether the output area is trusted.
+       */
+      readonly trusted: RegisterField<boolean>;
+
+      /**
+       * The list of outputs in the output area.
+       */
+      readonly outputs: ListField<string>;
+    };
+  };
+
+  /**
+   * A set of locations in a datastore in which an output area
+   * stores its data.
+   */
+  export type DataLocation = DatastoreExt.DataLocation & {
+    /**
+     * A record in a datastore to hold the output area model.
+     */
+    record: DatastoreExt.RecordLocation<Schema>;
+
+    /**
+     * A table in a datastore for individual outputs.
+     */
+    outputs: DatastoreExt.TableLocation<IOutputData.Schema>;
+  };
+}
+
+/**
+ * Functions for performing operations on IOutputAreaData.
+ */
+export namespace OutputAreaData {
+  /**
+   * A concrete output area schema, available at runtime.
+   */
+  export const SCHEMA: IOutputAreaData.Schema = {
+    /**
+     * The schema id.
+     */
+    id: '@jupyterlab/outputarea:outputareamodel.v1',
+
+    /**
+     * The fields for the schema.
+     */
+    fields: {
+      trusted: Fields.Boolean(),
+      outputs: Fields.List<string>()
+    }
+  };
+
+  /**
+   * Create an in-memory datastore capable of holding the data for an output area.
+   */
+  export function createStore(id: number = 1): Datastore {
+    return Datastore.create({
+      id,
+      schemas: [SCHEMA, OutputData.SCHEMA]
+    });
+  }
+
+  /**
+   * Deserialize an output area model from JSON to a datastore location.
+   */
+  export function fromJSON(
+    loc: IOutputAreaData.DataLocation,
+    values: nbformat.IOutput[]
+  ): void {
+    DatastoreExt.withTransaction(loc.datastore, () => {
+      clear(loc);
+      values.forEach(value => appendItem(loc, value));
+    });
+  }
+
+  /**
+   * Set whether the model is trusted.
+   */
+  export function setTrusted(
+    loc: IOutputAreaData.DataLocation,
+    value: boolean
+  ) {
+    const { datastore, record, outputs } = loc;
+    if (
+      value ===
+      DatastoreExt.getField(datastore, { ...record, field: 'trusted' })
+    ) {
+      return;
+    }
+    DatastoreExt.withTransaction(datastore, () => {
+      const list = DatastoreExt.getField(datastore, {
+        ...record,
+        field: 'outputs'
+      });
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'trusted' },
+        true
+      );
+      for (let i = 0; i < list.length; i++) {
+        const id = list[i];
+        const outputRecord = { ...outputs, record: id };
+        DatastoreExt.updateField(
+          datastore,
+          { ...outputRecord, field: 'trusted' },
+          true
+        );
+      }
+    });
+  }
+
+  /**
+   * Set the value at the specified index.
+   */
+  export function setItem(
+    loc: IOutputAreaData.DataLocation,
+    index: number,
+    value: nbformat.IOutput
+  ): void {
+    const { datastore, record, outputs } = loc;
+    const list = DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'outputs'
+    });
+    const trusted = DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'trusted'
+    });
+    // Normalize stream data.
+    Private.normalize(value);
+    const outputData = {
+      datastore,
+      record: { ...outputs, record: list[index] }
+    };
+    OutputModel.fromJSON(outputData, value, trusted);
+  }
+
+  /**
+   * Clear all of the output.
+   */
+  export function clear(loc: IOutputAreaData.DataLocation): void {
+    const { datastore, record, outputs } = loc;
+    const list = DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'outputs'
+    });
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'outputs' },
+        { index: 0, remove: list.length, values: [] }
+      );
+      list.forEach(output => {
+        OutputModel.clear({
+          datastore,
+          record: { ...outputs, record: output }
+        });
+      });
+    });
+  }
+
+  /**
+   * Serialize the model to JSON.
+   */
+  export function toJSON(
+    loc: IOutputAreaData.DataLocation
+  ): nbformat.IOutput[] {
+    const { datastore, record, outputs } = loc;
+    const list = DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'outputs'
+    });
+    return list.map(id =>
+      OutputModel.toJSON({ datastore, record: { ...outputs, record: id } })
+    );
+  }
+
+  /**
+   * Add an array of output items to the list.
+   *
+   * #### Notes
+   * This removes overwritten characters, and consolidates items if they should
+   * be combined with a previous entry rather than a new entry.
+   */
+  export function appendItem(
+    loc: IOutputAreaData.DataLocation,
+    value: nbformat.IOutput
+  ): void {
+    const { datastore, record, outputs } = loc;
+    let trusted = DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'trusted'
+    });
+
+    DatastoreExt.withTransaction(datastore, () => {
+      // Normalize the value.
+      Private.normalize(value);
+
+      const list = DatastoreExt.getField(datastore, {
+        ...record,
+        field: 'outputs'
+      });
+
+      // Consolidate outputs if they are stream outputs of the same kind.
+      if (list.length) {
+        const index = list.length - 1;
+        const id = list[index];
+        const outputData = {
+          datastore,
+          record: { ...outputs, record: id }
+        };
+        const lastValue = OutputModel.toJSON(outputData);
+        if (nbformat.isStream(value) && lastValue.name === value.name) {
+          lastValue.text += value.text as string;
+          lastValue.text = Private.removeOverwrittenChars(
+            lastValue.text as string
+          );
+          value.text = lastValue.text;
+          OutputModel.fromJSON(outputData, value, trusted);
+          return;
+        }
+      }
+
+      if (nbformat.isStream(value)) {
+        value.text = Private.removeOverwrittenChars(value.text as string);
+      }
+
+      const id = UUID.uuid4();
+      const outputData = { datastore, record: { ...outputs, record: id } };
+      OutputModel.fromJSON(outputData, value, trusted);
+
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'outputs' },
+        { index: list.length, remove: 0, values: [id] }
+      );
+    });
+  }
+}
+
+/**
+ * A namespace for module-private functionality.
+ */
+namespace Private {
+  /**
+   * Normalize an output.
+   */
+  export function normalize(value: nbformat.IOutput): void {
+    if (nbformat.isStream(value)) {
+      if (Array.isArray(value.text)) {
+        value.text = (value.text as string[]).join('\n');
+      }
+    }
+  }
+
+  /**
+   * Remove characters that are overridden by backspace characters.
+   */
+  function fixBackspace(txt: string): string {
+    let tmp = txt;
+    do {
+      txt = tmp;
+      // Cancel out anything-but-newline followed by backspace
+      tmp = txt.replace(/[^\n]\x08/gm, '');
+    } while (tmp.length < txt.length);
+    return txt;
+  }
+
+  /**
+   * Remove chunks that should be overridden by the effect of
+   * carriage return characters.
+   */
+  function fixCarriageReturn(txt: string): string {
+    txt = txt.replace(/\r+\n/gm, '\n'); // \r followed by \n --> newline
+    while (txt.search(/\r[^$]/g) > -1) {
+      const base = txt.match(/^(.*)\r+/m)[1];
+      let insert = txt.match(/\r+(.*)$/m)[1];
+      insert = insert + base.slice(insert.length, base.length);
+      txt = txt.replace(/\r+.*$/m, '\r').replace(/^.*\r/m, insert);
+    }
+    return txt;
+  }
+
+  /*
+   * Remove characters overridden by backspaces and carriage returns
+   */
+  export function removeOverwrittenChars(text: string): string {
+    return fixCarriageReturn(fixBackspace(text));
+  }
+}
diff --git a/packages/outputarea/src/index.ts b/packages/outputarea/src/index.ts
index dba46488e23..02a73b2e475 100644
--- a/packages/outputarea/src/index.ts
+++ b/packages/outputarea/src/index.ts
@@ -1,5 +1,5 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-export * from './model';
+export * from './data';
 export * from './widget';
diff --git a/packages/outputarea/src/model.ts b/packages/outputarea/src/model.ts
deleted file mode 100644
index cd2d8c4fb85..00000000000
--- a/packages/outputarea/src/model.ts
+++ /dev/null
@@ -1,456 +0,0 @@
-// Copyright (c) Jupyter Development Team.
-// Distributed under the terms of the Modified BSD License.
-
-import { each, map, toArray } from '@phosphor/algorithm';
-
-import { IDisposable } from '@phosphor/disposable';
-
-import { ISignal, Signal } from '@phosphor/signaling';
-
-import { nbformat } from '@jupyterlab/coreutils';
-
-import { IObservableList, ObservableList } from '@jupyterlab/observables';
-
-import { IOutputModel, OutputModel } from '@jupyterlab/rendermime';
-
-/**
- * The model for an output area.
- */
-export interface IOutputAreaModel extends IDisposable {
-  /**
-   * A signal emitted when the model state changes.
-   */
-  readonly stateChanged: ISignal<IOutputAreaModel, void>;
-
-  /**
-   * A signal emitted when the model changes.
-   */
-  readonly changed: ISignal<IOutputAreaModel, IOutputAreaModel.ChangedArgs>;
-
-  /**
-   * The length of the items in the model.
-   */
-  readonly length: number;
-
-  /**
-   * Whether the output area is trusted.
-   */
-  trusted: boolean;
-
-  /**
-   * The output content factory used by the model.
-   */
-  readonly contentFactory: IOutputAreaModel.IContentFactory;
-
-  /**
-   * Get an item at the specified index.
-   */
-  get(index: number): IOutputModel;
-
-  /**
-   * Add an output, which may be combined with previous output.
-   *
-   * #### Notes
-   * The output bundle is copied.
-   * Contiguous stream outputs of the same `name` are combined.
-   */
-  add(output: nbformat.IOutput): number;
-
-  /**
-   * Set the value at the specified index.
-   */
-  set(index: number, output: nbformat.IOutput): void;
-
-  /**
-   * Clear all of the output.
-   *
-   * @param wait - Delay clearing the output until the next message is added.
-   */
-  clear(wait?: boolean): void;
-
-  /**
-   * Deserialize the model from JSON.
-   *
-   * #### Notes
-   * This will clear any existing data.
-   */
-  fromJSON(values: nbformat.IOutput[]): void;
-
-  /**
-   * Serialize the model to JSON.
-   */
-  toJSON(): nbformat.IOutput[];
-}
-
-/**
- * The namespace for IOutputAreaModel interfaces.
- */
-export namespace IOutputAreaModel {
-  /**
-   * The options used to create a output area model.
-   */
-  export interface IOptions {
-    /**
-     * The initial values for the model.
-     */
-    values?: nbformat.IOutput[];
-
-    /**
-     * Whether the output is trusted.  The default is false.
-     */
-    trusted?: boolean;
-
-    /**
-     * The output content factory used by the model.
-     *
-     * If not given, a default factory will be used.
-     */
-    contentFactory?: IContentFactory;
-  }
-
-  /**
-   * A type alias for changed args.
-   */
-  export type ChangedArgs = IObservableList.IChangedArgs<IOutputModel>;
-
-  /**
-   * The interface for an output content factory.
-   */
-  export interface IContentFactory {
-    /**
-     * Create an output model.
-     */
-    createOutputModel(options: IOutputModel.IOptions): IOutputModel;
-  }
-}
-
-/**
- * The default implementation of the IOutputAreaModel.
- */
-export class OutputAreaModel implements IOutputAreaModel {
-  /**
-   * Construct a new observable outputs instance.
-   */
-  constructor(options: IOutputAreaModel.IOptions = {}) {
-    this._trusted = !!options.trusted;
-    this.contentFactory =
-      options.contentFactory || OutputAreaModel.defaultContentFactory;
-    this.list = new ObservableList<IOutputModel>();
-    if (options.values) {
-      each(options.values, value => {
-        this._add(value);
-      });
-    }
-    this.list.changed.connect(this._onListChanged, this);
-  }
-
-  /**
-   * A signal emitted when the model state changes.
-   */
-  get stateChanged(): ISignal<IOutputAreaModel, void> {
-    return this._stateChanged;
-  }
-
-  /**
-   * A signal emitted when the model changes.
-   */
-  get changed(): ISignal<this, IOutputAreaModel.ChangedArgs> {
-    return this._changed;
-  }
-
-  /**
-   * Get the length of the items in the model.
-   */
-  get length(): number {
-    return this.list ? this.list.length : 0;
-  }
-
-  /**
-   * Get whether the model is trusted.
-   */
-  get trusted(): boolean {
-    return this._trusted;
-  }
-
-  /**
-   * Set whether the model is trusted.
-   *
-   * #### Notes
-   * Changing the value will cause all of the models to re-set.
-   */
-  set trusted(value: boolean) {
-    if (value === this._trusted) {
-      return;
-    }
-    let trusted = (this._trusted = value);
-    for (let i = 0; i < this.list.length; i++) {
-      let item = this.list.get(i);
-      let value = item.toJSON();
-      item.dispose();
-      item = this._createItem({ value, trusted });
-      this.list.set(i, item);
-    }
-  }
-
-  /**
-   * The output content factory used by the model.
-   */
-  readonly contentFactory: IOutputAreaModel.IContentFactory;
-
-  /**
-   * Test whether the model is disposed.
-   */
-  get isDisposed(): boolean {
-    return this._isDisposed;
-  }
-
-  /**
-   * Dispose of the resources used by the model.
-   */
-  dispose(): void {
-    if (this.isDisposed) {
-      return;
-    }
-    this._isDisposed = true;
-    this.list.dispose();
-    Signal.clearData(this);
-  }
-
-  /**
-   * Get an item at the specified index.
-   */
-  get(index: number): IOutputModel {
-    return this.list.get(index);
-  }
-
-  /**
-   * Set the value at the specified index.
-   */
-  set(index: number, value: nbformat.IOutput): void {
-    // Normalize stream data.
-    Private.normalize(value);
-    let item = this._createItem({ value, trusted: this._trusted });
-    this.list.set(index, item);
-  }
-
-  /**
-   * Add an output, which may be combined with previous output.
-   *
-   * #### Notes
-   * The output bundle is copied.
-   * Contiguous stream outputs of the same `name` are combined.
-   */
-  add(output: nbformat.IOutput): number {
-    // If we received a delayed clear message, then clear now.
-    if (this.clearNext) {
-      this.clear();
-      this.clearNext = false;
-    }
-
-    return this._add(output);
-  }
-
-  /**
-   * Clear all of the output.
-   *
-   * @param wait Delay clearing the output until the next message is added.
-   */
-  clear(wait: boolean = false): void {
-    this._lastStream = '';
-    if (wait) {
-      this.clearNext = true;
-      return;
-    }
-    each(this.list, (item: IOutputModel) => {
-      item.dispose();
-    });
-    this.list.clear();
-  }
-
-  /**
-   * Deserialize the model from JSON.
-   *
-   * #### Notes
-   * This will clear any existing data.
-   */
-  fromJSON(values: nbformat.IOutput[]) {
-    this.clear();
-    each(values, value => {
-      this._add(value);
-    });
-  }
-
-  /**
-   * Serialize the model to JSON.
-   */
-  toJSON(): nbformat.IOutput[] {
-    return toArray(map(this.list, (output: IOutputModel) => output.toJSON()));
-  }
-
-  /**
-   * Add an item to the list.
-   */
-  private _add(value: nbformat.IOutput): number {
-    let trusted = this._trusted;
-
-    // Normalize the value.
-    Private.normalize(value);
-
-    // Consolidate outputs if they are stream outputs of the same kind.
-    if (
-      nbformat.isStream(value) &&
-      this._lastStream &&
-      value.name === this._lastName
-    ) {
-      // In order to get a list change event, we add the previous
-      // text to the current item and replace the previous item.
-      // This also replaces the metadata of the last item.
-      this._lastStream += value.text as string;
-      this._lastStream = Private.removeOverwrittenChars(this._lastStream);
-      value.text = this._lastStream;
-      let item = this._createItem({ value, trusted });
-      let index = this.length - 1;
-      let prev = this.list.get(index);
-      prev.dispose();
-      this.list.set(index, item);
-      return index;
-    }
-
-    if (nbformat.isStream(value)) {
-      value.text = Private.removeOverwrittenChars(value.text as string);
-    }
-
-    // Create the new item.
-    let item = this._createItem({ value, trusted });
-
-    // Update the stream information.
-    if (nbformat.isStream(value)) {
-      this._lastStream = value.text as string;
-      this._lastName = value.name;
-    } else {
-      this._lastStream = '';
-    }
-
-    // Add the item to our list and return the new length.
-    return this.list.push(item);
-  }
-
-  /**
-   * A flag that is set when we want to clear the output area
-   * *after* the next addition to it.
-   */
-  protected clearNext = false;
-
-  /**
-   * An observable list containing the output models
-   * for this output area.
-   */
-  protected list: IObservableList<IOutputModel> = null;
-
-  /**
-   * Create an output item and hook up its signals.
-   */
-  private _createItem(options: IOutputModel.IOptions): IOutputModel {
-    let factory = this.contentFactory;
-    let item = factory.createOutputModel(options);
-    item.changed.connect(this._onGenericChange, this);
-    return item;
-  }
-
-  /**
-   * Handle a change to the list.
-   */
-  private _onListChanged(
-    sender: IObservableList<IOutputModel>,
-    args: IObservableList.IChangedArgs<IOutputModel>
-  ) {
-    this._changed.emit(args);
-  }
-
-  /**
-   * Handle a change to an item.
-   */
-  private _onGenericChange(): void {
-    this._stateChanged.emit(void 0);
-  }
-
-  private _lastStream: string;
-  private _lastName: 'stdout' | 'stderr';
-  private _trusted = false;
-  private _isDisposed = false;
-  private _stateChanged = new Signal<IOutputAreaModel, void>(this);
-  private _changed = new Signal<this, IOutputAreaModel.ChangedArgs>(this);
-}
-
-/**
- * The namespace for OutputAreaModel class statics.
- */
-export namespace OutputAreaModel {
-  /**
-   * The default implementation of a `IModelOutputFactory`.
-   */
-  export class ContentFactory implements IOutputAreaModel.IContentFactory {
-    /**
-     * Create an output model.
-     */
-    createOutputModel(options: IOutputModel.IOptions): IOutputModel {
-      return new OutputModel(options);
-    }
-  }
-
-  /**
-   * The default output model factory.
-   */
-  export const defaultContentFactory = new ContentFactory();
-}
-
-/**
- * A namespace for module-private functionality.
- */
-namespace Private {
-  /**
-   * Normalize an output.
-   */
-  export function normalize(value: nbformat.IOutput): void {
-    if (nbformat.isStream(value)) {
-      if (Array.isArray(value.text)) {
-        value.text = (value.text as string[]).join('\n');
-      }
-    }
-  }
-
-  /**
-   * Remove characters that are overridden by backspace characters.
-   */
-  function fixBackspace(txt: string): string {
-    let tmp = txt;
-    do {
-      txt = tmp;
-      // Cancel out anything-but-newline followed by backspace
-      tmp = txt.replace(/[^\n]\x08/gm, '');
-    } while (tmp.length < txt.length);
-    return txt;
-  }
-
-  /**
-   * Remove chunks that should be overridden by the effect of
-   * carriage return characters.
-   */
-  function fixCarriageReturn(txt: string): string {
-    txt = txt.replace(/\r+\n/gm, '\n'); // \r followed by \n --> newline
-    while (txt.search(/\r[^$]/g) > -1) {
-      const base = txt.match(/^(.*)\r+/m)[1];
-      let insert = txt.match(/\r+(.*)$/m)[1];
-      insert = insert + base.slice(insert.length, base.length);
-      txt = txt.replace(/\r+.*$/m, '\r').replace(/^.*\r/m, insert);
-    }
-    return txt;
-  }
-
-  /*
-   * Remove characters overridden by backspaces and carriage returns
-   */
-  export function removeOverwrittenChars(text: string): string {
-    return fixCarriageReturn(fixBackspace(text));
-  }
-}
diff --git a/packages/outputarea/src/widget.ts b/packages/outputarea/src/widget.ts
index 13e13411f82..c118a92c52c 100644
--- a/packages/outputarea/src/widget.ts
+++ b/packages/outputarea/src/widget.ts
@@ -1,31 +1,38 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
+import { IClientSession } from '@jupyterlab/apputils';
+
+import { nbformat } from '@jupyterlab/coreutils';
+
+import { DatastoreExt } from '@jupyterlab/datastore';
+
+import {
+  IOutputData,
+  IRenderMimeRegistry,
+  OutputData,
+  OutputModel
+} from '@jupyterlab/rendermime';
+
+import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
+
+import { Kernel, KernelMessage } from '@jupyterlab/services';
+
 import {
   JSONObject,
   PromiseDelegate,
   ReadonlyJSONObject
 } from '@phosphor/coreutils';
 
+import { Datastore, ListField } from '@phosphor/datastore';
+
 import { Message } from '@phosphor/messaging';
 
 import { Signal } from '@phosphor/signaling';
 
-import { Panel, PanelLayout } from '@phosphor/widgets';
-
-import { Widget } from '@phosphor/widgets';
-
-import { IClientSession } from '@jupyterlab/apputils';
-
-import { nbformat } from '@jupyterlab/coreutils';
+import { Panel, PanelLayout, Widget } from '@phosphor/widgets';
 
-import { IOutputModel, IRenderMimeRegistry } from '@jupyterlab/rendermime';
-
-import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
-
-import { Kernel, KernelMessage } from '@jupyterlab/services';
-
-import { IOutputAreaModel } from './model';
+import { IOutputAreaData, OutputAreaData } from './data';
 
 /**
  * The class name added to an output area widget.
@@ -83,12 +90,6 @@ const STDIN_INPUT_CLASS = 'jp-Stdin-input';
 
 /**
  * An output area widget.
- *
- * #### Notes
- * The widget model must be set separately and can be changed
- * at any time.  Consumers of the widget must account for a
- * `null` model, and may want to listen to the `modelChanged`
- * signal.
  */
 export class OutputArea extends Widget {
   /**
@@ -96,24 +97,42 @@ export class OutputArea extends Widget {
    */
   constructor(options: OutputArea.IOptions) {
     super();
-    let model = (this.model = options.model);
+    let data: IOutputAreaData.DataLocation;
+    if (options.data) {
+      data = this.data = options.data;
+    } else {
+      const datastore = (this._datastore = OutputAreaData.createStore());
+      data = this.data = {
+        datastore,
+        record: {
+          schema: OutputAreaData.SCHEMA,
+          record: 'data'
+        },
+        outputs: {
+          schema: OutputData.SCHEMA
+        }
+      };
+    }
     this.addClass(OUTPUT_AREA_CLASS);
     this.rendermime = options.rendermime;
     this.contentFactory =
       options.contentFactory || OutputArea.defaultContentFactory;
     this.layout = new PanelLayout();
-    for (let i = 0; i < model.length; i++) {
-      let output = model.get(i);
-      this._insertOutput(i, output);
+    const list = DatastoreExt.getField(data.datastore, {
+      ...data.record,
+      field: 'outputs'
+    });
+    for (let i = 0; i < list.length; i++) {
+      this._insertOutput(i, { ...data.outputs, record: list[i] });
     }
-    model.changed.connect(this.onModelChanged, this);
-    model.stateChanged.connect(this.onStateChanged, this);
+
+    data.datastore.changed.connect(this.onChange, this);
   }
 
   /**
-   * The model used by the widget.
+   * The data rendered by the widget.
    */
-  readonly model: IOutputAreaModel;
+  readonly data: IOutputAreaData.DataLocation;
 
   /**
    * The content factory used by the widget.
@@ -157,10 +176,6 @@ export class OutputArea extends Widget {
       KernelMessage.IExecuteReplyMsg
     > | null
   ) {
-    // Bail if the model is disposed.
-    if (this.model.isDisposed) {
-      throw Error('Model is disposed');
-    }
     if (this._future === value) {
       return;
     }
@@ -169,12 +184,12 @@ export class OutputArea extends Widget {
     }
     this._future = value;
 
-    this.model.clear();
+    OutputAreaData.clear(this.data);
 
     // Make sure there were no input widgets.
     if (this.widgets.length) {
       this._clear();
-      this.outputLengthChanged.emit(this.model.length);
+      this.outputLengthChanged.emit(0);
     }
 
     // Handle published messages.
@@ -195,50 +210,76 @@ export class OutputArea extends Widget {
    * Dispose of the resources used by the output area.
    */
   dispose(): void {
+    if (this.isDisposed) {
+      return;
+    }
+    if (this._datastore) {
+      this._datastore.dispose();
+      this._datastore = null;
+    }
+
     if (this._future) {
       this._future.dispose();
     }
     this._future = null;
     this._displayIdMap.clear();
+    Signal.clearData(this);
     super.dispose();
   }
-
   /**
-   * Follow changes on the model state.
-   */
-  protected onModelChanged(
-    sender: IOutputAreaModel,
-    args: IOutputAreaModel.ChangedArgs
-  ): void {
-    switch (args.type) {
-      case 'add':
-        this._insertOutput(args.newIndex, args.newValues[0]);
-        this.outputLengthChanged.emit(this.model.length);
-        break;
-      case 'remove':
-        // Only clear is supported by the model.
-        if (this.widgets.length) {
-          this._clear();
-          this.outputLengthChanged.emit(this.model.length);
+   * Follow changes to the datastore.
+   */
+  protected onChange(sender: Datastore, args: Datastore.IChangedArgs) {
+    // Keep track of the items that have been rendered.
+    const handled = new Set<string>();
+
+    // First, handle list removals and inserts.
+    const { schema, record } = this.data.record;
+    const listChange =
+      args.change[schema.id] &&
+      args.change[schema.id][record] &&
+      (args.change[schema.id][record]['outputs'] as ListField.Change<string>);
+    if (listChange) {
+      listChange.forEach(change => {
+        // Remove any disposed values
+        for (let i = 0; i < change.removed.length; i++) {
+          this.widgets[change.index].dispose();
         }
-        break;
-      case 'set':
-        this._setOutput(args.newIndex, args.newValues[0]);
-        this.outputLengthChanged.emit(this.model.length);
-        break;
-      default:
-        break;
+        // Insert new values
+        for (let i = 0; i < change.inserted.length; i++) {
+          const id = change.inserted[i];
+          const record = {
+            ...this.data.outputs,
+            record: id
+          };
+          this._insertOutput(change.index + i, record);
+          // Mark this item as having been rendered.
+          handled.add(id);
+        }
+      });
     }
-  }
-
-  /**
-   * Follow changes on the output model state.
-   */
-  protected onStateChanged(sender: IOutputAreaModel): void {
-    for (let i = 0; i < this.model.length; i++) {
-      this._setOutput(i, this.model.get(i));
+    // Check for changes to individual outputs.
+    const outputChanges = args.change[this.data.outputs.schema.id];
+    if (!outputChanges) {
+      return;
     }
-    this.outputLengthChanged.emit(this.model.length);
+    const outputs = DatastoreExt.getField(this.data.datastore, {
+      ...this.data.record,
+      field: 'outputs'
+    });
+    Object.keys(outputChanges).forEach(output => {
+      const index = outputs.indexOf(output);
+      // If this output belongs to us, and we have not rerendered it already,
+      // then rerender it in-place. This can happen when an output is updated
+      // or a stream is consolidated.
+      if (index !== -1 && !handled.has(output)) {
+        const record = {
+          ...this.data.outputs,
+          record: output
+        };
+        this._setOutput(index, record);
+      }
+    });
   }
 
   /**
@@ -312,7 +353,7 @@ export class OutputArea extends Widget {
      */
     void input.value.then(value => {
       // Use stdin as the stream so it does not get combined with stdout.
-      this.model.add({
+      this._appendItem({
         output_type: 'stream',
         name: 'stdin',
         text: value + '\n'
@@ -324,27 +365,44 @@ export class OutputArea extends Widget {
   /**
    * Update an output in the layout in place.
    */
-  private _setOutput(index: number, model: IOutputModel): void {
+  private _setOutput(
+    index: number,
+    loc: DatastoreExt.RecordLocation<IOutputData.Schema>
+  ): void {
     let layout = this.layout as PanelLayout;
     let panel = layout.widgets[index] as Panel;
     let renderer = (panel.widgets
       ? panel.widgets[1]
       : panel) as IRenderMime.IRenderer;
     if (renderer.renderModel) {
+      // Create a temporary output model view to pass of to the renderer.
+      let model = new OutputModel({
+        data: {
+          datastore: this.data.datastore,
+          record: loc
+        }
+      });
       void renderer.renderModel(model);
     } else {
       layout.widgets[index].dispose();
-      this._insertOutput(index, model);
+      this._insertOutput(index, loc);
     }
   }
 
   /**
    * Render and insert a single output into the layout.
    */
-  private _insertOutput(index: number, model: IOutputModel): void {
-    let output = this.createOutputItem(model);
+  private _insertOutput(
+    index: number,
+    loc: DatastoreExt.RecordLocation<IOutputData.Schema>
+  ): void {
+    let output = this.createOutputItem(loc);
+    let executionCount = DatastoreExt.getField(this.data.datastore, {
+      ...loc,
+      field: 'executionCount'
+    });
     if (output) {
-      output.toggleClass(EXECUTE_CLASS, model.executionCount !== null);
+      output.toggleClass(EXECUTE_CLASS, executionCount !== null);
     } else {
       output = new Widget();
     }
@@ -355,19 +413,26 @@ export class OutputArea extends Widget {
   /**
    * Create an output item with a prompt and actual output
    */
-  protected createOutputItem(model: IOutputModel): Widget | null {
-    let output = this.createRenderedMimetype(model);
+  protected createOutputItem(
+    loc: DatastoreExt.RecordLocation<IOutputData.Schema>
+  ): Widget | null {
+    let output = this.createRenderedMimetype(loc);
 
     if (!output) {
       return null;
     }
 
+    let executionCount = DatastoreExt.getField(this.data.datastore, {
+      ...loc,
+      field: 'executionCount'
+    });
+
     let panel = new Panel();
 
     panel.addClass(OUTPUT_AREA_ITEM_CLASS);
 
     let prompt = this.contentFactory.createOutputPrompt();
-    prompt.executionCount = model.executionCount;
+    prompt.executionCount = executionCount;
     prompt.addClass(OUTPUT_AREA_PROMPT_CLASS);
     panel.addWidget(prompt);
 
@@ -379,7 +444,16 @@ export class OutputArea extends Widget {
   /**
    * Render a mimetype
    */
-  protected createRenderedMimetype(model: IOutputModel): Widget | null {
+  protected createRenderedMimetype(
+    loc: DatastoreExt.RecordLocation<IOutputData.Schema>
+  ): Widget | null {
+    // Create a temporary output model view to pass of to the renderer.
+    let model = new OutputModel({
+      data: {
+        datastore: this.data.datastore,
+        record: loc
+      }
+    });
     let mimeType = this.rendermime.preferredMimeType(
       model.data,
       model.trusted ? 'any' : 'ensure'
@@ -423,7 +497,6 @@ export class OutputArea extends Widget {
    * Handle an iopub message.
    */
   private _onIOPub = (msg: KernelMessage.IIOPubMessage) => {
-    let model = this.model;
     let msgType = msg.header.msg_type;
     let output: nbformat.IOutput;
     let transient = ((msg.content as any).transient || {}) as JSONObject;
@@ -437,11 +510,17 @@ export class OutputArea extends Widget {
       case 'error':
         output = msg.content as nbformat.IOutput;
         output.output_type = msgType as nbformat.OutputType;
-        model.add(output);
+        this._appendItem(output);
         break;
       case 'clear_output':
+        // If a wait signal is recieved, mark the `_clearNext` flag so
+        // we can clear the output area after the next output.
         let wait = (msg as KernelMessage.IClearOutputMsg).content.wait;
-        model.clear(wait);
+        if (wait) {
+          this._clearNext = true;
+        } else {
+          OutputAreaData.clear(this.data);
+        }
         break;
       case 'update_display_data':
         output = msg.content as nbformat.IOutput;
@@ -449,7 +528,7 @@ export class OutputArea extends Widget {
         targets = this._displayIdMap.get(displayId);
         if (targets) {
           for (let index of targets) {
-            model.set(index, output);
+            OutputAreaData.setItem(this.data, index, output);
           }
         }
         break;
@@ -457,8 +536,12 @@ export class OutputArea extends Widget {
         break;
     }
     if (displayId && msgType === 'display_data') {
+      let list = DatastoreExt.getField(this.data.datastore, {
+        ...this.data.record,
+        field: 'outputs'
+      });
       targets = this._displayIdMap.get(displayId) || [];
-      targets.push(model.length - 1);
+      targets.push(list.length - 1);
       this._displayIdMap.set(displayId, targets);
     }
   };
@@ -470,7 +553,6 @@ export class OutputArea extends Widget {
     // API responses that contain a pager are special cased and their type
     // is overridden from 'execute_reply' to 'display_data' in order to
     // render output.
-    let model = this.model;
     let content = msg.content;
     if (content.status !== 'ok') {
       return;
@@ -489,15 +571,26 @@ export class OutputArea extends Widget {
       data: (page as any).data as nbformat.IMimeBundle,
       metadata: {}
     };
-    model.add(output);
+    this._appendItem(output);
   };
 
+  private _appendItem(output: nbformat.IOutput): void {
+    if (this._clearNext) {
+      OutputAreaData.clear(this.data);
+      this._clearNext = false;
+      return;
+    }
+    OutputAreaData.appendItem(this.data, output);
+  }
+
   private _minHeightTimeout: number = null;
   private _future: Kernel.IShellFuture<
     KernelMessage.IExecuteRequestMsg,
     KernelMessage.IExecuteReplyMsg
   > | null = null;
   private _displayIdMap = new Map<string, number[]>();
+  private _datastore: Datastore | null = null;
+  private _clearNext = false;
 }
 
 export class SimplifiedOutputArea extends OutputArea {
@@ -514,8 +607,10 @@ export class SimplifiedOutputArea extends OutputArea {
   /**
    * Create an output item without a prompt, just the output widgets
    */
-  protected createOutputItem(model: IOutputModel): Widget | null {
-    let output = this.createRenderedMimetype(model);
+  protected createOutputItem(
+    loc: DatastoreExt.RecordLocation<IOutputData.Schema>
+  ): Widget | null {
+    let output = this.createRenderedMimetype(loc);
     if (output) {
       output.addClass(OUTPUT_AREA_OUTPUT_CLASS);
     }
@@ -534,7 +629,7 @@ export namespace OutputArea {
     /**
      * The model used by the widget.
      */
-    model: IOutputAreaModel;
+    data?: IOutputAreaData.DataLocation;
 
     /**
      * The content factory used by the widget to create children.
diff --git a/packages/outputarea/tsconfig.json b/packages/outputarea/tsconfig.json
index 21861f5318c..cf88d3cb27d 100644
--- a/packages/outputarea/tsconfig.json
+++ b/packages/outputarea/tsconfig.json
@@ -13,7 +13,7 @@
       "path": "../coreutils"
     },
     {
-      "path": "../observables"
+      "path": "../datastore"
     },
     {
       "path": "../rendermime"
diff --git a/packages/rendermime/package.json b/packages/rendermime/package.json
index 24f7c1459f3..c1c5827cece 100644
--- a/packages/rendermime/package.json
+++ b/packages/rendermime/package.json
@@ -38,13 +38,13 @@
     "@jupyterlab/apputils": "^1.0.1",
     "@jupyterlab/codemirror": "^1.0.1",
     "@jupyterlab/coreutils": "^3.0.0",
-    "@jupyterlab/observables": "^2.2.0",
+    "@jupyterlab/datastore": "^1.0.0",
     "@jupyterlab/rendermime-interfaces": "^1.3.0",
     "@jupyterlab/services": "^4.0.1",
     "@phosphor/algorithm": "^1.1.3",
     "@phosphor/coreutils": "^1.3.1",
+    "@phosphor/datastore": "0.7.2",
     "@phosphor/messaging": "^1.2.3",
-    "@phosphor/signaling": "^1.2.3",
     "@phosphor/widgets": "^1.8.0",
     "lodash.escape": "^4.0.1",
     "marked": "0.6.2"
diff --git a/packages/rendermime/src/attachmentmodel.ts b/packages/rendermime/src/attachmentmodel.ts
deleted file mode 100644
index ec99a5b8cc3..00000000000
--- a/packages/rendermime/src/attachmentmodel.ts
+++ /dev/null
@@ -1,231 +0,0 @@
-/*-----------------------------------------------------------------------------
-| Copyright (c) Jupyter Development Team.
-| Distributed under the terms of the Modified BSD License.
-|----------------------------------------------------------------------------*/
-
-import { nbformat } from '@jupyterlab/coreutils';
-
-import { IObservableJSON, ObservableJSON } from '@jupyterlab/observables';
-
-import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
-
-import {
-  JSONExt,
-  JSONObject,
-  JSONValue,
-  ReadonlyJSONObject
-} from '@phosphor/coreutils';
-
-import { ISignal, Signal } from '@phosphor/signaling';
-
-import { MimeModel } from './mimemodel';
-
-/**
- * The interface for an attachment model.
- */
-export interface IAttachmentModel extends IRenderMime.IMimeModel {
-  /**
-   * A signal emitted when the attachment model changes.
-   */
-  readonly changed: ISignal<this, void>;
-
-  /**
-   * Dispose of the resources used by the attachment model.
-   */
-  dispose(): void;
-
-  /**
-   * Serialize the model to JSON.
-   */
-  toJSON(): nbformat.IMimeBundle;
-}
-
-/**
- * The namespace for IAttachmentModel sub-interfaces.
- */
-export namespace IAttachmentModel {
-  /**
-   * The options used to create a notebook attachment model.
-   */
-  export interface IOptions {
-    /**
-     * The raw attachment value.
-     */
-    value: nbformat.IMimeBundle;
-  }
-}
-
-/**
- * The default implementation of a notebook attachment model.
- */
-export class AttachmentModel implements IAttachmentModel {
-  /**
-   * Construct a new attachment model.
-   */
-  constructor(options: IAttachmentModel.IOptions) {
-    let { data } = Private.getBundleOptions(options);
-    this._data = new ObservableJSON({ values: data as JSONObject });
-    this._rawData = data;
-    // Make a copy of the data.
-    let value = options.value;
-    for (let key in value) {
-      // Ignore data and metadata that were stripped.
-      switch (key) {
-        case 'data':
-          break;
-        default:
-          this._raw[key] = Private.extract(value, key);
-      }
-    }
-  }
-
-  /**
-   * A signal emitted when the attachment model changes.
-   */
-  get changed(): ISignal<this, void> {
-    return this._changed;
-  }
-
-  /**
-   * Dispose of the resources used by the attachment model.
-   */
-  dispose(): void {
-    this._data.dispose();
-    Signal.clearData(this);
-  }
-
-  /**
-   * The data associated with the model.
-   */
-  get data(): ReadonlyJSONObject {
-    return this._rawData;
-  }
-
-  /**
-   * The metadata associated with the model.
-   */
-  get metadata(): ReadonlyJSONObject {
-    return undefined;
-  }
-
-  /**
-   * Set the data associated with the model.
-   *
-   * #### Notes
-   * Depending on the implementation of the mime model,
-   * this call may or may not have deferred effects,
-   */
-  setData(options: IRenderMime.IMimeModel.ISetDataOptions): void {
-    if (options.data) {
-      this._updateObservable(this._data, options.data);
-      this._rawData = options.data;
-    }
-    this._changed.emit(void 0);
-  }
-
-  /**
-   * Serialize the model to JSON.
-   */
-  toJSON(): nbformat.IMimeBundle {
-    let attachment: JSONValue = {};
-    for (let key in this._raw) {
-      attachment[key] = Private.extract(this._raw, key);
-    }
-    return attachment as nbformat.IMimeBundle;
-  }
-
-  // All attachments are untrusted
-  readonly trusted: boolean = false;
-
-  /**
-   * Update an observable JSON object using a readonly JSON object.
-   */
-  private _updateObservable(
-    observable: IObservableJSON,
-    data: ReadonlyJSONObject
-  ) {
-    let oldKeys = observable.keys();
-    let newKeys = Object.keys(data);
-
-    // Handle removed keys.
-    for (let key of oldKeys) {
-      if (newKeys.indexOf(key) === -1) {
-        observable.delete(key);
-      }
-    }
-
-    // Handle changed data.
-    for (let key of newKeys) {
-      let oldValue = observable.get(key);
-      let newValue = data[key];
-      if (oldValue !== newValue) {
-        observable.set(key, newValue as JSONValue);
-      }
-    }
-  }
-
-  private _changed = new Signal<this, void>(this);
-  private _raw: JSONObject = {};
-  private _rawData: ReadonlyJSONObject;
-  private _data: IObservableJSON;
-}
-
-/**
- * The namespace for AttachmentModel statics.
- */
-export namespace AttachmentModel {
-  /**
-   * Get the data for an attachment.
-   *
-   * @params bundle - A kernel attachment MIME bundle.
-   *
-   * @returns - The data for the payload.
-   */
-  export function getData(bundle: nbformat.IMimeBundle): JSONObject {
-    return Private.getData(bundle);
-  }
-}
-
-/**
- * The namespace for module private data.
- */
-namespace Private {
-  /**
-   * Get the data from a notebook attachment.
-   */
-  export function getData(bundle: nbformat.IMimeBundle): JSONObject {
-    return convertBundle(bundle);
-  }
-
-  /**
-   * Get the bundle options given attachment model options.
-   */
-  export function getBundleOptions(
-    options: IAttachmentModel.IOptions
-  ): MimeModel.IOptions {
-    let data = getData(options.value);
-    return { data };
-  }
-
-  /**
-   * Extract a value from a JSONObject.
-   */
-  export function extract(value: JSONObject, key: string): JSONValue {
-    let item = value[key];
-    if (JSONExt.isPrimitive(item)) {
-      return item;
-    }
-    return JSONExt.deepCopy(item);
-  }
-
-  /**
-   * Convert a mime bundle to mime data.
-   */
-  function convertBundle(bundle: nbformat.IMimeBundle): JSONObject {
-    let map: JSONObject = Object.create(null);
-    for (let mimeType in bundle) {
-      map[mimeType] = extract(bundle, mimeType);
-    }
-    return map;
-  }
-}
diff --git a/packages/rendermime/src/index.ts b/packages/rendermime/src/index.ts
index e21201ea14d..949dfef41bb 100644
--- a/packages/rendermime/src/index.ts
+++ b/packages/rendermime/src/index.ts
@@ -4,7 +4,6 @@
 |----------------------------------------------------------------------------*/
 
 export * from '@jupyterlab/rendermime-interfaces';
-export * from './attachmentmodel';
 export * from './factories';
 export * from './latex';
 export * from './mimemodel';
diff --git a/packages/rendermime/src/outputmodel.ts b/packages/rendermime/src/outputmodel.ts
index 0624057d172..42efebd665a 100644
--- a/packages/rendermime/src/outputmodel.ts
+++ b/packages/rendermime/src/outputmodel.ts
@@ -2,6 +2,12 @@
 | Copyright (c) Jupyter Development Team.
 | Distributed under the terms of the Modified BSD License.
 |----------------------------------------------------------------------------*/
+import { nbformat } from '@jupyterlab/coreutils';
+
+import { DatastoreExt } from '@jupyterlab/datastore';
+
+import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
+
 import {
   JSONExt,
   JSONObject,
@@ -9,25 +15,105 @@ import {
   ReadonlyJSONObject
 } from '@phosphor/coreutils';
 
-import { ISignal, Signal } from '@phosphor/signaling';
+import { Datastore, Fields, Record, RegisterField } from '@phosphor/datastore';
 
-import { nbformat } from '@jupyterlab/coreutils';
+import { MimeModel } from './mimemodel';
 
-import { IObservableJSON, ObservableJSON } from '@jupyterlab/observables';
+/**
+ * A namespace for interfaces describing where an IOutputModel
+ * holds its data.
+ */
+export namespace IOutputData {
+  /**
+   * A type alias for the ouput model schema.
+   */
+  export type Schema = {
+    /**
+     * The id for the schema.
+     */
+    id: string;
 
-import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
+    /**
+     * The fields for a single output.
+     */
+    fields: {
+      /**
+       * Whether the output model is trusted.
+       */
+      trusted: RegisterField<boolean>;
+
+      /**
+       * The type of the output model.
+       */
+      type: RegisterField<string>;
+
+      /**
+       * The execution count of the model.
+       */
+      executionCount: RegisterField<nbformat.ExecutionCount>;
+
+      /**
+       * The data for the model.
+       */
+      data: RegisterField<ReadonlyJSONObject>;
+
+      /**
+       * The metadata for the model.
+       */
+      metadata: RegisterField<ReadonlyJSONObject>;
+
+      /**
+       * Raw data passed in that is not in the data or metadata fields.
+       */
+      raw: RegisterField<ReadonlyJSONObject>;
+    };
+  };
 
-import { MimeModel } from './mimemodel';
+  /**
+   * A description of where data is stored in a code editor.
+   */
+  export type DataLocation = DatastoreExt.DataLocation & {
+    /**
+     * The record in which the data is located.
+     */
+    record: DatastoreExt.RecordLocation<Schema>;
+  };
+}
 
 /**
- * The interface for an output model.
+ * A namespace for default implementation of the IOutputData functionality.
  */
-export interface IOutputModel extends IRenderMime.IMimeModel {
+export namespace OutputData {
   /**
-   * A signal emitted when the output model changes.
+   * A concrete realization of the schema, available at runtime.
    */
-  readonly changed: ISignal<this, void>;
+  export const SCHEMA: IOutputData.Schema = {
+    id: '@jupyterlab/rendermime:outputmodel.v1',
+    fields: {
+      trusted: Fields.Boolean(),
+      type: Fields.String(),
+      executionCount: Fields.Register<nbformat.ExecutionCount>({ value: null }),
+      data: Fields.Register<ReadonlyJSONObject>({ value: {} }),
+      metadata: Fields.Register<ReadonlyJSONObject>({ value: {} }),
+      raw: Fields.Register<ReadonlyJSONObject>({ value: {} })
+    }
+  };
 
+  /**
+   * Create an in-memory datastore capable of holding the data for an output.
+   */
+  export function createStore(id: number = 1): Datastore {
+    return Datastore.create({
+      id,
+      schemas: [SCHEMA]
+    });
+  }
+}
+
+/**
+ * The interface for an output model.
+ */
+export interface IOutputModel extends IRenderMime.IMimeModel {
   /**
    * The output type.
    */
@@ -55,7 +141,7 @@ export interface IOutputModel extends IRenderMime.IMimeModel {
 }
 
 /**
- * The namespace for IOutputModel sub-interfaces.
+ * A namespace for IOutputModel statics.
  */
 export namespace IOutputModel {
   /**
@@ -65,12 +151,17 @@ export namespace IOutputModel {
     /**
      * The raw output value.
      */
-    value: nbformat.IOutput;
+    value?: nbformat.IOutput;
 
     /**
      * Whether the output is trusted.  The default is false.
      */
     trusted?: boolean;
+
+    /**
+     * A location in which to store the data.
+     */
+    data?: IOutputData.DataLocation;
   }
 }
 
@@ -82,75 +173,85 @@ export class OutputModel implements IOutputModel {
    * Construct a new output model.
    */
   constructor(options: IOutputModel.IOptions) {
-    let { data, metadata, trusted } = Private.getBundleOptions(options);
-    this._data = new ObservableJSON({ values: data as JSONObject });
-    this._rawData = data;
-    this._metadata = new ObservableJSON({ values: metadata as JSONObject });
-    this._rawMetadata = metadata;
-    this.trusted = trusted;
-    // Make a copy of the data.
-    let value = options.value;
-    for (let key in value) {
-      // Ignore data and metadata that were stripped.
-      switch (key) {
-        case 'data':
-        case 'metadata':
-          break;
-        default:
-          this._raw[key] = Private.extract(value, key);
-      }
-    }
-    this.type = value.output_type;
-    if (nbformat.isExecuteResult(value)) {
-      this.executionCount = value.execution_count;
+    if (options.data) {
+      this._data = options.data;
     } else {
-      this.executionCount = null;
+      this._datastore = OutputData.createStore();
+      this._data = {
+        datastore: this._datastore,
+        record: {
+          schema: OutputData.SCHEMA,
+          record: 'data'
+        }
+      };
+      if (options.value) {
+        OutputModel.fromJSON(this._data, options.value, options.trusted);
+      }
     }
   }
 
-  /**
-   * A signal emitted when the output model changes.
-   */
-  get changed(): ISignal<this, void> {
-    return this._changed;
-  }
-
   /**
    * The output type.
    */
-  readonly type: string;
+  get type(): string {
+    return DatastoreExt.getField(this._data.datastore, {
+      ...this._data.record,
+      field: 'type'
+    });
+  }
 
   /**
    * The execution count.
    */
-  readonly executionCount: nbformat.ExecutionCount;
+  get executionCount(): nbformat.ExecutionCount {
+    return DatastoreExt.getField(this._data.datastore, {
+      ...this._data.record,
+      field: 'executionCount'
+    });
+  }
 
   /**
    * Whether the model is trusted.
    */
-  readonly trusted: boolean;
+  get trusted(): boolean {
+    return DatastoreExt.getField(this._data.datastore, {
+      ...this._data.record,
+      field: 'trusted'
+    });
+  }
 
   /**
    * Dispose of the resources used by the output model.
    */
   dispose(): void {
-    this._data.dispose();
-    this._metadata.dispose();
-    Signal.clearData(this);
+    if (this._isDisposed) {
+      return;
+    }
+    this._isDisposed = true;
+    if (this._datastore) {
+      this._datastore.dispose();
+      this._datastore = null;
+    }
   }
 
   /**
    * The data associated with the model.
    */
   get data(): ReadonlyJSONObject {
-    return this._rawData;
+    return DatastoreExt.getField(this._data.datastore, {
+      ...this._data.record,
+      field: 'data'
+    });
   }
 
   /**
    * The metadata associated with the model.
    */
   get metadata(): ReadonlyJSONObject {
-    return this._rawMetadata;
+    return DatastoreExt.getField(this._data.datastore, {
+      ...this._data.record,
+      field: 'metadata'
+    });
   }
 
   /**
@@ -161,73 +262,36 @@ export class OutputModel implements IOutputModel {
    * this call may or may not have deferred effects,
    */
   setData(options: IRenderMime.IMimeModel.ISetDataOptions): void {
+    let metadataUpdate: Record.Update<IOutputData.Schema> = {};
+    let dataUpdate: Record.Update<IOutputData.Schema> = {};
     if (options.data) {
-      this._updateObservable(this._data, options.data);
-      this._rawData = options.data;
+      dataUpdate = { data: options.data };
     }
     if (options.metadata) {
-      this._updateObservable(this._metadata, options.metadata);
-      this._rawMetadata = options.metadata;
+      metadataUpdate = { metadata: options.metadata };
     }
-    this._changed.emit(void 0);
+    const { datastore, record } = this._data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateRecord(datastore, record, {
+        ...dataUpdate,
+        ...metadataUpdate
+      });
+    });
   }
 
   /**
    * Serialize the model to JSON.
    */
   toJSON(): nbformat.IOutput {
-    let output: JSONValue = {};
-    for (let key in this._raw) {
-      output[key] = Private.extract(this._raw, key);
-    }
-    switch (this.type) {
-      case 'display_data':
-      case 'execute_result':
-      case 'update_display_data':
-        output['data'] = this.data as JSONObject;
-        output['metadata'] = this.metadata as JSONObject;
-        break;
-      default:
-        break;
-    }
-    // Remove transient data.
-    delete output['transient'];
-    return output as nbformat.IOutput;
+    return OutputModel.toJSON(this._data);
   }
 
   /**
-   * Update an observable JSON object using a readonly JSON object.
+   * The record in which the output model is stored.
    */
-  private _updateObservable(
-    observable: IObservableJSON,
-    data: ReadonlyJSONObject
-  ) {
-    let oldKeys = observable.keys();
-    let newKeys = Object.keys(data);
-
-    // Handle removed keys.
-    for (let key of oldKeys) {
-      if (newKeys.indexOf(key) === -1) {
-        observable.delete(key);
-      }
-    }
-
-    // Handle changed data.
-    for (let key of newKeys) {
-      let oldValue = observable.get(key);
-      let newValue = data[key];
-      if (oldValue !== newValue) {
-        observable.set(key, newValue as JSONValue);
-      }
-    }
-  }
-
-  private _changed = new Signal<this, void>(this);
-  private _raw: JSONObject = {};
-  private _rawMetadata: ReadonlyJSONObject;
-  private _rawData: ReadonlyJSONObject;
-  private _data: IObservableJSON;
-  private _metadata: IObservableJSON;
+  private readonly _data: IOutputData.DataLocation;
+  private _datastore: Datastore | null = null;
+  private _isDisposed = false;
 }
 
 /**
@@ -255,6 +319,91 @@ export namespace OutputModel {
   export function getMetadata(output: nbformat.IOutput): JSONObject {
     return Private.getMetadata(output);
   }
+
+  /**
+   * Serialize an output record to JSON.
+   */
+  export function toJSON(loc: IOutputData.DataLocation): nbformat.IOutput {
+    let { datastore, record } = loc;
+    let output: JSONObject = DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'raw'
+    }) as JSONObject;
+    const type = DatastoreExt.getField(datastore, { ...record, field: 'type' });
+    const data = DatastoreExt.getField(datastore, { ...record, field: 'data' });
+    const metadata = DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'metadata'
+    });
+    switch (type) {
+      case 'display_data':
+      case 'execute_result':
+      case 'update_display_data':
+        output['data'] = data as JSONValue;
+        output['metadata'] = metadata as JSONValue;
+        break;
+      default:
+        break;
+    }
+    // Remove transient data.
+    delete output['transient'];
+    return output as nbformat.IOutput;
+  }
+
+  export function fromJSON(
+    loc: IOutputData.DataLocation,
+    value: nbformat.IOutput,
+    trusted: boolean = false
+  ): void {
+    const { datastore, record } = loc;
+    let data = Private.getData(value);
+    let metadata = Private.getData(value);
+    trusted = !!trusted;
+
+    let raw: { [x: string]: JSONValue } = {};
+    for (let key in value) {
+      // Ignore data and metadata that were stripped.
+      switch (key) {
+        case 'data':
+        case 'metadata':
+          break;
+        default:
+          raw[key] = Private.extract(value, key);
+      }
+    }
+    const type = value.output_type;
+    const executionCount = nbformat.isExecuteResult(value)
+      ? value.execution_count
+      : null;
+
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateRecord(datastore, record, {
+        data,
+        executionCount,
+        metadata,
+        raw,
+        trusted,
+        type
+      });
+    });
+  }
+
+  /**
+   * Clear an output record from a table.
+   */
+  export function clear(loc: IOutputData.DataLocation): void {
+    const { datastore, record } = loc;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateRecord(datastore, record, {
+        data: {},
+        executionCount: null,
+        metadata: {},
+        raw: {},
+        trusted: false,
+        type: ''
+      });
+    });
+  }
 }
 
 /**
diff --git a/packages/rendermime/tsconfig.json b/packages/rendermime/tsconfig.json
index 7498c987854..a18944a270c 100644
--- a/packages/rendermime/tsconfig.json
+++ b/packages/rendermime/tsconfig.json
@@ -16,7 +16,7 @@
       "path": "../coreutils"
     },
     {
-      "path": "../observables"
+      "path": "../datastore"
     },
     {
       "path": "../rendermime-interfaces"
diff --git a/packages/services/package.json b/packages/services/package.json
index 7e616a7faa0..d78be9e255a 100644
--- a/packages/services/package.json
+++ b/packages/services/package.json
@@ -42,7 +42,6 @@
   },
   "dependencies": {
     "@jupyterlab/coreutils": "^3.0.0",
-    "@jupyterlab/observables": "^2.2.0",
     "@phosphor/algorithm": "^1.1.3",
     "@phosphor/coreutils": "^1.3.1",
     "@phosphor/disposable": "^1.2.0",
diff --git a/packages/services/src/contents/index.ts b/packages/services/src/contents/index.ts
index 79be3a6c5f2..905b161e742 100644
--- a/packages/services/src/contents/index.ts
+++ b/packages/services/src/contents/index.ts
@@ -3,8 +3,6 @@
 
 import { URLExt, PathExt } from '@jupyterlab/coreutils';
 
-import { ModelDB } from '@jupyterlab/observables';
-
 import { JSONObject } from '@phosphor/coreutils';
 
 import { each } from '@phosphor/algorithm';
@@ -253,13 +251,6 @@ export namespace Contents {
      */
     driveName(path: string): string;
 
-    /**
-     * Given a path, get a ModelDB.IFactory from the
-     * relevant backend. Returns `null` if the backend
-     * does not provide one.
-     */
-    getModelDBFactory(path: string): ModelDB.IFactory | null;
-
     /**
      * Get a file or directory.
      *
@@ -393,12 +384,6 @@ export namespace Contents {
      */
     readonly serverSettings: ServerConnection.ISettings;
 
-    /**
-     * An optional ModelDB.IFactory instance for the
-     * drive.
-     */
-    readonly modelDBFactory?: ModelDB.IFactory;
-
     /**
      * A signal emitted when a file operation takes place.
      */
@@ -581,16 +566,6 @@ export class ContentsManager implements Contents.IManager {
     drive.fileChanged.connect(this._onFileChanged, this);
   }
 
-  /**
-   * Given a path, get a ModelDB.IFactory from the
-   * relevant backend. Returns `null` if the backend
-   * does not provide one.
-   */
-  getModelDBFactory(path: string): ModelDB.IFactory | null {
-    let [drive] = this._driveForPath(path);
-    return (drive && drive.modelDBFactory) || null;
-  }
-
   /**
    * Given a path of the form `drive:local/portion/of/it.txt`
    * get the local part of it.
diff --git a/packages/services/src/index.ts b/packages/services/src/index.ts
index fc86490bf28..a78a8595407 100644
--- a/packages/services/src/index.ts
+++ b/packages/services/src/index.ts
@@ -10,6 +10,7 @@ export * from './session';
 export * from './setting';
 export * from './terminal';
 export * from './workspace';
+export * from './wsconnection';
 export * from './nbconvert';
 
 export { Builder } from './builder';
diff --git a/packages/services/src/wsconnection.ts b/packages/services/src/wsconnection.ts
new file mode 100644
index 00000000000..2b257668ecd
--- /dev/null
+++ b/packages/services/src/wsconnection.ts
@@ -0,0 +1,221 @@
+// Copyright (c) Jupyter Development Team.
+// Distributed under the terms of the Modified BSD License.
+
+import { PromiseDelegate } from '@phosphor/coreutils';
+
+import { IDisposable } from '@phosphor/disposable';
+
+/**
+ * Abstract base for a class that sends/receives messages over websocket.
+ */
+export abstract class WSConnection<TSendMsg, TRecvMsg> implements IDisposable {
+  /**
+   * Dispose of the resources held by the connection.
+   */
+  dispose(): void {
+    if (this.isDisposed) {
+      return;
+    }
+    this._isDisposed = true;
+    this._clearSocket();
+  }
+
+  /**
+   * Test whether the connection has been disposed.
+   */
+  get isDisposed(): boolean {
+    return this._isDisposed;
+  }
+
+  /**
+   * Test whether the connection is ready.
+   */
+  get isReady(): boolean {
+    return !this._wsStopped;
+  }
+
+  /**
+   * A promise that resolves once the connection is open.
+   */
+  get ready(): Promise<void> {
+    return this._readyDelegate.promise;
+  }
+
+  /**
+   * Factory function for a WebSocket.
+   */
+  protected abstract wsFactory(): WebSocket;
+
+  /**
+   * Send a message over the websocket.
+   *
+   * @param msg - The JSON value to send.
+   *
+   */
+  protected sendMessage(msg: TSendMsg) {
+    if (!this._ws || this._wsStopped) {
+      throw new Error('Web socket not connected');
+    }
+
+    const value = this.serializeWSMessage(msg);
+
+    this._ws.send(value);
+  }
+
+  /**
+   * Handle a received, decoded WS message.
+   *
+   * @param msg - The decoded message that was received.
+   *
+   * @returns Whether the message was handled.
+   */
+  protected abstract handleMessage(msg: TRecvMsg): boolean;
+
+  /**
+   * Whether a closed connection should reconnect.
+   *
+   * @return - Returns false if it should not reconnect.
+   * Otherwise it returns a number indicating the delay before reconnecting
+   * in ms. Return 0 to reconnect as soon as possible.
+   */
+  protected shouldReconnect(): false | number {
+    if (this.reconnectAttempt >= this.reconnectLimit) {
+      console.log(
+        `Websocket reconnect abandoned after ${this.reconnectAttempt} attempts`
+      );
+      return false;
+    }
+    return 1e3 * Math.pow(2, this.reconnectAttempt++);
+  }
+
+  protected serializeWSMessage(
+    msg: TSendMsg
+  ): string | ArrayBuffer | Blob | ArrayBufferView {
+    return JSON.stringify(msg);
+  }
+
+  protected deserializeWSMessage(data: unknown): TRecvMsg {
+    if (typeof data !== 'string') {
+      console.error(`Invalid websocket message data type: ${typeof data}`);
+      return;
+    }
+    try {
+      return JSON.parse(data);
+    } catch (error) {
+      console.error(`Invalid message: ${error.message}`);
+      return;
+    }
+  }
+
+  /**
+   * Create the websocket connection and add socket status handlers.
+   */
+  protected _createSocket = () => {
+    this._clearSocket();
+    this._wsStopped = false;
+    this._ws = this.wsFactory();
+    this._readyDelegate = new PromiseDelegate<void>();
+
+    this._ws.onmessage = this._onWSMessage.bind(this);
+    this._ws.onopen = this._onWSOpen.bind(this);
+    this._ws.onclose = this._onWSClose.bind(this);
+    this._ws.onerror = this._onWSError.bind(this);
+  };
+
+  /**
+   * Clear the socket state.
+   */
+  private _clearSocket(): void {
+    this._wsStopped = true;
+    if (this._ws !== null) {
+      // Clear the websocket event handlers and the socket itself.
+      this._ws.onopen = this._noOp;
+      this._ws.onclose = this._noOp;
+      this._ws.onerror = this._noOp;
+      this._ws.onmessage = this._noOp;
+      this._ws.close();
+      this._ws = null;
+    }
+  }
+
+  private _onWSOpen(evt: Event): void {
+    if (!this.isDisposed) {
+      this.reconnectAttempt = 0;
+      this._wsStopped = false;
+      this._readyDelegate.resolve(undefined);
+    }
+  }
+
+  private _onWSMessage(evt: MessageEvent) {
+    if (this._wsStopped) {
+      // If the socket is being closed, ignore any messages
+      return;
+    }
+    const msg = this.deserializeWSMessage(evt.data);
+
+    let handled = this.handleMessage(msg);
+    if (!handled) {
+      console.log('Unhandled websocket message.', msg);
+    }
+  }
+
+  private _onWSClose(evt: CloseEvent) {
+    if (this._wsStopped || !this._ws) {
+      return;
+    }
+    console.warn(`Websocket closed: ${evt.code}`);
+    this._reconnectSocket();
+  }
+
+  private _onWSError(evt: Event) {
+    if (!this._isDisposed) {
+      this._readyDelegate.reject(evt);
+    }
+  }
+
+  private _reconnectSocket(): void {
+    const delay = this.shouldReconnect();
+    if (delay === false) {
+      return;
+    }
+
+    console.log(`Websocket will attempt to reconnect in ${delay * 1e-3}s`);
+    this._wsStopped = true;
+
+    setTimeout(() => {
+      if (this.isDisposed) {
+        return;
+      }
+      this._createSocket();
+      this.ready
+        .then(() => {
+          console.log('Websocket reconnected');
+        })
+        .catch(reason => {
+          console.warn(`Websocket reconnect failed`, reason);
+        });
+    }, delay);
+  }
+
+  protected readonly reconnectLimit = 7;
+  protected reconnectAttempt = 0;
+  protected _ws: WebSocket | null = null;
+  protected _wsStopped = true;
+
+  private _isDisposed = false;
+  private _readyDelegate: PromiseDelegate<void> | null = null;
+
+  private readonly _noOp = () => {
+    /* no-op */
+  };
+}
+
+/**
+ * The namespace for WSConnection statics.
+ */
+export namespace WSConnection {
+  /**
+   * A websocket factory function.
+   */
+  export type WSFactory = () => WebSocket;
+}
diff --git a/packages/services/tsconfig.json b/packages/services/tsconfig.json
index 1c324ae71e1..4446231729e 100644
--- a/packages/services/tsconfig.json
+++ b/packages/services/tsconfig.json
@@ -10,9 +10,6 @@
   "references": [
     {
       "path": "../coreutils"
-    },
-    {
-      "path": "../observables"
     }
   ]
 }
diff --git a/packages/settingeditor/package.json b/packages/settingeditor/package.json
index 475aaaee885..49b52f43852 100644
--- a/packages/settingeditor/package.json
+++ b/packages/settingeditor/package.json
@@ -38,6 +38,7 @@
     "@jupyterlab/apputils": "^1.0.1",
     "@jupyterlab/codeeditor": "^1.0.0",
     "@jupyterlab/coreutils": "^3.0.0",
+    "@jupyterlab/datastore": "^1.0.0",
     "@jupyterlab/inspector": "^1.0.1",
     "@jupyterlab/rendermime": "^1.0.1",
     "@phosphor/commands": "^1.6.3",
diff --git a/packages/settingeditor/src/raweditor.ts b/packages/settingeditor/src/raweditor.ts
index d88ea31c264..40e85646cb5 100644
--- a/packages/settingeditor/src/raweditor.ts
+++ b/packages/settingeditor/src/raweditor.ts
@@ -7,6 +7,8 @@ import { CodeEditor, CodeEditorWrapper } from '@jupyterlab/codeeditor';
 
 import { ISettingRegistry } from '@jupyterlab/coreutils';
 
+import { DatastoreExt } from '@jupyterlab/datastore';
+
 import { IRenderMimeRegistry } from '@jupyterlab/rendermime';
 
 import { CommandRegistry } from '@phosphor/commands';
@@ -71,7 +73,7 @@ export class RawEditor extends SplitPanel {
       factory: editorFactory
     }));
 
-    defaults.editor.model.value.text = '';
+    defaults.editor.model.value = '';
     defaults.editor.model.mimeType = 'text/javascript';
     defaults.editor.setOption('readOnly', true);
 
@@ -84,7 +86,12 @@ export class RawEditor extends SplitPanel {
 
     user.addClass(USER_CLASS);
     user.editor.model.mimeType = 'text/javascript';
-    user.editor.model.value.changed.connect(this._onTextChanged, this);
+    DatastoreExt.listenField(
+      user.editor.model.data.datastore,
+      { ...user.editor.model.data.record, field: 'text' },
+      this._onTextChanged,
+      this
+    );
 
     // Create and set up an inspector.
     this._inspector = createInspector(this, options.rendermime);
@@ -125,7 +132,7 @@ export class RawEditor extends SplitPanel {
    * Tests whether the settings have been modified and need saving.
    */
   get isDirty(): boolean {
-    return this._user.editor.model.value.text !== this._settings.raw;
+    return this._user.editor.model.value !== this._settings.raw;
   }
 
   /**
@@ -160,8 +167,8 @@ export class RawEditor extends SplitPanel {
       this._onSettingsChanged();
     } else {
       this._settings = null;
-      defaults.editor.model.value.text = '';
-      user.editor.model.value.text = '';
+      defaults.editor.model.value = '';
+      user.editor.model.value = '';
     }
 
     this.update();
@@ -201,7 +208,7 @@ export class RawEditor extends SplitPanel {
    * Revert the editor back to original settings.
    */
   revert(): void {
-    this._user.editor.model.value.text = this.settings.raw;
+    this._user.editor.model.value = this.settings.raw;
     this._updateToolbar(false, false);
   }
 
@@ -214,7 +221,7 @@ export class RawEditor extends SplitPanel {
     }
 
     const settings = this._settings;
-    const source = this._user.editor.model.value.text;
+    const source = this._user.editor.model.value;
 
     return settings
       .save(source)
@@ -253,7 +260,7 @@ export class RawEditor extends SplitPanel {
    * Handle text changes in the underlying editor.
    */
   private _onTextChanged(): void {
-    const raw = this._user.editor.model.value.text;
+    const raw = this._user.editor.model.value;
     const settings = this._settings;
 
     this.removeClass(ERROR_CLASS);
@@ -283,8 +290,8 @@ export class RawEditor extends SplitPanel {
     const defaults = this._defaults;
     const user = this._user;
 
-    defaults.editor.model.value.text = settings.annotatedDefaults();
-    user.editor.model.value.text = settings.raw;
+    defaults.editor.model.value = settings.annotatedDefaults();
+    user.editor.model.value = settings.raw;
   }
 
   private _updateToolbar(revert = this._canRevert, save = this._canSave): void {
diff --git a/packages/settingeditor/tsconfig.json b/packages/settingeditor/tsconfig.json
index e38e704a2b3..ab1a186813e 100644
--- a/packages/settingeditor/tsconfig.json
+++ b/packages/settingeditor/tsconfig.json
@@ -15,6 +15,9 @@
     {
       "path": "../coreutils"
     },
+    {
+      "path": "../datastore"
+    },
     {
       "path": "../inspector"
     },
diff --git a/packages/statusbar-extension/src/index.ts b/packages/statusbar-extension/src/index.ts
index 0628a1b6173..fa8138a226c 100644
--- a/packages/statusbar-extension/src/index.ts
+++ b/packages/statusbar-extension/src/index.ts
@@ -253,7 +253,11 @@ export const lineColItem: JupyterFrontEndPlugin<void> = {
         );
         const cell = (newValue as NotebookPanel).content.activeCell;
         item.model!.editor = cell && cell.editor;
-      } else if (newValue && editorTracker.has(newValue)) {
+      } else if (
+        newValue &&
+        editorTracker.has(newValue) &&
+        (newValue as IDocumentWidget<FileEditor>).content.editor
+      ) {
         item.model!.editor = (newValue as IDocumentWidget<
           FileEditor
         >).content.editor;
diff --git a/packages/statusbar/package.json b/packages/statusbar/package.json
index 325339b7cfc..aaeb662e22e 100644
--- a/packages/statusbar/package.json
+++ b/packages/statusbar/package.json
@@ -34,6 +34,7 @@
     "@jupyterlab/apputils": "^1.0.1",
     "@jupyterlab/codeeditor": "^1.0.0",
     "@jupyterlab/coreutils": "^3.0.0",
+    "@jupyterlab/datastore": "^1.0.0",
     "@jupyterlab/services": "^4.0.1",
     "@phosphor/algorithm": "^1.1.3",
     "@phosphor/coreutils": "^1.3.1",
diff --git a/packages/statusbar/src/defaults/lineCol.tsx b/packages/statusbar/src/defaults/lineCol.tsx
index 2240c2da940..653626d95c3 100644
--- a/packages/statusbar/src/defaults/lineCol.tsx
+++ b/packages/statusbar/src/defaults/lineCol.tsx
@@ -7,6 +7,10 @@ import { VDomRenderer, VDomModel, ReactWidget } from '@jupyterlab/apputils';
 
 import { CodeEditor } from '@jupyterlab/codeeditor';
 
+import { DatastoreExt } from '@jupyterlab/datastore';
+
+import { IDisposable } from '@phosphor/disposable';
+
 import { interactiveItem, showPopup, Popup, TextItem } from '..';
 
 import {
@@ -290,9 +294,9 @@ export namespace LineCol {
       return this._editor;
     }
     set editor(editor: CodeEditor.IEditor | null) {
-      const oldEditor = this._editor;
-      if (oldEditor) {
-        oldEditor.model.selections.changed.disconnect(this._onSelectionChanged);
+      if (this._selectionListener) {
+        this._selectionListener.dispose();
+        this._selectionListener = null;
       }
 
       const oldState = this._getAllState();
@@ -301,7 +305,11 @@ export namespace LineCol {
         this._column = 1;
         this._line = 1;
       } else {
-        this._editor.model.selections.changed.connect(this._onSelectionChanged);
+        DatastoreExt.listenField(
+          editor.model.data.datastore,
+          { ...editor.model.data.record, field: 'selections' },
+          this._onSelectionChanged
+        );
 
         const pos = this._editor.getCursorPosition();
         this._column = pos.column + 1;
@@ -353,5 +361,6 @@ export namespace LineCol {
     private _line: number = 1;
     private _column: number = 1;
     private _editor: CodeEditor.IEditor | null = null;
+    private _selectionListener: IDisposable | null = null;
   }
 }
diff --git a/packages/statusbar/tsconfig.json b/packages/statusbar/tsconfig.json
index 5ed8ed31f74..0cf42477966 100644
--- a/packages/statusbar/tsconfig.json
+++ b/packages/statusbar/tsconfig.json
@@ -15,6 +15,9 @@
     {
       "path": "../coreutils"
     },
+    {
+      "path": "../datastore"
+    },
     {
       "path": "../services"
     }
diff --git a/packages/tooltip-extension/src/index.ts b/packages/tooltip-extension/src/index.ts
index e1360b310b7..e69dde42ddb 100644
--- a/packages/tooltip-extension/src/index.ts
+++ b/packages/tooltip-extension/src/index.ts
@@ -292,7 +292,7 @@ namespace Private {
    */
   export function fetch(options: IFetchOptions): Promise<JSONObject> {
     let { detail, editor, kernel } = options;
-    let code = editor.model.value.text;
+    let code = editor.model.value;
     let position = editor.getCursorPosition();
     let offset = Text.jsIndexToCharIndex(editor.getOffsetAt(position), code);
 
diff --git a/setup.py b/setup.py
index d54ac6a3e3c..a3b563f8874 100644
--- a/setup.py
+++ b/setup.py
@@ -133,7 +133,7 @@ def run(self):
 setup_args['install_requires'] = [
     'notebook>=4.3.1',
     'tornado!=6.0.0, !=6.0.1, !=6.0.2',
-    'jupyterlab_server~=1.0.0rc0'
+    'jupyterlab_server~=1.0.2'
 ]
 
 setup_args['extras_require'] = {
diff --git a/yarn.lock b/yarn.lock
index 88df6f77338..df42085d9ac 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -1635,10 +1635,10 @@
     universal-user-agent "^2.0.0"
     url-template "^2.0.8"
 
-"@phosphor/algorithm@^1.1.3":
-  version "1.1.3"
-  resolved "https://registry.yarnpkg.com/@phosphor/algorithm/-/algorithm-1.1.3.tgz#fb0e974f4e81aadc06f948770b3060c4ec8a1e27"
-  integrity sha512-+dkdYTBglR+qGnLVQdCvYojNZMGxf+xSl1Jeksha3pm7niQktSFz2aR5gEPu/nI5LM8T8slTpqE4Pjvq8P+IVA==
+"@phosphor/algorithm@^1.1.3", "@phosphor/algorithm@^1.2.0":
+  version "1.2.0"
+  resolved "https://registry.yarnpkg.com/@phosphor/algorithm/-/algorithm-1.2.0.tgz#4a19aa59261b7270be696672dc3f0663f7bef152"
+  integrity sha512-C9+dnjXyU2QAkWCW6QVDGExk4hhwxzAKf5/FIuYlHAI9X5vFv99PYm0EREDxX1PbMuvfFBZhPNu0PvuSDQ7sFA==
 
 "@phosphor/application@^1.6.3":
   version "1.6.3"
@@ -1649,12 +1649,12 @@
     "@phosphor/coreutils" "^1.3.1"
     "@phosphor/widgets" "^1.8.0"
 
-"@phosphor/collections@^1.1.3":
-  version "1.1.3"
-  resolved "https://registry.yarnpkg.com/@phosphor/collections/-/collections-1.1.3.tgz#c938ee4138d97377bba1f0970102071ca3ac1420"
-  integrity sha512-J2U1xd2e5LtqoOJt4kynrjDNeHhVpJjuY2/zA0InS5kyOuWmvy79pt/KJ22n0LBNcU/fjkImqtQmbrC2Z4q2xQ==
+"@phosphor/collections@^1.2.0":
+  version "1.2.0"
+  resolved "https://registry.yarnpkg.com/@phosphor/collections/-/collections-1.2.0.tgz#a8cdd0edc0257de7c33306a91caf47910036307f"
+  integrity sha512-T9/0EjSuY6+ga2LIFRZ0xupciOR3Qnyy8Q95lhGTC0FXZUFwC8fl9e8On6IcwasCszS+1n8dtZUWSIynfgdpzw==
   dependencies:
-    "@phosphor/algorithm" "^1.1.3"
+    "@phosphor/algorithm" "^1.2.0"
 
 "@phosphor/commands@^1.6.3":
   version "1.6.3"
@@ -1687,13 +1687,25 @@
     "@phosphor/signaling" "^1.2.3"
     "@phosphor/widgets" "^1.8.0"
 
-"@phosphor/disposable@^1.2.0":
-  version "1.2.0"
-  resolved "https://registry.yarnpkg.com/@phosphor/disposable/-/disposable-1.2.0.tgz#878b9b5863f2026bbf2935eb600c7fdc97d0d026"
-  integrity sha512-4PoWoffdrLyWOW5Qv7I8//owvZmv57YhaxetAMWeJl13ThXc901RprL0Gxhtue2ZxL2PtUjM1207HndKo2FVjA==
+"@phosphor/datastore@0.7.2":
+  version "0.7.2"
+  resolved "https://registry.yarnpkg.com/@phosphor/datastore/-/datastore-0.7.2.tgz#749fe4c5a85c0cf752fd869f32a7987b20c96ac9"
+  integrity sha512-jHQaktrwsoBjKXlMtc70sB9uQxD53A8ifVA/65Xwnze74NtEe8ni8FTWBdo7Xul6WbTJUFrCutLWLAn3H+tDTQ==
   dependencies:
-    "@phosphor/algorithm" "^1.1.3"
-    "@phosphor/signaling" "^1.2.3"
+    "@phosphor/algorithm" "^1.2.0"
+    "@phosphor/collections" "^1.2.0"
+    "@phosphor/coreutils" "^1.3.1"
+    "@phosphor/disposable" "^1.3.0"
+    "@phosphor/messaging" "^1.3.0"
+    "@phosphor/signaling" "^1.3.0"
+
+"@phosphor/disposable@^1.2.0", "@phosphor/disposable@^1.3.0":
+  version "1.3.0"
+  resolved "https://registry.yarnpkg.com/@phosphor/disposable/-/disposable-1.3.0.tgz#3321a420e14acf0761a559f202bf98d4c46b8163"
+  integrity sha512-wHQov7HoS20mU6yuEz5ZMPhfxHdcxGovjPoid0QwccUEOm33UBkWlxaJGm9ONycezIX8je7ZuPOf/gf7JI6Dlg==
+  dependencies:
+    "@phosphor/algorithm" "^1.2.0"
+    "@phosphor/signaling" "^1.3.0"
 
 "@phosphor/domutils@^1.1.3":
   version "1.1.3"
@@ -1713,25 +1725,25 @@
   resolved "https://registry.yarnpkg.com/@phosphor/keyboard/-/keyboard-1.1.3.tgz#e5fd13af0479034ef0b5fffcf43ef2d4a266b5b6"
   integrity sha512-dzxC/PyHiD6mXaESRy6PZTd9JeK+diwG1pyngkyUf127IXOEzubTIbu52VSdpGBklszu33ws05BAGDa4oBE4mQ==
 
-"@phosphor/messaging@^1.2.3":
-  version "1.2.3"
-  resolved "https://registry.yarnpkg.com/@phosphor/messaging/-/messaging-1.2.3.tgz#860423261df8ac6c30344cc036b10b0e83d3c0db"
-  integrity sha512-89Ps4uSRNOEQoepB/0SDoyPpNUWd6VZnmbMetmeXZJHsuJ1GLxtnq3WBdl7UCVNsw3W9NC610pWaDCy/BafRlg==
+"@phosphor/messaging@^1.2.3", "@phosphor/messaging@^1.3.0":
+  version "1.3.0"
+  resolved "https://registry.yarnpkg.com/@phosphor/messaging/-/messaging-1.3.0.tgz#a140e6dd28a496260779acf74860f738c654c65e"
+  integrity sha512-k0JE+BTMKlkM335S2AmmJxoYYNRwOdW5jKBqLgjJdGRvUQkM0+2i60ahM45+J23atGJDv9esKUUBINiKHFhLew==
   dependencies:
-    "@phosphor/algorithm" "^1.1.3"
-    "@phosphor/collections" "^1.1.3"
+    "@phosphor/algorithm" "^1.2.0"
+    "@phosphor/collections" "^1.2.0"
 
 "@phosphor/properties@^1.1.3":
   version "1.1.3"
   resolved "https://registry.yarnpkg.com/@phosphor/properties/-/properties-1.1.3.tgz#63e4355be5e22a411c566fd1860207038f171598"
   integrity sha512-GiglqzU77s6+tFVt6zPq9uuyu/PLQPFcqZt914ZhJ4cN/7yNI/SLyMzpYZ56IRMXvzK9TUgbRna6URE3XAwFUg==
 
-"@phosphor/signaling@^1.2.3":
-  version "1.2.3"
-  resolved "https://registry.yarnpkg.com/@phosphor/signaling/-/signaling-1.2.3.tgz#2fde0ee810b0fab5f3fc765f81ed08ae671e76f1"
-  integrity sha512-DMwS0m9OgfY5ljpTsklRQPUQpTyg4obz85FyImRDacUVxUVbas95djIDEbU4s1TMzdHBBO+gfki3V4giXUvXzw==
+"@phosphor/signaling@^1.2.3", "@phosphor/signaling@^1.3.0":
+  version "1.3.0"
+  resolved "https://registry.yarnpkg.com/@phosphor/signaling/-/signaling-1.3.0.tgz#9de9904e07aaf6eb82074de29017c7c2bf1fd3df"
+  integrity sha512-ZbG2Mof4LGSkaEuDicqA2o2TKu3i5zanjr2GkevI/82aKBD7cI1NGLGT55HZwtE87/gOF4FIM3d3DeyrFDMjMQ==
   dependencies:
-    "@phosphor/algorithm" "^1.1.3"
+    "@phosphor/algorithm" "^1.2.0"
 
 "@phosphor/virtualdom@^1.1.3":
   version "1.1.3"
@@ -7380,7 +7392,7 @@ karma-ie-launcher@^1.0.0:
   resolved "https://registry.yarnpkg.com/karma-ie-launcher/-/karma-ie-launcher-1.0.0.tgz#497986842c490190346cd89f5494ca9830c6d59c"
   integrity sha1-SXmGhCxJAZA0bNifVJTKmDDG1Zw=
   dependencies:
-    lodash "^4.6.2"
+    lodash "^4.6.1"
 
 karma-mocha-reporter@^2.2.5:
   version "2.2.5"
@@ -7738,9 +7750,9 @@ lodash.isstring@^4.0.1:
   resolved "https://registry.yarnpkg.com/lodash.isstring/-/lodash.isstring-4.0.1.tgz#d527dfb5456eca7cc9bb95d5daeaf88ba54a5451"
   integrity sha1-1SfftUVuynzJu5XV2ur4i6VKVFE=
 
-lodash.mergewith@^4.6.2:
+lodash.mergewith@^4.6.1:
   version "4.6.2"
-  resolved "https://registry.npmjs.org/lodash.mergewith/-/lodash.mergewith-4.6.2.tgz#617121f89ac55f59047c7aec1ccd6654c6590f55"
+  resolved "https://registry.yarnpkg.com/lodash.mergewith/-/lodash.mergewith-4.6.2.tgz#617121f89ac55f59047c7aec1ccd6654c6590f55"
   integrity sha512-GK3g5RPZWTRSeLSpgP8Xhra+pnjBC56q9FZYe1d5RN3TJ35dbkGy3YqBSMbyCrlbi+CM9Z3Jk5yTL7RCsqboyQ==
 
 lodash.set@^4.3.2:
@@ -7773,10 +7785,10 @@ lodash.uniq@^4.5.0:
   resolved "https://registry.yarnpkg.com/lodash.uniq/-/lodash.uniq-4.5.0.tgz#d0225373aeb652adc1bc82e4945339a842754773"
   integrity sha1-0CJTc662Uq3BvILklFM5qEJ1R3M=
 
-lodash@^4.0.0, lodash@^4.17.0, lodash@^4.17.10, lodash@^4.17.11, lodash@^4.17.3, lodash@^4.17.4, lodash@^4.17.5, lodash@^4.2.1, lodash@^4.6.2:
-  version "4.17.11"
-  resolved "https://registry.yarnpkg.com/lodash/-/lodash-4.17.11.tgz#b39ea6229ef607ecd89e2c8df12536891cac9b8d"
-  integrity sha512-cQKh8igo5QUhZ7lg38DYWAxMvjSAKG0A8wGSVimP07SIUEK2UO+arSRKbRZWtelMtN5V0Hkwh5ryOto/SshYIg==
+lodash@^4.0.0, lodash@^4.17.0, lodash@^4.17.10, lodash@^4.17.11, lodash@^4.17.3, lodash@^4.17.4, lodash@^4.17.5, lodash@^4.2.1, lodash@^4.6.1:
+  version "4.17.15"
+  resolved "https://registry.yarnpkg.com/lodash/-/lodash-4.17.15.tgz#b447f6670a0455bbfeedd11392eff330ea097548"
+  integrity sha512-8xOcRHvCjnocdS5cpwXQXVzmmh5e5+saE2QGoeQmbKmRS6J3VQppPOIt0MnmE+4xlZoumy0GPG0D0MVIQbNA1A==
 
 log-symbols@2.2.0, log-symbols@^2.1.0, log-symbols@^2.2.0:
   version "2.2.0"
@@ -10291,7 +10303,7 @@ sanitize-html@~1.20.1:
     lodash.escaperegexp "^4.1.2"
     lodash.isplainobject "^4.0.6"
     lodash.isstring "^4.0.1"
-    lodash.mergewith "^4.6.2"
+    lodash.mergewith "^4.6.1"
     postcss "^7.0.5"
     srcset "^1.0.0"
     xtend "^4.0.1"
