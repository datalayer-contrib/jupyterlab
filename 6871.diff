
diff --git a/packages/codeeditor/src/editor.ts b/packages/codeeditor/src/editor.ts
index 5b9e48c3187..1a6d3d712a1 100644
--- a/packages/codeeditor/src/editor.ts
+++ b/packages/codeeditor/src/editor.ts
@@ -1,22 +1,17 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
+import { DatastoreExt } from '@jupyterlab/datastore';
+
 import { JSONObject } from '@lumino/coreutils';
 
+import { Datastore } from '@lumino/datastore';
+
 import { IDisposable } from '@lumino/disposable';
 
 import { ISignal, Signal } from '@lumino/signaling';
 
-import { IChangedArgs } from '@jupyterlab/coreutils';
-
-import {
-  IModelDB,
-  ModelDB,
-  IObservableValue,
-  ObservableValue,
-  IObservableMap,
-  IObservableString
-} from '@jupyterlab/observables';
+import { CodeEditorData, ICodeEditorData } from './data';
 
 /**
  * A namespace for code editors.
@@ -111,7 +106,7 @@ export namespace CodeEditor {
   export const defaultSelectionStyle: ISelectionStyle = {
     className: '',
     displayName: '',
-    color: 'black'
+    color: '#2196F3'
   };
 
   /**
@@ -170,15 +165,10 @@ export namespace CodeEditor {
    * An editor model.
    */
   export interface IModel extends IDisposable {
-    /**
-     * A signal emitted when a property changes.
-     */
-    mimeTypeChanged: ISignal<IModel, IChangedArgs<string>>;
-
     /**
      * The text stored in the model.
      */
-    readonly value: IObservableString;
+    value: string;
 
     /**
      * A mime type of the model.
@@ -191,13 +181,12 @@ export namespace CodeEditor {
     /**
      * The currently selected code.
      */
-    readonly selections: IObservableMap<ITextSelection[]>;
+    readonly selections: { [id: string]: ITextSelection[] };
 
     /**
-     * The underlying `IModelDB` instance in which model
-     * data is stored.
+     * The location in the datastore in which this codeeditor keeps its data.
      */
-    readonly modelDB: IModelDB;
+    readonly data: ICodeEditorData.DataLocation;
   }
 
   /**
@@ -210,61 +199,107 @@ export namespace CodeEditor {
     constructor(options?: Model.IOptions) {
       options = options || {};
 
-      if (options.modelDB) {
-        this.modelDB = options.modelDB;
+      if (options.data) {
+        this.data = options.data;
       } else {
-        this.modelDB = new ModelDB();
+        const datastore = (this._datastore = CodeEditorData.createStore());
+        this.data = {
+          datastore,
+          record: {
+            schema: CodeEditorData.SCHEMA,
+            record: 'data'
+          }
+        };
+      }
+      const { datastore, record } = this.data;
+      if (!DatastoreExt.getRecord(datastore, record)) {
+        this.isPrepopulated = false;
+        // Initialize the record if it hasn't been.
+        DatastoreExt.withTransaction(datastore, () => {
+          DatastoreExt.updateRecord(datastore, record, {
+            mimeType: options.mimeType || 'text/plain',
+            text: { index: 0, remove: 0, text: options.value || '' }
+          });
+        });
+      } else {
+        this.isPrepopulated = true;
+        // Possibly override any data existing in the record with options
+        // provided by the user.
+        if (options.value) {
+          this.value = options.value;
+        }
+        if (options.mimeType) {
+          this.mimeType = options.mimeType;
+        }
+        if (!this.mimeType) {
+          this.mimeType = 'text/plain';
+        }
       }
-
-      let value = this.modelDB.createString('value');
-      value.text = value.text || options.value || '';
-
-      let mimeType = this.modelDB.createValue('mimeType');
-      mimeType.set(options.mimeType || 'text/plain');
-      mimeType.changed.connect(this._onMimeTypeChanged, this);
-
-      this.modelDB.createMap('selections');
     }
 
     /**
-     * The underlying `IModelDB` instance in which model
-     * data is stored.
+     * The record in the datastore in which this codeeditor keeps its data.
      */
-    readonly modelDB: IModelDB;
+    readonly data: ICodeEditorData.DataLocation;
 
-    /**
-     * A signal emitted when a mimetype changes.
-     */
-    get mimeTypeChanged(): ISignal<this, IChangedArgs<string>> {
-      return this._mimeTypeChanged;
-    }
+    readonly isPrepopulated: boolean;
 
     /**
      * Get the value of the model.
      */
-    get value(): IObservableString {
-      return this.modelDB.get('value') as IObservableString;
+    get value(): string {
+      return DatastoreExt.getField(this.data.datastore, {
+        ...this.data.record,
+        field: 'text'
+      });
+    }
+    set value(value: string) {
+      const current = this.value;
+      DatastoreExt.withTransaction(this.data.datastore, () => {
+        DatastoreExt.updateField(
+          this.data.datastore,
+          { ...this.data.record, field: 'text' },
+          {
+            index: 0,
+            remove: current.length,
+            text: value
+          }
+        );
+      });
     }
 
     /**
      * Get the selections for the model.
      */
-    get selections(): IObservableMap<ITextSelection[]> {
-      return this.modelDB.get('selections') as IObservableMap<ITextSelection[]>;
+    get selections(): { [id: string]: ITextSelection[] } {
+      return DatastoreExt.getField(this.data.datastore, {
+        ...this.data.record,
+        field: 'selections'
+      });
     }
 
     /**
      * A mime type of the model.
      */
     get mimeType(): string {
-      return this.modelDB.getValue('mimeType') as string;
+      return DatastoreExt.getField(this.data.datastore, {
+        ...this.data.record,
+        field: 'mimeType'
+      });
     }
     set mimeType(newValue: string) {
       const oldValue = this.mimeType;
       if (oldValue === newValue) {
         return;
       }
-      this.modelDB.setValue('mimeType', newValue);
+      const { datastore, record } = this.data;
+      DatastoreExt.withTransaction(datastore, () => {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'mimeType' },
+          newValue
+        );
+      });
     }
 
     /**
@@ -281,24 +316,16 @@ export namespace CodeEditor {
       if (this._isDisposed) {
         return;
       }
+      if (this._datastore) {
+        this._datastore.dispose();
+        this._datastore = null;
+      }
       this._isDisposed = true;
-      this.value.text = '';
       Signal.clearData(this);
     }
 
-    private _onMimeTypeChanged(
-      mimeType: IObservableValue,
-      args: ObservableValue.IChangedArgs
-    ): void {
-      this._mimeTypeChanged.emit({
-        name: 'mimeType',
-        oldValue: args.oldValue as string,
-        newValue: args.newValue as string
-      });
-    }
-
     private _isDisposed = false;
-    private _mimeTypeChanged = new Signal<this, IChangedArgs<string>>(this);
+    private _datastore: Datastore | null = null;
   }
 
   /**
@@ -709,9 +736,9 @@ export namespace CodeEditor {
       mimeType?: string;
 
       /**
-       * An optional modelDB for storing model state.
+       * A location in an existing datastore in which to store the model.
        */
-      modelDB?: IModelDB;
+      data?: ICodeEditorData.DataLocation;
     }
   }
 }
diff --git a/packages/codeeditor/src/index.ts b/packages/codeeditor/src/index.ts
index e67c50c901c..59fbce1c70b 100644
--- a/packages/codeeditor/src/index.ts
+++ b/packages/codeeditor/src/index.ts
@@ -1,6 +1,7 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
+export * from './data';
 export * from './editor';
 export * from './jsoneditor';
 export * from './widget';
diff --git a/packages/codeeditor/src/jsoneditor.ts b/packages/codeeditor/src/jsoneditor.ts
index 8f34fe73c9b..b63ecb8aea1 100644
--- a/packages/codeeditor/src/jsoneditor.ts
+++ b/packages/codeeditor/src/jsoneditor.ts
@@ -1,9 +1,18 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { IObservableJSON } from '@jupyterlab/observables';
+import { DatastoreExt } from '@jupyterlab/datastore';
 
-import { JSONExt, JSONObject } from '@lumino/coreutils';
+import {
+  JSONExt,
+  JSONObject,
+  JSONValue,
+  ReadonlyJSONObject
+} from '@lumino/coreutils';
+
+import { Datastore, MapField, Schema } from '@lumino/datastore';
+
+import { IDisposable } from '@lumino/disposable';
 
 import { Message } from '@lumino/messaging';
 
@@ -44,7 +53,10 @@ const COMMIT_CLASS = 'jp-JSONEditor-commitButton';
 /**
  * A widget for editing observable JSON.
  */
-export class JSONEditor extends Widget {
+export class JSONEditor<
+  S extends Schema,
+  F extends keyof JSONEditor.MapFields<S>
+> extends Widget {
   /**
    * Construct a new JSON editor.
    */
@@ -75,9 +87,14 @@ export class JSONEditor extends Widget {
 
     let model = new CodeEditor.Model();
 
-    model.value.text = 'No data!';
+    model.value = 'No data!';
     model.mimeType = 'application/json';
-    model.value.changed.connect(this._onValueChanged, this);
+    DatastoreExt.listenField(
+      model.data.datastore,
+      { ...model.data.record, field: 'text' },
+      this._onValueChanged,
+      this
+    );
     this.model = model;
     this.editor = options.editorFactory({ host: this.editorHostNode, model });
     this.editor.setOption('readOnly', true);
@@ -116,20 +133,26 @@ export class JSONEditor extends Widget {
   /**
    * The observable source.
    */
-  get source(): IObservableJSON | null {
+  get source(): JSONEditor.DataLocation<S, F> | null {
     return this._source;
   }
-  set source(value: IObservableJSON | null) {
+  set source(value: JSONEditor.DataLocation<S, F> | null) {
     if (this._source === value) {
       return;
     }
-    if (this._source) {
-      this._source.changed.disconnect(this._onSourceChanged, this);
+    if (this._listener) {
+      this._listener.dispose();
+      this._listener = null;
     }
     this._source = value;
     this.editor.setOption('readOnly', value === null);
     if (value) {
-      value.changed.connect(this._onSourceChanged, this);
+      this._listener = DatastoreExt.listenField(
+        this._source.datastore,
+        this._source.field,
+        this._onSourceChanged,
+        this
+      );
     }
     this._setValue();
   }
@@ -204,11 +227,11 @@ export class JSONEditor extends Widget {
   }
 
   /**
-   * Handle a change to the metadata of the source.
+   * Handle a change to the JSON of the source.
    */
   private _onSourceChanged(
-    sender: IObservableJSON,
-    args: IObservableJSON.IChangedArgs
+    sender: Datastore,
+    args: MapField.Change<JSONValue>
   ) {
     if (this._changeGuard) {
       return;
@@ -226,7 +249,7 @@ export class JSONEditor extends Widget {
   private _onValueChanged(): void {
     let valid = true;
     try {
-      let value = JSON.parse(this.editor.model.value.text);
+      let value = JSON.parse(this.editor.model.value);
       this.removeClass(ERROR_CLASS);
       this._inputDirty =
         !this._changeGuard && !JSONExt.deepEqual(value, this._originalValue);
@@ -280,25 +303,29 @@ export class JSONEditor extends Widget {
   private _mergeContent(): void {
     let model = this.editor.model;
     let old = this._originalValue;
-    let user = JSON.parse(model.value.text) as JSONObject;
+    let user = JSON.parse(model.value) as JSONObject;
     let source = this.source;
     if (!source) {
       return;
     }
 
-    // If it is in user and has changed from old, set in new.
-    for (let key in user) {
-      if (!JSONExt.deepEqual(user[key], old[key] || null)) {
-        source.set(key, user[key]);
-      }
-    }
-
-    // If it was in old and is not in user, remove from source.
-    for (let key in old) {
+    let update: JSONObject = {};
+    Object.keys(old).forEach(key => {
+      // If it was in old and not in user, remove from the source.
       if (!(key in user)) {
-        source.delete(key);
+        update[key] = null;
       }
-    }
+    });
+    Object.keys(user).forEach(key => {
+      // If it is in user and has changed from old, set in new
+      if (!JSONExt.deepEqual(user[key], old[key] || null)) {
+        update[key] = user[key];
+      }
+    });
+    let { datastore, field } = this._source;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateField(datastore, field, update);
+    });
   }
 
   /**
@@ -311,14 +338,19 @@ export class JSONEditor extends Widget {
     this.commitButtonNode.hidden = true;
     this.removeClass(ERROR_CLASS);
     let model = this.editor.model;
-    let content = this._source ? this._source.toJSON() : {};
+    let content = this._source
+      ? (DatastoreExt.getField(
+          this._source.datastore,
+          this._source.field
+        ) as ReadonlyJSONObject)
+      : {};
     this._changeGuard = true;
     if (content === void 0) {
-      model.value.text = 'No data!';
+      model.value = 'No data!';
       this._originalValue = JSONExt.emptyObject;
     } else {
       let value = JSON.stringify(content, null, 4);
-      model.value.text = value;
+      model.value = value;
       this._originalValue = content;
       // Move the cursor to within the brace.
       if (value.length > 1 && value[0] === '{') {
@@ -333,9 +365,10 @@ export class JSONEditor extends Widget {
 
   private _dataDirty = false;
   private _inputDirty = false;
-  private _source: IObservableJSON | null = null;
-  private _originalValue = JSONExt.emptyObject;
+  private _source: JSONEditor.DataLocation<S, F> | null = null;
+  private _originalValue: ReadonlyJSONObject = JSONExt.emptyObject;
   private _changeGuard = false;
+  private _listener: IDisposable | null = null;
 }
 
 /**
@@ -351,4 +384,23 @@ export namespace JSONEditor {
      */
     editorFactory: CodeEditor.Factory;
   }
+
+  /**
+   * The subset of fields in a schema that represent a JSON Object.
+   */
+  export type MapFields<S extends Schema> = {
+    [F in keyof S['fields']]: S['fields'][F] extends MapField<JSONValue>
+      ? F
+      : never;
+  };
+
+  /**
+   * A field location referencing a JSON-able object.
+   */
+  export type DataLocation<
+    S extends Schema,
+    F extends keyof MapFields<S>
+  > = DatastoreExt.DataLocation & {
+    field: DatastoreExt.FieldLocation<S, F>;
+  };
 }
diff --git a/packages/codeeditor/src/widget.ts b/packages/codeeditor/src/widget.ts
index 270f1126db9..b0214c6863d 100644
--- a/packages/codeeditor/src/widget.ts
+++ b/packages/codeeditor/src/widget.ts
@@ -1,6 +1,8 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
+import { DatastoreExt } from '@jupyterlab/datastore';
+
 import { MimeData } from '@lumino/coreutils';
 
 import { IDragEvent } from '@lumino/dragdrop';
@@ -48,7 +50,12 @@ export class CodeEditorWrapper extends Widget {
       config: options.config,
       selectionStyle: options.selectionStyle
     }));
-    editor.model.selections.changed.connect(this._onSelectionsChanged, this);
+    DatastoreExt.listenField(
+      editor.model.data.datastore,
+      { ...editor.model.data.record, field: 'selections' },
+      this._onSelectionsChanged,
+      this
+    );
     this._updateOnShow = options.updateOnShow !== false;
   }
 
@@ -271,7 +278,13 @@ export class CodeEditorWrapper extends Widget {
     };
     const position = this.editor.getPositionForCoordinate(coordinate);
     const offset = this.editor.getOffsetAt(position);
-    this.model.value.insert(offset, data);
+    DatastoreExt.withTransaction(this.model.data.datastore, () => {
+      DatastoreExt.updateField(
+        this.model.data.datastore,
+        { ...this.model.data.record, field: 'text' },
+        { index: offset, remove: 0, text: data }
+      );
+    });
   }
 
   private _updateOnShow: boolean;

diff --git a/packages/codemirror-extension/src/index.ts b/packages/codemirror-extension/src/index.ts
index 16c0e1a5f3a..a30670acace 100644
--- a/packages/codemirror-extension/src/index.ts
+++ b/packages/codemirror-extension/src/index.ts
@@ -209,7 +209,8 @@ function activateEditorCommands(
   /**
    * Handle the settings of new widgets.
    */
-  tracker.widgetAdded.connect((sender, widget) => {
+  tracker.widgetAdded.connect(async (sender, widget) => {
+    await widget.context.ready;
     if (widget.content.editor instanceof CodeMirrorEditor) {
       let cm = widget.content.editor.editor;
       cm.setOption('keyMap', keyMap);

diff --git a/packages/codemirror/src/editor.ts b/packages/codemirror/src/editor.ts
index d68ff9601f0..204ac6e6b06 100644
--- a/packages/codemirror/src/editor.ts
+++ b/packages/codemirror/src/editor.ts
@@ -17,15 +17,15 @@ import { showDialog } from '@jupyterlab/apputils';
 
 import { Poll } from '@jupyterlab/coreutils';
 
+import { DatastoreExt } from '@jupyterlab/datastore';
+
 import { CodeEditor } from '@jupyterlab/codeeditor';
 
 import { UUID } from '@lumino/coreutils';
 
-import {
-  IObservableMap,
-  IObservableString,
-  ICollaborator
-} from '@jupyterlab/observables';
+import { Datastore, MapField, TextField } from '@lumino/datastore';
+
+import { ICollaborator } from '@jupyterlab/observables';
 
 import { Mode } from './mode';
 
@@ -121,7 +121,7 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
     let doc = editor.getDoc();
 
     // Handle initial values for text, mimetype, and selections.
-    doc.setValue(model.value.text);
+    doc.setValue(model.value);
     this.clearHistory();
     this._onMimeTypeChanged();
     this._onCursorActivity();
@@ -137,9 +137,25 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
     });
 
     // Connect to changes.
-    model.value.changed.connect(this._onValueChanged, this);
-    model.mimeTypeChanged.connect(this._onMimeTypeChanged, this);
-    model.selections.changed.connect(this._onSelectionsChanged, this);
+    let { record, datastore } = model.data;
+    DatastoreExt.listenField(
+      datastore,
+      { ...record, field: 'text' },
+      this._onValueChanged,
+      this
+    );
+    DatastoreExt.listenField(
+      datastore,
+      { ...record, field: 'mimeType' },
+      this._onMimeTypeChanged,
+      this
+    );
+    DatastoreExt.listenField(
+      datastore,
+      { ...record, field: 'selections' },
+      this._onSelectionsChanged,
+      this
+    );
 
     CodeMirror.on(editor, 'keydown', (editor: CodeMirror.Editor, event) => {
       let index = ArrayExt.findFirstIndex(this._keydownHandlers, handler => {
@@ -532,7 +548,14 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
     // will get screened out in _onCursorsChanged(). Make an
     // exception for this method.
     if (!this.editor.hasFocus()) {
-      this.model.selections.set(this.uuid, this.getSelections());
+      const { datastore, record } = this.model.data;
+      DatastoreExt.withTransaction(datastore, () => {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'selections' },
+          { [this.uuid]: this.getSelections() }
+        );
+      });
     }
   }
 
@@ -694,16 +717,17 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
    * Handles a selections change.
    */
   private _onSelectionsChanged(
-    selections: IObservableMap<CodeEditor.ITextSelection[]>,
-    args: IObservableMap.IChangedArgs<CodeEditor.ITextSelection[]>
+    sender: Datastore,
+    args: MapField.Change<CodeEditor.ITextSelection[]>
   ): void {
-    const uuid = args.key;
-    if (uuid !== this.uuid) {
-      this._cleanSelections(uuid);
-      if (args.type !== 'remove' && args.newValue) {
-        this._markSelections(uuid, args.newValue);
+    Object.keys(args.current).forEach(uuid => {
+      if (uuid !== this.uuid) {
+        this._cleanSelections(uuid);
+        if (args.current[uuid] !== null && args.current[uuid]) {
+          this._markSelections(uuid, args.current[uuid]);
+        }
       }
-    }
+    });
   }
 
   /**
@@ -736,9 +760,7 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
     // If we can id the selection to a specific collaborator,
     // use that information.
     let collaborator: ICollaborator | undefined;
-    if (this._model.modelDB.collaborators) {
-      collaborator = this._model.modelDB.collaborators.get(uuid);
-    }
+    // TODO: figure out who our collaborators are so we can show it.
 
     // Style each selection for the uuid.
     selections.forEach(selection => {
@@ -768,7 +790,7 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
           markerOptions = this._toTextMarkerOptions(selection.style);
         }
         markers.push(this.doc.markText(anchor, head, markerOptions));
-      } else if (collaborator) {
+      } else {
         let caret = this._getCaret(collaborator);
         markers.push(
           this.doc.setBookmark(this._toCodeMirrorPosition(selection.end), {
@@ -787,8 +809,14 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
     // Only add selections if the editor has focus. This avoids unwanted
     // triggering of cursor activity due to collaborator actions.
     if (this._editor.hasFocus()) {
-      const selections = this.getSelections();
-      this.model.selections.set(this.uuid, selections);
+      const { datastore, record } = this.model.data;
+      DatastoreExt.withTransaction(datastore, () => {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'selections' },
+          { [this.uuid]: this.getSelections() }
+        );
+      });
     }
   }
 
@@ -858,38 +886,24 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
   /**
    * Handle model value changes.
    */
-  private _onValueChanged(
-    value: IObservableString,
-    args: IObservableString.IChangedArgs
-  ): void {
+  private _onValueChanged(sender: Datastore, changes: TextField.Change): void {
+    // Ignore changes that have already been applied locally.
     if (this._changeGuard) {
       return;
     }
-    this._changeGuard = true;
-    let doc = this.doc;
-    switch (args.type) {
-      case 'insert':
-        let pos = doc.posFromIndex(args.start);
-        // Replace the range, including a '+input' orign,
-        // which indicates that CodeMirror may merge changes
-        // for undo/redo purposes.
-        doc.replaceRange(args.value, pos, pos, '+input');
-        break;
-      case 'remove':
-        let from = doc.posFromIndex(args.start);
-        let to = doc.posFromIndex(args.end);
-        // Replace the range, including a '+input' orign,
-        // which indicates that CodeMirror may merge changes
-        // for undo/redo purposes.
-        doc.replaceRange('', from, to, '+input');
-        break;
-      case 'set':
-        doc.setValue(args.value);
-        break;
-      default:
-        break;
-    }
-    this._changeGuard = false;
+    const doc = this.doc;
+    changes.forEach(tc => {
+      // Convert the change data to codemirror range and inserted text.
+      const from = doc.posFromIndex(tc.index);
+      const to = doc.posFromIndex(tc.index + tc.removed.length);
+      const replacement = tc.inserted;
+
+      // Apply the operation, setting the change guard so we can ignore
+      // the change signals from codemirror.
+      this._changeGuard = true;
+      doc.replaceRange(replacement, from, to, '+input');
+      this._changeGuard = false;
+    });
   }
 
   /**
@@ -902,18 +916,19 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
     if (this._changeGuard) {
       return;
     }
+    const start = doc.indexFromPos(change.from);
+    const end = doc.indexFromPos(change.to);
+    const text = change.text.join('\n');
+    // If this was a local change, update the table.
     this._changeGuard = true;
-    let value = this._model.value;
-    let start = doc.indexFromPos(change.from);
-    let end = doc.indexFromPos(change.to);
-    let inserted = change.text.join('\n');
-
-    if (end !== start) {
-      value.remove(start, end);
-    }
-    if (inserted) {
-      value.insert(start, inserted);
-    }
+    const { datastore, record } = this.model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'text' },
+        { index: start, remove: end - start, text }
+      );
+    });
     this._changeGuard = false;
   }
 
@@ -990,7 +1005,7 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
    * Construct a caret element representing the position
    * of a collaborator's cursor.
    */
-  private _getCaret(collaborator: ICollaborator): HTMLElement {
+  private _getCaret(collaborator?: ICollaborator): HTMLElement {
     let name = collaborator ? collaborator.displayName : 'Anonymous';
     let color = collaborator ? collaborator.color : this._selectionStyle.color;
     let caret: HTMLElement = document.createElement('span');
@@ -998,7 +1013,7 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
     caret.style.borderBottomColor = color;
     caret.onmouseenter = () => {
       this._clearHover();
-      this._hoverId = collaborator.sessionId;
+      this._hoverId = collaborator ? collaborator.sessionId : UUID.uuid4();
       let rect = caret.getBoundingClientRect();
       // Construct and place the hover box.
       let hover = document.createElement('div');
@@ -1039,7 +1054,7 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
     this._lastChange = null;
     let editor = this._editor;
     let doc = editor.getDoc();
-    if (doc.getValue() === this._model.value.text) {
+    if (doc.getValue() === this._model.value) {
       return;
     }
 
@@ -1053,7 +1068,7 @@ export class CodeMirrorEditor implements CodeEditor.IEditor {
     );
     console.log(
       JSON.stringify({
-        model: this._model.value.text,
+        model: this._model.value,
         view: doc.getValue(),
         selections: this.getSelections(),
         cursor: this.getCursorPosition(),
diff --git a/packages/codemirror/src/syntaxstatus.tsx b/packages/codemirror/src/syntaxstatus.tsx
index 888747cfb40..02032ae1652 100644
--- a/packages/codemirror/src/syntaxstatus.tsx
+++ b/packages/codemirror/src/syntaxstatus.tsx
@@ -4,7 +4,7 @@ import { VDomRenderer, VDomModel } from '@jupyterlab/apputils';
 
 import { CodeEditor } from '@jupyterlab/codeeditor';
 
-import { IChangedArgs } from '@jupyterlab/coreutils';
+import { DatastoreExt } from '@jupyterlab/datastore';
 
 import {
   interactiveItem,
@@ -19,6 +19,10 @@ import { CommandRegistry } from '@lumino/commands';
 
 import { JSONObject } from '@lumino/coreutils';
 
+import { Datastore, RegisterField } from '@lumino/datastore';
+
+import { IDisposable } from '@lumino/disposable';
+
 import { Menu } from '@lumino/widgets';
 
 /**
@@ -150,9 +154,9 @@ export namespace EditorSyntaxStatus {
       return this._editor;
     }
     set editor(editor: CodeEditor.IEditor | null) {
-      const oldEditor = this._editor;
-      if (oldEditor !== null) {
-        oldEditor.model.mimeTypeChanged.disconnect(this._onMIMETypeChange);
+      if (this._mimeTypeListener) {
+        this._mimeTypeListener.dispose();
+        this._mimeTypeListener = null;
       }
       const oldMode = this._mode;
       this._editor = editor;
@@ -162,7 +166,11 @@ export namespace EditorSyntaxStatus {
         const spec = Mode.findByMIME(this._editor.model.mimeType);
         this._mode = spec.name || spec.mode;
 
-        this._editor.model.mimeTypeChanged.connect(this._onMIMETypeChange);
+        DatastoreExt.listenField(
+          editor.model.data.datastore,
+          { ...editor.model.data.record, field: 'mimeType' },
+          this._onMIMETypeChange
+        );
       }
 
       this._triggerChange(oldMode, this._mode);
@@ -172,11 +180,11 @@ export namespace EditorSyntaxStatus {
      * If the editor mode changes, update the model.
      */
     private _onMIMETypeChange = (
-      mode: CodeEditor.IModel,
-      change: IChangedArgs<string>
+      sender: Datastore,
+      change: RegisterField.Change<string>
     ) => {
       const oldMode = this._mode;
-      const spec = Mode.findByMIME(change.newValue);
+      const spec = Mode.findByMIME(change.current);
       this._mode = spec.name || spec.mode;
 
       this._triggerChange(oldMode, this._mode);
@@ -193,6 +201,7 @@ export namespace EditorSyntaxStatus {
 
     private _mode: string = '';
     private _editor: CodeEditor.IEditor | null = null;
+    private _mimeTypeListener: IDisposable;
   }
 
   /**
diff --git a/packages/completer-extension/src/index.ts b/packages/completer-extension/src/index.ts
index f29b4b41c13..0328202ba28 100644
--- a/packages/completer-extension/src/index.ts
+++ b/packages/completer-extension/src/index.ts
@@ -216,7 +216,7 @@ const notebooks: JupyterFrontEndPlugin<void> = {
     app.commands.addCommand(CommandIDs.invokeNotebook, {
       execute: () => {
         const panel = notebooks.currentWidget;
-        if (panel && panel.content.activeCell.model.type === 'code') {
+        if (panel && panel.content.activeCell.type === 'code') {
           return app.commands.execute(CommandIDs.invoke, { id: panel.id });
         }
       }
@@ -261,9 +261,9 @@ const files: JupyterFrontEndPlugin<void> = {
     } = {};
 
     // When a new file editor is created, make the completer for it.
-    editorTracker.widgetAdded.connect((sender, widget) => {
+    editorTracker.widgetAdded.connect(async (sender, widget) => {
       const sessions = app.serviceManager.sessions;
-      const editor = widget.content.editor;
+      const editor = await widget.content.editor;
       const contextConnector = new ContextConnector({ editor });
 
       // When the list of running sessions changes,
diff --git a/packages/completer/src/handler.ts b/packages/completer/src/handler.ts
index 4e783d85072..83ca71007fe 100644
--- a/packages/completer/src/handler.ts
+++ b/packages/completer/src/handler.ts
@@ -5,6 +5,8 @@ import { CodeEditor } from '@jupyterlab/codeeditor';
 
 import { IDataConnector, Text } from '@jupyterlab/coreutils';
 
+import { DatastoreExt } from '@jupyterlab/datastore';
+
 import { ReadonlyJSONObject, JSONObject, JSONArray } from '@lumino/coreutils';
 
 import { IDisposable } from '@lumino/disposable';
@@ -84,12 +86,16 @@ export class CompletionHandler implements IDisposable {
 
     // Clean up and disconnect from old editor.
     if (editor && !editor.isDisposed) {
-      const model = editor.model;
-
       editor.host.classList.remove(COMPLETER_ENABLED_CLASS);
       editor.host.classList.remove(COMPLETER_ACTIVE_CLASS);
-      model.selections.changed.disconnect(this.onSelectionsChanged, this);
-      model.value.changed.disconnect(this.onTextChanged, this);
+      if (this._selectionListener) {
+        this._selectionListener.dispose();
+        this._selectionListener = null;
+      }
+      if (this._textListener) {
+        this._textListener.dispose();
+        this._textListener = null;
+      }
     }
 
     // Reset completer state.
@@ -99,11 +105,21 @@ export class CompletionHandler implements IDisposable {
     // Update the editor and signal connections.
     editor = this._editor = newValue;
     if (editor) {
-      const model = editor.model;
+      const { datastore, record } = editor.model.data;
 
       this._enabled = false;
-      model.selections.changed.connect(this.onSelectionsChanged, this);
-      model.value.changed.connect(this.onTextChanged, this);
+      this._textListener = DatastoreExt.listenField(
+        datastore,
+        { ...record, field: 'text' },
+        this.onTextChanged,
+        this
+      );
+      this._selectionListener = DatastoreExt.listenField(
+        datastore,
+        { ...record, field: 'selections' },
+        this.onSelectionsChanged,
+        this
+      );
       // On initial load, manually check the cursor position.
       this.onSelectionsChanged();
     }
@@ -155,7 +171,7 @@ export class CompletionHandler implements IDisposable {
     position: CodeEditor.IPosition
   ): Completer.ITextState {
     return {
-      text: editor.model.value.text,
+      text: editor.model.value,
       lineHeight: editor.lineHeight,
       charWidth: editor.charWidth,
       line: position.line,
@@ -180,8 +196,14 @@ export class CompletionHandler implements IDisposable {
     }
 
     const { start, end, value } = patch;
-    editor.model.value.remove(start, end);
-    editor.model.value.insert(start, value);
+    const { datastore, record } = editor.model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'text' },
+        { index: start, remove: end - start, text: value }
+      );
+    });
   }
 
   /**
@@ -341,7 +363,7 @@ export class CompletionHandler implements IDisposable {
       return Promise.reject(new Error('No active editor'));
     }
 
-    const text = editor.model.value.text;
+    const text = editor.model.value;
     const offset = Text.jsIndexToCharIndex(editor.getOffsetAt(position), text);
     const pending = ++this._pending;
     const state = this.getState(editor, position);
@@ -445,6 +467,8 @@ export class CompletionHandler implements IDisposable {
   private _enabled = false;
   private _pending = 0;
   private _isDisposed = false;
+  private _textListener: IDisposable | null = null;
+  private _selectionListener: IDisposable | null = null;
 }
 
 /**
diff --git a/packages/console/src/foreign.ts b/packages/console/src/foreign.ts
index 1b746cb308e..d891d2ee618 100644
--- a/packages/console/src/foreign.ts
+++ b/packages/console/src/foreign.ts
@@ -7,6 +7,10 @@ import { CodeCell } from '@jupyterlab/cells';
 
 import { nbformat } from '@jupyterlab/coreutils';
 
+import { DatastoreExt } from '@jupyterlab/datastore';
+
+import { OutputAreaData } from '@jupyterlab/outputarea';
+
 import { KernelMessage } from '@jupyterlab/services';
 
 import { IDisposable } from '@lumino/disposable';
@@ -102,10 +106,18 @@ export class ForeignHandler implements IDisposable {
       case 'execute_input':
         let inputMsg = msg as KernelMessage.IExecuteInputMsg;
         cell = this._newCell(parentMsgId);
-        let model = cell.model;
-        model.executionCount = inputMsg.content.execution_count;
-        model.value.text = inputMsg.content.code;
-        model.trusted = true;
+        const { datastore, record } = cell.data;
+        DatastoreExt.withTransaction(datastore, () => {
+          DatastoreExt.updateRecord(datastore, record, {
+            executionCount: inputMsg.content.execution_count,
+            text: {
+              index: 0,
+              remove: cell.editor.model.value.length,
+              text: inputMsg.content.code
+            },
+            trusted: true
+          });
+        });
         parent.update();
         return true;
       case 'execute_result':
@@ -118,14 +130,23 @@ export class ForeignHandler implements IDisposable {
         }
         let output = msg.content as nbformat.IOutput;
         output.output_type = msgType as nbformat.OutputType;
-        cell.model.outputs.add(output);
+        if (this._clearNext) {
+          OutputAreaData.clear(cell.data);
+          this._clearNext = false;
+        } else {
+          OutputAreaData.appendItem(cell.data, output);
+        }
         parent.update();
         return true;
       case 'clear_output':
         let wait = (msg as KernelMessage.IClearOutputMsg).content.wait;
-        cell = this._parent.getCell(parentMsgId);
-        if (cell) {
-          cell.model.outputs.clear(wait);
+        if (wait) {
+          this._clearNext = true;
+        } else {
+          cell = this._parent.getCell(parentMsgId);
+          if (cell) {
+            OutputAreaData.clear(cell.data);
+          }
         }
         return true;
       default:
@@ -146,6 +167,7 @@ export class ForeignHandler implements IDisposable {
   private _enabled = false;
   private _parent: ForeignHandler.IReceiver;
   private _isDisposed = false;
+  private _clearNext = false;
 }
 
 /**
diff --git a/packages/console/src/history.ts b/packages/console/src/history.ts
index 39001027026..ad523a5b488 100644
--- a/packages/console/src/history.ts
+++ b/packages/console/src/history.ts
@@ -1,16 +1,18 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
+import { IClientSession } from '@jupyterlab/apputils';
+
+import { CodeEditor } from '@jupyterlab/codeeditor';
+
+import { DatastoreExt } from '@jupyterlab/datastore';
+
 import { KernelMessage } from '@jupyterlab/services';
 
 import { IDisposable } from '@lumino/disposable';
 
 import { Signal } from '@lumino/signaling';
 
-import { IClientSession } from '@jupyterlab/apputils';
-
-import { CodeEditor } from '@jupyterlab/codeeditor';
-
 /**
  * The definition of a console history manager object.
  */
@@ -99,17 +101,24 @@ export class ConsoleHistory implements IConsoleHistory {
       return;
     }
 
-    let prev = this._editor;
-    if (prev) {
-      prev.edgeRequested.disconnect(this.onEdgeRequest, this);
-      prev.model.value.changed.disconnect(this.onTextChange, this);
+    if (this._editor) {
+      this._editor.edgeRequested.disconnect(this.onEdgeRequest, this);
+    }
+    if (this._listener) {
+      this._listener.dispose();
+      this._listener = null;
     }
 
     this._editor = value;
 
     if (value) {
       value.edgeRequested.connect(this.onEdgeRequest, this);
-      value.model.value.changed.connect(this.onTextChange, this);
+      this._listener = DatastoreExt.listenField(
+        value.model.data.datastore,
+        { ...value.model.data.record, field: 'text' },
+        this.onTextChange,
+        this
+      );
     }
   }
 
@@ -255,18 +264,18 @@ export class ConsoleHistory implements IConsoleHistory {
     location: CodeEditor.EdgeLocation
   ): void {
     let model = editor.model;
-    let source = model.value.text;
+    let source = model.value;
 
     if (location === 'top' || location === 'topLine') {
       void this.back(source).then(value => {
         if (this.isDisposed || !value) {
           return;
         }
-        if (model.value.text === value) {
+        if (model.value === value) {
           return;
         }
         this._setByHistory = true;
-        model.value.text = value;
+        model.value = value;
         let columnPos = 0;
         columnPos = value.indexOf('\n');
         if (columnPos < 0) {
@@ -280,11 +289,11 @@ export class ConsoleHistory implements IConsoleHistory {
           return;
         }
         let text = value || this.placeholder;
-        if (model.value.text === text) {
+        if (model.value === text) {
           return;
         }
         this._setByHistory = true;
-        model.value.text = text;
+        model.value = text;
         let pos = editor.getPositionAt(text.length);
         if (pos) {
           editor.setCursorPosition(pos);
@@ -340,6 +349,7 @@ export class ConsoleHistory implements IConsoleHistory {
   private _setByHistory = false;
   private _isDisposed = false;
   private _editor: CodeEditor.IEditor | null = null;
+  private _listener: IDisposable = null;
   private _filtered: string[] = [];
 }
 
diff --git a/packages/console/src/panel.ts b/packages/console/src/panel.ts
index a3e8f34fc72..d00dae7d884 100644
--- a/packages/console/src/panel.ts
+++ b/packages/console/src/panel.ts
@@ -48,8 +48,7 @@ export class ConsolePanel extends Panel {
       path,
       basePath,
       name,
-      manager,
-      modelFactory
+      manager
     } = options;
     let contentFactory = (this.contentFactory =
       options.contentFactory || ConsolePanel.defaultContentFactory);
@@ -77,8 +76,7 @@ export class ConsolePanel extends Panel {
       rendermime,
       session,
       mimeTypeService,
-      contentFactory,
-      modelFactory
+      contentFactory
     });
     this.addWidget(this.console);
 
@@ -204,11 +202,6 @@ export namespace ConsolePanel {
      */
     kernelPreference?: IClientSession.IKernelPreference;
 
-    /**
-     * The model factory for the console widget.
-     */
-    modelFactory?: CodeConsole.IModelFactory;
-
     /**
      * The service used to look up mime types.
      */
diff --git a/packages/console/src/widget.ts b/packages/console/src/widget.ts
index f3d61071107..94c6d7e0438 100644
--- a/packages/console/src/widget.ts
+++ b/packages/console/src/widget.ts
@@ -6,20 +6,17 @@ import { IClientSession } from '@jupyterlab/apputils';
 import {
   Cell,
   CellDragUtils,
-  CellModel,
   CodeCell,
-  CodeCellModel,
-  ICodeCellModel,
-  isCodeCellModel,
-  IRawCellModel,
-  RawCell,
-  RawCellModel
+  CodeCellData,
+  RawCell
 } from '@jupyterlab/cells';
 
 import { IEditorMimeTypeService, CodeEditor } from '@jupyterlab/codeeditor';
 
 import { nbformat } from '@jupyterlab/coreutils';
 
+import { DatastoreExt } from '@jupyterlab/datastore';
+
 import { IObservableList, ObservableList } from '@jupyterlab/observables';
 
 import { IRenderMimeRegistry } from '@jupyterlab/rendermime';
@@ -116,7 +113,6 @@ export class CodeConsole extends Widget {
 
     this.contentFactory =
       options.contentFactory || CodeConsole.defaultContentFactory;
-    this.modelFactory = options.modelFactory || CodeConsole.defaultModelFactory;
     this.rendermime = options.rendermime;
     this.session = options.session;
     this._mimeTypeService = options.mimeTypeService;
@@ -157,11 +153,6 @@ export class CodeConsole extends Widget {
    */
   readonly contentFactory: CodeConsole.IContentFactory;
 
-  /**
-   * The model factory for the console widget.
-   */
-  readonly modelFactory: CodeConsole.IModelFactory;
-
   /**
    * The rendermime instance used by the console.
    */
@@ -227,12 +218,10 @@ export class CodeConsole extends Widget {
       cell.disposed.connect(this._onCellDisposed, this);
     }
     // Create the banner.
-    let model = this.modelFactory.createRawCell({});
-    model.value.text = '...';
     let banner = (this._banner = new RawCell({
-      model,
       contentFactory: this.contentFactory
-    })).initializeState();
+    }));
+    banner.editor.model.value = '...';
     banner.addClass(BANNER_CLASS);
     banner.readOnly = true;
     this._content.addWidget(banner);
@@ -257,7 +246,7 @@ export class CodeConsole extends Widget {
     let options = this._createCodeCellOptions();
     let cell = factory.createCodeCell(options);
     cell.readOnly = true;
-    cell.model.mimeType = this._mimetype;
+    cell.editor.model.mimeType = this._mimetype;
     return cell;
   }
 
@@ -296,7 +285,14 @@ export class CodeConsole extends Widget {
     if (!promptCell) {
       return Promise.reject('Cannot execute without a prompt cell');
     }
-    promptCell.model.trusted = true;
+    const { datastore, record } = promptCell.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'trusted' },
+        true
+      );
+    });
 
     if (force) {
       // Create a new prompt cell before kernel execution to allow typeahead.
@@ -339,10 +335,13 @@ export class CodeConsole extends Widget {
    */
   inject(code: string, metadata: JSONObject = {}): Promise<void> {
     let cell = this.createCodeCell();
-    cell.model.value.text = code;
-    for (let key of Object.keys(metadata)) {
-      cell.model.metadata.set(key, metadata[key]);
-    }
+    const { datastore, record } = cell.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateRecord(datastore, record, {
+        text: { index: 0, remove: 0, text: code },
+        metadata
+      });
+    });
     this.addCell(cell);
     return this._execute(cell);
   }
@@ -368,14 +367,13 @@ export class CodeConsole extends Widget {
   serialize(): nbformat.ICodeCell[] {
     const cells: nbformat.ICodeCell[] = [];
     each(this._cells, cell => {
-      let model = cell.model;
-      if (isCodeCellModel(model)) {
-        cells.push(model.toJSON());
+      if (cell.type === 'code') {
+        CodeCellData.toJSON(cell.data);
       }
     });
 
     if (this.promptCell) {
-      cells.push(this.promptCell.model.toJSON());
+      cells.push(CodeCellData.toJSON(this.promptCell.data));
     }
     return cells;
   }
@@ -463,8 +461,9 @@ export class CodeConsole extends Widget {
     clientX: number,
     clientY: number
   ): Promise<void> {
-    const cellModel = this._focusedCell.model as ICodeCellModel;
-    let selected: nbformat.ICell[] = [cellModel.toJSON()];
+    let selected: nbformat.ICell[] = [
+      CodeCellData.toJSON(this._focusedCell.data)
+    ];
 
     const dragImage = CellDragUtils.createCellDragImage(
       this._focusedCell,
@@ -480,7 +479,7 @@ export class CodeConsole extends Widget {
     });
 
     this._drag.mimeData.setData(JUPYTER_CELL_MIME, selected);
-    const textContent = cellModel.value.text;
+    const textContent = this._focusedCell.editor.model.value;
     this._drag.mimeData.setData('text/plain', textContent);
 
     this._focusedCell = null;
@@ -583,7 +582,7 @@ export class CodeConsole extends Widget {
     let factory = this.contentFactory;
     let options = this._createCodeCellOptions();
     promptCell = factory.createCodeCell(options);
-    promptCell.model.mimeType = this._mimetype;
+    promptCell.editor.model.mimeType = this._mimetype;
     promptCell.addClass(PROMPT_CLASS);
     this._input.addWidget(promptCell);
 
@@ -632,7 +631,7 @@ export class CodeConsole extends Widget {
    * Execute the code in the current prompt cell.
    */
   private _execute(cell: CodeCell): Promise<void> {
-    let source = cell.model.value.text;
+    let source = cell.editor.model.value;
     this._history.push(source);
     // If the source of the console is just "clear", clear the console as we
     // do in IPython or QtConsole.
@@ -640,7 +639,13 @@ export class CodeConsole extends Widget {
       this.clear();
       return Promise.resolve(void 0);
     }
-    cell.model.contentChanged.connect(this.update, this);
+    const { datastore, record } = cell.data;
+    const listener = DatastoreExt.listenRecord(
+      datastore,
+      record,
+      this.update,
+      this
+    );
     let onSuccess = (value: KernelMessage.IExecuteReplyMsg) => {
       if (this.isDisposed) {
         return;
@@ -655,17 +660,21 @@ export class CodeConsole extends Widget {
           if (setNextInput) {
             let text = (setNextInput as any).text;
             // Ignore the `replace` value and always set the next cell.
-            cell.model.value.text = text;
+            cell.editor.model.value = text;
           }
         }
       } else if (value && value.content.status === 'error') {
         each(this._cells, (cell: CodeCell) => {
-          if (cell.model.executionCount === null) {
+          const executionCount = DatastoreExt.getField(cell.data.datastore, {
+            ...cell.data.record,
+            field: 'executionCount'
+          });
+          if (executionCount === null) {
             cell.setPrompt('');
           }
         });
       }
-      cell.model.contentChanged.disconnect(this.update, this);
+      listener.dispose();
       this.update();
       this._executed.emit(new Date());
     };
@@ -673,7 +682,7 @@ export class CodeConsole extends Widget {
       if (this.isDisposed) {
         return;
       }
-      cell.model.contentChanged.disconnect(this.update, this);
+      listener.dispose();
       this.update();
     };
     return CodeCell.execute(cell, this.session).then(onSuccess, onFailure);
@@ -684,14 +693,14 @@ export class CodeConsole extends Widget {
    */
   private _handleInfo(info: KernelMessage.IInfoReplyMsg['content']): void {
     if (info.status !== 'ok') {
-      this._banner.model.value.text = 'Error in getting kernel banner';
+      this._banner.editor.model.value = 'Error in getting kernel banner';
       return;
     }
-    this._banner.model.value.text = info.banner;
+    this._banner.editor.model.value = info.banner;
     let lang = info.language_info as nbformat.ILanguageInfoMetadata;
     this._mimetype = this._mimeTypeService.getMimeTypeByLanguage(lang);
     if (this.promptCell) {
-      this.promptCell.model.mimeType = this._mimetype;
+      this.promptCell.editor.model.mimeType = this._mimetype;
     }
   }
 
@@ -700,10 +709,8 @@ export class CodeConsole extends Widget {
    */
   private _createCodeCellOptions(): CodeCell.IOptions {
     let contentFactory = this.contentFactory;
-    let modelFactory = this.modelFactory;
-    let model = modelFactory.createCodeCell({});
     let rendermime = this.rendermime;
-    return { model, rendermime, contentFactory };
+    return { rendermime, contentFactory };
   }
 
   /**
@@ -728,8 +735,7 @@ export class CodeConsole extends Widget {
     if (!promptCell) {
       return Promise.resolve(false);
     }
-    let model = promptCell.model;
-    let code = model.value.text;
+    let code = promptCell.editor.model.value;
     return new Promise<boolean>((resolve, reject) => {
       let timer = setTimeout(() => {
         resolve(true);
@@ -833,11 +839,6 @@ export namespace CodeConsole {
      */
     contentFactory: IContentFactory;
 
-    /**
-     * The model factory for the console widget.
-     */
-    modelFactory?: IModelFactory;
-
     /**
      * The mime renderer for the console widget.
      */
@@ -917,98 +918,6 @@ export namespace CodeConsole {
    * A default content factory for the code console.
    */
   export const defaultContentFactory: IContentFactory = new ContentFactory();
-
-  /**
-   * A model factory for a console widget.
-   */
-  export interface IModelFactory {
-    /**
-     * The factory for code cell content.
-     */
-    readonly codeCellContentFactory: CodeCellModel.IContentFactory;
-
-    /**
-     * Create a new code cell.
-     *
-     * @param options - The options used to create the cell.
-     *
-     * @returns A new code cell. If a source cell is provided, the
-     *   new cell will be initialized with the data from the source.
-     */
-    createCodeCell(options: CodeCellModel.IOptions): ICodeCellModel;
-
-    /**
-     * Create a new raw cell.
-     *
-     * @param options - The options used to create the cell.
-     *
-     * @returns A new raw cell. If a source cell is provided, the
-     *   new cell will be initialized with the data from the source.
-     */
-    createRawCell(options: CellModel.IOptions): IRawCellModel;
-  }
-
-  /**
-   * The default implementation of an `IModelFactory`.
-   */
-  export class ModelFactory {
-    /**
-     * Create a new cell model factory.
-     */
-    constructor(options: IModelFactoryOptions = {}) {
-      this.codeCellContentFactory =
-        options.codeCellContentFactory || CodeCellModel.defaultContentFactory;
-    }
-
-    /**
-     * The factory for output area models.
-     */
-    readonly codeCellContentFactory: CodeCellModel.IContentFactory;
-
-    /**
-     * Create a new code cell.
-     *
-     * @param source - The data to use for the original source data.
-     *
-     * @returns A new code cell. If a source cell is provided, the
-     *   new cell will be initialized with the data from the source.
-     *   If the contentFactory is not provided, the instance
-     *   `codeCellContentFactory` will be used.
-     */
-    createCodeCell(options: CodeCellModel.IOptions): ICodeCellModel {
-      if (!options.contentFactory) {
-        options.contentFactory = this.codeCellContentFactory;
-      }
-      return new CodeCellModel(options);
-    }
-
-    /**
-     * Create a new raw cell.
-     *
-     * @param source - The data to use for the original source data.
-     *
-     * @returns A new raw cell. If a source cell is provided, the
-     *   new cell will be initialized with the data from the source.
-     */
-    createRawCell(options: CellModel.IOptions): IRawCellModel {
-      return new RawCellModel(options);
-    }
-  }
-
-  /**
-   * The options used to initialize a `ModelFactory`.
-   */
-  export interface IModelFactoryOptions {
-    /**
-     * The factory for output area models.
-     */
-    codeCellContentFactory?: CodeCellModel.IContentFactory;
-  }
-
-  /**
-   * The default `ModelFactory` instance.
-   */
-  export const defaultModelFactory = new ModelFactory({});
 }
 
 /**
diff --git a/packages/console/style/index.css b/packages/console/style/index.css
index 192a269ffd7..c0e2d26bce3 100644
--- a/packages/console/style/index.css
+++ b/packages/console/style/index.css
@@ -9,6 +9,7 @@
 @import url('~@lumino/dragdrop/style/index.css');
 @import url('~@jupyterlab/codeeditor/style/index.css');
 @import url('~@jupyterlab/rendermime/style/index.css');
+@import url('~@jupyterlab/outputarea/style/index.css');
 @import url('~@jupyterlab/cells/style/index.css');
 
 @import url('./base.css');

diff --git a/packages/coreutils/src/pageconfig.ts b/packages/coreutils/src/pageconfig.ts
index e84050ffe37..25d9fa0424b 100644
--- a/packages/coreutils/src/pageconfig.ts
+++ b/packages/coreutils/src/pageconfig.ts
@@ -132,6 +132,13 @@ export namespace PageConfig {
     return URLExt.normalize(wsUrl);
   }
 
+  /**
+   * Get the unique store ID.
+   */
+  export function getStoreID(): number {
+    return Number(getOption('store_id'));
+  }
+
   /**
    * Returns the URL converting this notebook to a certain
    * format with nbconvert.
diff --git a/packages/csvviewer-extension/src/index.ts b/packages/csvviewer-extension/src/index.ts
index db69d577375..60a3519cd64 100644
--- a/packages/csvviewer-extension/src/index.ts
+++ b/packages/csvviewer-extension/src/index.ts
@@ -86,6 +86,7 @@ function activateCsv(
 ): void {
   const factory = new CSVViewerFactory({
     name: FACTORY_CSV,
+    modelName: 'string',
     fileTypes: ['csv'],
     defaultFor: ['csv'],
     readOnly: true
@@ -156,6 +157,7 @@ function activateTsv(
 ): void {
   const factory = new TSVViewerFactory({
     name: FACTORY_TSV,
+    modelName: 'string',
     fileTypes: ['tsv'],
     defaultFor: ['tsv'],
     readOnly: true

diff --git a/packages/docmanager-extension/src/index.ts b/packages/docmanager-extension/src/index.ts
index d1fec3d07a7..e70172909fc 100644
--- a/packages/docmanager-extension/src/index.ts
+++ b/packages/docmanager-extension/src/index.ts
@@ -420,7 +420,7 @@ function addCommands(
             return;
           }
           if (result.button.accept) {
-            if (context.model.readOnly) {
+            if (context.readOnly) {
               return context.revert();
             }
             return context.restoreCheckpoint().then(() => context.revert());
@@ -437,7 +437,7 @@ function addCommands(
     execute: () => {
       if (isEnabled()) {
         let context = docManager.contextForWidget(shell.currentWidget);
-        if (context.model.readOnly) {
+        if (context.readOnly) {
           return showDialog({
             title: 'Cannot Save',
             body: 'Document is read-only',
@@ -472,7 +472,7 @@ function addCommands(
       const paths = new Set<string>(); // Cache so we don't double save files.
       each(shell.widgets('main'), widget => {
         const context = docManager.contextForWidget(widget);
-        if (context && !context.model.readOnly && !paths.has(context.path)) {
+        if (context && !context.readOnly && !paths.has(context.path)) {
           paths.add(context.path);
           promises.push(context.save());
         }
@@ -646,8 +646,8 @@ function handleContext(
     }
   };
   void context.ready.then(() => {
-    context.model.stateChanged.connect(onStateChanged);
-    if (context.model.dirty) {
+    context.stateChanged.connect(onStateChanged);
+    if (context.dirty) {
       disposable = status.setDirty();
     }
   });
diff --git a/packages/docmanager/src/manager.ts b/packages/docmanager/src/manager.ts
index c17b68213e1..7849fafd1ba 100644
--- a/packages/docmanager/src/manager.ts
+++ b/packages/docmanager/src/manager.ts
@@ -456,15 +456,12 @@ export class DocumentManager implements IDocumentManager {
       this._widgetManager.adoptWidget(context, widget);
       this._opener.open(widget, options);
     };
-    let modelDBFactory =
-      this.services.contents.getModelDBFactory(path) || undefined;
     let context = new Context({
       opener: adopter,
       manager: this.services,
       factory,
       path,
       kernelPreference,
-      modelDBFactory,
       setBusy: this._setBusy
     });
     let handler = new SaveHandler({
diff --git a/packages/docmanager/src/savehandler.ts b/packages/docmanager/src/savehandler.ts
index 402887111ce..4025b3116be 100644
--- a/packages/docmanager/src/savehandler.ts
+++ b/packages/docmanager/src/savehandler.ts
@@ -111,7 +111,7 @@ export class SaveHandler implements IDisposable {
     // Bail if the model is not dirty or the file is not writable, or the dialog
     // is already showing.
     let writable = context.contentsModel && context.contentsModel.writable;
-    if (!writable || !context.model.dirty || this._inDialog) {
+    if (!writable || !context.dirty || this._inDialog) {
       return;
     }
 
diff --git a/packages/docmanager/src/widgetmanager.ts b/packages/docmanager/src/widgetmanager.ts
index 2507a012765..cecfd6f828d 100644
--- a/packages/docmanager/src/widgetmanager.ts
+++ b/packages/docmanager/src/widgetmanager.ts
@@ -278,7 +278,7 @@ export class DocumentWidgetManager implements IDisposable {
         let last = checkpoints[checkpoints.length - 1];
         let checkpoint = last ? Time.format(last.last_modified) : 'None';
         let caption = `Name: ${model.name}\nPath: ${model.path}\n`;
-        if (context.model.readOnly) {
+        if (context.readOnly) {
           caption += 'Read-only';
         } else {
           caption +=
@@ -351,8 +351,7 @@ export class DocumentWidgetManager implements IDisposable {
     if (!factory) {
       return Promise.resolve(true);
     }
-    let model = context.model;
-    if (!model.dirty || widgets.length > 1 || factory.readOnly) {
+    if (!context.dirty || widgets.length > 1 || factory.readOnly) {
       return Promise.resolve(true);
     }
     let fileName = widget.title.label;
diff --git a/packages/docregistry/src/context.ts b/packages/docregistry/src/context.ts
index 3618a08c553..62a2d89c130 100644
--- a/packages/docregistry/src/context.ts
+++ b/packages/docregistry/src/context.ts
@@ -23,9 +23,7 @@ import {
   showErrorMessage
 } from '@jupyterlab/apputils';
 
-import { PathExt } from '@jupyterlab/coreutils';
-
-import { IModelDB, ModelDB } from '@jupyterlab/observables';
+import { IChangedArgs, PathExt } from '@jupyterlab/coreutils';
 
 import { RenderMimeRegistry } from '@jupyterlab/rendermime';
 
@@ -51,17 +49,17 @@ export class Context<T extends DocumentRegistry.IModel>
     const localPath = this._manager.contents.localPath(this._path);
     let lang = this._factory.preferredLanguage(PathExt.basename(localPath));
 
-    let dbFactory = options.modelDBFactory;
-    if (dbFactory) {
-      const localPath = manager.contents.localPath(this._path);
-      this._modelDB = dbFactory.createNew(localPath);
-      this._model = this._factory.createNew(lang, this._modelDB);
-    } else {
-      this._model = this._factory.createNew(lang);
-    }
+    this._modelPromise = this._factory.createNew({
+      path: this._path,
+      languagePreference: lang
+    });
+    this._modelPromise.then(model => {
+      this._model = model;
+      this._model.contentChanged.connect(this._onModelContentChanged, this);
+    });
 
-    this._readyPromise = manager.ready.then(() => {
-      return this._populatedPromise.promise;
+    this._readyPromise = manager.ready.then(async () => {
+      await Promise.all([this._modelPromise, this._populatedPromise.promise]);
     });
 
     let ext = PathExt.extname(this._path);
@@ -96,6 +94,42 @@ export class Context<T extends DocumentRegistry.IModel>
     return this._fileChanged;
   }
 
+  /**
+   * A signal emitted when the document state changes.
+   */
+  get stateChanged(): ISignal<this, IChangedArgs<any>> {
+    return this._stateChanged;
+  }
+
+  /**
+   * The dirty state of the document.
+   */
+  get dirty(): boolean {
+    return this._dirty;
+  }
+  set dirty(newValue: boolean) {
+    if (newValue === this._dirty) {
+      return;
+    }
+    let oldValue = this._dirty;
+    this._dirty = newValue;
+    this._stateChanged.emit({ name: 'dirty', oldValue, newValue });
+  }
+
+  /**
+   * The read only state of the document.
+   */
+  get readOnly(): boolean {
+    return this._readOnly;
+  }
+  set readOnly(newValue: boolean) {
+    if (newValue === this._readOnly) {
+      return;
+    }
+    let oldValue = this._readOnly;
+    this._readOnly = newValue;
+    this._stateChanged.emit({ name: 'readOnly', oldValue, newValue });
+  }
   /**
    * A signal emitted on the start and end of a saving operation.
    */
@@ -113,7 +147,7 @@ export class Context<T extends DocumentRegistry.IModel>
   /**
    * Get the model associated with the document.
    */
-  get model(): T {
+  get model(): T | null {
     return this._model;
   }
 
@@ -175,9 +209,6 @@ export class Context<T extends DocumentRegistry.IModel>
     }
     this._isDisposed = true;
     this.session.dispose();
-    if (this._modelDB) {
-      this._modelDB.dispose();
-    }
     this._model.dispose();
     this._disposed.emit(void 0);
     Signal.clearData(this);
@@ -209,24 +240,20 @@ export class Context<T extends DocumentRegistry.IModel>
    *
    * @returns a promise that resolves upon initialization.
    */
-  initialize(isNew: boolean): Promise<void> {
+  async initialize(isNew: boolean): Promise<void> {
     if (isNew) {
-      this._model.initialize();
       return this._save();
     }
-    if (this._modelDB) {
-      return this._modelDB.connected.then(() => {
-        if (this._modelDB.isPrepopulated) {
-          this._model.initialize();
-          void this._save();
-          return void 0;
-        } else {
-          return this._revert(true);
-        }
-      });
-    } else {
-      return this._revert(true);
+    const model = await this._modelPromise;
+    if (
+      model.isCollaborative &&
+      ((model as any) as DocumentRegistry.ICollaborativeModel).isPrepopulated
+    ) {
+      this._populate();
+      return;
     }
+    // TODO how to handle prepopulated collaborative sessions?
+    return this._revert(true);
   }
 
   /**
@@ -408,6 +435,13 @@ export class Context<T extends DocumentRegistry.IModel>
     }
   }
 
+  /**
+   * Handle a change in the model content.
+   */
+  private _onModelContentChanged(): void {
+    this.dirty = true;
+  }
+
   /**
    * Update our contents model, without the content.
    */
@@ -482,17 +516,15 @@ export class Context<T extends DocumentRegistry.IModel>
 
     return this._manager.ready
       .then(() => {
-        if (!model.modelDB.isCollaborative) {
-          return this._maybeSave(options);
-        }
-        return this._manager.contents.save(this._path, options);
+        // TODO think about how saving works in collaborative environments.
+        return this._maybeSave(options);
       })
       .then(value => {
         if (this.isDisposed) {
           return;
         }
 
-        model.dirty = false;
+        this.dirty = false;
         this._updateContentsModel(value);
 
         if (!this._isPopulated) {
@@ -541,21 +573,19 @@ export class Context<T extends DocumentRegistry.IModel>
       content: true
     };
     let path = this._path;
-    let model = this._model;
     return this._manager.ready
       .then(() => {
         return this._manager.contents.get(path, opts);
       })
-      .then(contents => {
+      .then(async contents => {
         if (this.isDisposed) {
           return;
         }
+        let model = await this._modelPromise;
         let dirty = false;
         if (contents.format === 'json') {
           model.fromJSON(contents.content);
-          if (initializeModel) {
-            model.initialize();
-          }
+          // TODO figure out model initialization
         } else {
           let content = contents.content;
           // Convert line endings if necessary, marking the file
@@ -567,12 +597,9 @@ export class Context<T extends DocumentRegistry.IModel>
             this._useCRLF = false;
           }
           model.fromString(content);
-          if (initializeModel) {
-            model.initialize();
-          }
         }
         this._updateContentsModel(contents);
-        model.dirty = dirty;
+        this.dirty = dirty;
         if (!this._isPopulated) {
           return this._populate();
         }
@@ -763,8 +790,8 @@ export class Context<T extends DocumentRegistry.IModel>
     widget: Widget,
     options?: DocumentRegistry.IOpenOptions
   ) => void;
-  private _model: T;
-  private _modelDB: IModelDB;
+  private _model: T | null;
+  private _modelPromise: Promise<T>;
   private _path = '';
   private _useCRLF = false;
   private _factory: DocumentRegistry.IModelFactory<T>;
@@ -776,8 +803,11 @@ export class Context<T extends DocumentRegistry.IModel>
   private _isDisposed = false;
   private _pathChanged = new Signal<this, string>(this);
   private _fileChanged = new Signal<this, Contents.IModel>(this);
+  private _stateChanged = new Signal<this, IChangedArgs<any>>(this);
   private _saveState = new Signal<this, DocumentRegistry.SaveState>(this);
   private _disposed = new Signal<this, void>(this);
+  private _dirty = false;
+  private _readOnly = false;
 }
 
 /**
@@ -808,11 +838,6 @@ export namespace Context {
      */
     kernelPreference?: IClientSession.IKernelPreference;
 
-    /**
-     * An IModelDB factory method which may be used for the document.
-     */
-    modelDBFactory?: ModelDB.IFactory;
-
     /**
      * An optional callback for opening sibling widgets.
      */
diff --git a/packages/docregistry/src/default.ts b/packages/docregistry/src/default.ts
index fcb9cc3718a..187773c825f 100644
--- a/packages/docregistry/src/default.ts
+++ b/packages/docregistry/src/default.ts
@@ -1,40 +1,73 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
+import { MainAreaWidget } from '@jupyterlab/apputils';
+
+import {
+  CodeEditor,
+  CodeEditorData,
+  ICodeEditorData
+} from '@jupyterlab/codeeditor';
+
 import { Mode } from '@jupyterlab/codemirror';
 
+import { IChangedArgs, PathExt } from '@jupyterlab/coreutils';
+
+import { createDatastore, DatastoreExt } from '@jupyterlab/datastore';
+
 import { Contents } from '@jupyterlab/services';
 
 import { JSONValue } from '@lumino/coreutils';
 
+import { IDisposable } from '@lumino/disposable';
+
 import { ISignal, Signal } from '@lumino/signaling';
 
 import { Widget } from '@lumino/widgets';
 
-import { MainAreaWidget } from '@jupyterlab/apputils';
-
-import { CodeEditor } from '@jupyterlab/codeeditor';
-
-import { IChangedArgs, PathExt } from '@jupyterlab/coreutils';
-
-import { IModelDB } from '@jupyterlab/observables';
-
 import { DocumentRegistry, IDocumentWidget } from './index';
 
 /**
- * The default implementation of a document model.
+ * The default implementation of a text document model.
  */
-export class DocumentModel extends CodeEditor.Model
+export class TextDocumentModel extends CodeEditor.Model
   implements DocumentRegistry.ICodeModel {
   /**
    * Construct a new document model.
    */
-  constructor(languagePreference?: string, modelDB?: IModelDB) {
-    super({ modelDB });
-    this._defaultLang = languagePreference || '';
-    this.value.changed.connect(this.triggerContentChange, this);
+  constructor(options: TextDocumentModel.IOptions = {}) {
+    super({
+      data: options.data || {
+        datastore: CodeEditorData.createStore(),
+        record: {
+          schema: CodeEditorData.SCHEMA,
+          record: 'data'
+        }
+      }
+    });
+
+    this._defaultLang = options.languagePreference || '';
+    // We don't want to trigger a content change for text selection changes,
+    // only actual content changes to the data owned by the document
+    this._listener = DatastoreExt.listenField(
+      this.data.datastore,
+      { ...this.data.record, field: 'text' },
+      this.triggerContentChange,
+      this
+    );
+    this.ready = Promise.resolve(undefined);
   }
 
+  /**
+   * Whether the model is ready for collaboration.
+   */
+  readonly ready: Promise<void>;
+
+  /**
+   * Whether the model is collaborative.
+   */
+  readonly isCollaborative = true;
+
   /**
    * A signal emitted when the document content changes.
    */
@@ -43,51 +76,129 @@ export class DocumentModel extends CodeEditor.Model
   }
 
   /**
-   * A signal emitted when the document state changes.
+   * The default kernel name of the document.
+   *
+   * #### Notes
+   * This is a read-only property.
    */
-  get stateChanged(): ISignal<this, IChangedArgs<any>> {
-    return this._stateChanged;
+  get defaultKernelName(): string {
+    return '';
   }
 
   /**
-   * The dirty state of the document.
+   * The default kernel language of the document.
+   *
+   * #### Notes
+   * This is a read-only property.
    */
-  get dirty(): boolean {
-    return this._dirty;
+  get defaultKernelLanguage(): string {
+    return this._defaultLang;
   }
-  set dirty(newValue: boolean) {
-    if (newValue === this._dirty) {
-      return;
-    }
-    let oldValue = this._dirty;
-    this._dirty = newValue;
-    this.triggerStateChange({ name: 'dirty', oldValue, newValue });
+
+  /**
+   * Serialize the model to a string.
+   */
+  toString(): string {
+    return this.value;
   }
 
   /**
-   * The read only state of the document.
+   * Deserialize the model from a string.
+   *
+   * #### Notes
+   * Should emit a [contentChanged] signal.
    */
-  get readOnly(): boolean {
-    return this._readOnly;
+  fromString(value: string): void {
+    this.value = value;
+  }
+
+  /**
+   * Serialize the model to JSON.
+   */
+  toJSON(): JSONValue {
+    return JSON.parse(this.value || 'null');
+  }
+
+  /**
+   * Deserialize the model from JSON.
+   *
+   * #### Notes
+   * Should emit a [contentChanged] signal.
+   */
+  fromJSON(value: JSONValue): void {
+    this.fromString(JSON.stringify(value));
   }
-  set readOnly(newValue: boolean) {
-    if (newValue === this._readOnly) {
+
+  /**
+   * Dispose of resources held by the document model.
+   */
+  dispose(): void {
+    if (this.isDisposed) {
       return;
     }
-    let oldValue = this._readOnly;
-    this._readOnly = newValue;
-    this.triggerStateChange({ name: 'readOnly', oldValue, newValue });
+    if (this._listener) {
+      this._listener.dispose();
+    }
+    super.dispose();
+  }
+
+  /**
+   * Trigger a content changed signal.
+   */
+  protected triggerContentChange(): void {
+    this._contentChanged.emit(void 0);
+  }
+
+  private _contentChanged = new Signal<this, void>(this);
+  private _listener: IDisposable | null = null;
+  private _defaultLang = '';
+}
+
+/**
+ * A namespace for TextDocumentModel statics.
+ */
+export namespace TextDocumentModel {
+  /**
+   * Options for creating a new TextDocumentModel.
+   */
+  export interface IOptions {
+    /**
+     * A record in a datastore in which to hold the data.
+     */
+    data?: ICodeEditorData.DataLocation;
+
+    /**
+     * The preferred kernel language for the document.
+     */
+    languagePreference?: string;
+  }
+}
+
+/**
+ * An implementation of a string document model. Unlike the text document model,
+ * it is not intended to be collaborative, so it has a lighter memory footprint.
+ * It is intended to be used for large, static text data, such as CSVs.
+ */
+export class StringDocumentModel implements DocumentRegistry.IModel {
+  /**
+   * A signal emitted when the document content changes.
+   */
+  get contentChanged(): ISignal<this, void> {
+    return this._contentChanged;
   }
 
+  /**
+   * Whether the model is collaborative.
+   */
+  readonly isCollaborative = false;
+
   /**
    * The default kernel name of the document.
    *
    * #### Notes
    * This is a read-only property.
    */
-  get defaultKernelName(): string {
-    return '';
-  }
+  readonly defaultKernelName = '';
 
   /**
    * The default kernel language of the document.
@@ -95,15 +206,13 @@ export class DocumentModel extends CodeEditor.Model
    * #### Notes
    * This is a read-only property.
    */
-  get defaultKernelLanguage(): string {
-    return this._defaultLang;
-  }
+  readonly defaultKernelLanguage = '';
 
   /**
    * Serialize the model to a string.
    */
   toString(): string {
-    return this.value.text;
+    return this._value;
   }
 
   /**
@@ -113,14 +222,15 @@ export class DocumentModel extends CodeEditor.Model
    * Should emit a [contentChanged] signal.
    */
   fromString(value: string): void {
-    this.value.text = value;
+    this._value = value;
+    this._contentChanged.emit();
   }
 
   /**
    * Serialize the model to JSON.
    */
   toJSON(): JSONValue {
-    return JSON.parse(this.value.text || 'null');
+    return JSON.parse(this._value || 'null');
   }
 
   /**
@@ -134,32 +244,26 @@ export class DocumentModel extends CodeEditor.Model
   }
 
   /**
-   * Initialize the model with its current state.
-   */
-  initialize(): void {
-    return;
-  }
-
-  /**
-   * Trigger a state change signal.
+   * Whether the model has been disposed.
    */
-  protected triggerStateChange(args: IChangedArgs<any>): void {
-    this._stateChanged.emit(args);
+  get isDisposed(): boolean {
+    return this._isDisposed;
   }
 
   /**
-   * Trigger a content changed signal.
+   * Dispose of resources held by the document model.
    */
-  protected triggerContentChange(): void {
-    this._contentChanged.emit(void 0);
-    this.dirty = true;
+  dispose(): void {
+    if (this._isDisposed) {
+      return;
+    }
+    this._isDisposed = true;
+    this._value = '';
   }
 
-  private _defaultLang = '';
-  private _dirty = false;
-  private _readOnly = false;
   private _contentChanged = new Signal<this, void>(this);
-  private _stateChanged = new Signal<this, IChangedArgs<any>>(this);
+  private _isDisposed = false;
+  private _value = '';
 }
 
 /**
@@ -216,11 +320,22 @@ export class TextModelFactory implements DocumentRegistry.CodeModelFactory {
    *
    * @returns A new document model.
    */
-  createNew(
-    languagePreference?: string,
-    modelDB?: IModelDB
-  ): DocumentRegistry.ICodeModel {
-    return new DocumentModel(languagePreference, modelDB);
+  async createNew(
+    options: DocumentRegistry.IModelFactory.IOptions = {}
+  ): Promise<DocumentRegistry.ICodeModel> {
+    const { languagePreference, path } = options;
+    if (path) {
+      const datastore = await createDatastore(path, [CodeEditorData.SCHEMA]);
+      const data = {
+        datastore,
+        record: {
+          schema: CodeEditorData.SCHEMA,
+          record: 'data'
+        }
+      };
+      return new TextDocumentModel({ data, languagePreference });
+    }
+    return new TextDocumentModel({ languagePreference });
   }
 
   /**
@@ -235,9 +350,10 @@ export class TextModelFactory implements DocumentRegistry.CodeModelFactory {
 }
 
 /**
- * An implementation of a model factory for base64 files.
+ * An implementation of a model factory for string documents.
  */
-export class Base64ModelFactory extends TextModelFactory {
+export class StringModelFactory
+  implements DocumentRegistry.IModelFactory<StringDocumentModel> {
   /**
    * The name of the model type.
    *
@@ -245,7 +361,7 @@ export class Base64ModelFactory extends TextModelFactory {
    * This is a read-only property.
    */
   get name(): string {
-    return 'base64';
+    return 'string';
   }
 
   /**
@@ -258,6 +374,66 @@ export class Base64ModelFactory extends TextModelFactory {
     return 'file';
   }
 
+  /**
+   * The format of the file.
+   *
+   * This is a read-only property.
+   */
+  get fileFormat(): Contents.FileFormat {
+    return 'text';
+  }
+  /**
+   * Get whether the model factory has been disposed.
+   */
+  get isDisposed(): boolean {
+    return this._isDisposed;
+  }
+
+  /**
+   * Dispose of the resources held by the model factory.
+   */
+  dispose(): void {
+    this._isDisposed = true;
+  }
+
+  /**
+   * Create a new model.
+   *
+   * @param languagePreference - An optional kernel language preference.
+   *
+   * @returns A new document model.
+   */
+  async createNew(
+    options: DocumentRegistry.IModelFactory.IOptions = {}
+  ): Promise<StringDocumentModel> {
+    return new StringDocumentModel();
+  }
+
+  /**
+   * Get the preferred kernel language given the path.
+   * Returns an empty string.
+   */
+  preferredLanguage(path: string): string {
+    return '';
+  }
+
+  private _isDisposed = false;
+}
+
+/**
+ * An implementation of a model factory for base64-encoded documents.
+ */
+export class Base64ModelFactory extends StringModelFactory {
+  /**
+   * The name of the model type.
+   *
+   * #### Notes
+   * This is a read-only property.
+   */
+  get name(): string {
+    return 'base64';
+  }
+
   /**
    * The format of the file.
    *
@@ -463,7 +639,7 @@ export class DocumentWidget<
     this._onPathChanged(this.context, this.context.path);
 
     // Listen for changes in the dirty state.
-    this.context.model.stateChanged.connect(this._onModelStateChanged, this);
+    this.context.stateChanged.connect(this._onContextStateChanged, this);
     void this.context.ready.then(() => {
       this._handleDirtyState();
     });
@@ -487,10 +663,10 @@ export class DocumentWidget<
   }
 
   /**
-   * Handle a change to the context model state.
+   * Handle a change to the context state.
    */
-  private _onModelStateChanged(
-    sender: DocumentRegistry.IModel,
+  private _onContextStateChanged(
+    sender: DocumentRegistry.IContext<DocumentRegistry.IModel>,
     args: IChangedArgs<any>
   ): void {
     if (args.name === 'dirty') {
@@ -502,7 +678,7 @@ export class DocumentWidget<
    * Handle the dirty state of the context model.
    */
   private _handleDirtyState(): void {
-    if (this.context.model.dirty) {
+    if (this.context.dirty) {
       this.title.className += ` ${DIRTY_CLASS}`;
     } else {
       this.title.className = this.title.className.replace(DIRTY_CLASS, '');
diff --git a/packages/docregistry/src/mimedocument.ts b/packages/docregistry/src/mimedocument.ts
index b8225dd095c..3092eb2d26e 100644
--- a/packages/docregistry/src/mimedocument.ts
+++ b/packages/docregistry/src/mimedocument.ts
@@ -191,6 +191,7 @@ export class MimeContent extends Widget {
     } else {
       if (!JSONExt.deepEqual(data, this._context.model.toJSON())) {
         this._context.model.fromJSON(data);
+        this._context.dirty = false;
       }
     }
   };
diff --git a/packages/docregistry/src/registry.ts b/packages/docregistry/src/registry.ts
index f234672f596..bf3bb600bea 100644
--- a/packages/docregistry/src/registry.ts
+++ b/packages/docregistry/src/registry.ts
@@ -1,8 +1,6 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { Contents, Kernel } from '@jupyterlab/services';
-
 import {
   ArrayExt,
   ArrayIterator,
@@ -30,7 +28,7 @@ import {
   PathExt
 } from '@jupyterlab/coreutils';
 
-import { IModelDB } from '@jupyterlab/observables';
+import { Contents, Kernel } from '@jupyterlab/services';
 
 import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
 
@@ -659,23 +657,9 @@ export namespace DocumentRegistry {
     contentChanged: ISignal<this, void>;
 
     /**
-     * A signal emitted when the model state changes.
-     */
-    stateChanged: ISignal<this, IChangedArgsGeneric<any>>;
-
-    /**
-     * The dirty state of the model.
-     *
-     * #### Notes
-     * This should be cleared when the document is loaded from
-     * or saved to disk.
-     */
-    dirty: boolean;
-
-    /**
-     * The read-only state of the model.
+     * Whether the model is collaborative.
      */
-    readOnly: boolean;
+    readonly isCollaborative: boolean;
 
     /**
      * The default kernel name of the document.
@@ -687,16 +671,6 @@ export namespace DocumentRegistry {
      */
     readonly defaultKernelLanguage: string;
 
-    /**
-     * The underlying `IModelDB` instance in which model
-     * data is stored.
-     *
-     * ### Notes
-     * Making direct edits to the values stored in the`IModelDB`
-     * is not recommended, and may produce unpredictable results.
-     */
-    readonly modelDB: IModelDB;
-
     /**
      * Serialize the model to a string.
      */
@@ -722,21 +696,32 @@ export namespace DocumentRegistry {
      * Should emit a [contentChanged] signal.
      */
     fromJSON(value: any): void;
+  }
 
+  export interface ICollaborativeModel extends IModel {
     /**
-     * Initialize model state after initial data load.
-     *
-     * #### Notes
-     * This function must be called after the initial data is loaded to set up
-     * initial model state, such as an initial undo stack, etc.
+     * Whether the collaborative model is ready for use.
+     * This typically means it has made a connection with the server
+     * and received any history or context that it needs.
+     */
+    readonly ready: Promise<void>;
+
+    /**
+     * Whether the model is collaborative.
      */
-    initialize(): void;
+    readonly isCollaborative: true;
+
+    /**
+     * Whether the datastore for the model is prepopulated upon
+     * model construction time.
+     */
+    readonly isPrepopulated: boolean;
   }
 
   /**
    * The interface for a document model that represents code.
    */
-  export interface ICodeModel extends IModel, CodeEditor.IModel {}
+  export interface ICodeModel extends ICollaborativeModel, CodeEditor.IModel {}
 
   /**
    * The document context object.
@@ -752,6 +737,25 @@ export namespace DocumentRegistry {
      */
     fileChanged: ISignal<this, Contents.IModel>;
 
+    /**
+     * A signal emitted when the model state changes.
+     */
+    stateChanged: ISignal<this, IChangedArgsGeneric<any>>;
+
+    /**
+     * The dirty state of the model.
+     *
+     * #### Notes
+     * This should be cleared when the document is loaded from
+     * or saved to disk.
+     */
+    dirty: boolean;
+
+    /**
+     * The read-only state of the model.
+     */
+    readOnly: boolean;
+
     /**
      * A signal emitted on the start and end of a saving operation.
      */
@@ -1044,7 +1048,7 @@ export namespace DocumentRegistry {
      *
      * @returns A new document model.
      */
-    createNew(languagePreference?: string, modelDB?: IModelDB): T;
+    createNew(options: IModelFactory.IOptions): Promise<T>;
 
     /**
      * Get the preferred kernel language given a file path.
@@ -1052,6 +1056,26 @@ export namespace DocumentRegistry {
     preferredLanguage(path: string): string;
   }
 
+  /**
+   * A namespace for IModelFactory statics.
+   */
+  export namespace IModelFactory {
+    /**
+     * Options for creating a new document model.
+     */
+    export interface IOptions {
+      /**
+       * An optional path which can be used to set up a collaboration context.
+       */
+      path?: string;
+
+      /**
+       * A kernel language preference.
+       */
+      languagePreference?: string;
+    }
+  }
+
   /**
    * A type alias for a standard model factory.
    */
diff --git a/packages/documentsearch/src/providers/notebooksearchprovider.ts b/packages/documentsearch/src/providers/notebooksearchprovider.ts
index 20cf0e1b985..80703202321 100644
--- a/packages/documentsearch/src/providers/notebooksearchprovider.ts
+++ b/packages/documentsearch/src/providers/notebooksearchprovider.ts
@@ -3,10 +3,12 @@
 import { ISearchProvider, ISearchMatch } from '../index';
 import { CodeMirrorSearchProvider } from './codemirrorsearchprovider';
 
-import { NotebookPanel } from '@jupyterlab/notebook';
-import { CodeMirrorEditor } from '@jupyterlab/codemirror';
 import { Cell, MarkdownCell } from '@jupyterlab/cells';
+import { CodeMirrorEditor } from '@jupyterlab/codemirror';
+import { DatastoreExt } from '@jupyterlab/datastore';
+import { NotebookPanel } from '@jupyterlab/notebook';
 
+import { IDisposable } from '@lumino/disposable';
 import { Signal, ISignal } from '@lumino/signaling';
 import { Widget } from '@lumino/widgets';
 
@@ -50,8 +52,13 @@ export class NotebookSearchProvider implements ISearchProvider<NotebookPanel> {
     this._query = query;
     // Listen for cell model change to redo the search in case of
     // new/pasted/deleted cells
-    const cellList = this._searchTarget.model.cells;
-    cellList.changed.connect(this._restartQuery.bind(this), this);
+    const { datastore, record } = this._searchTarget.content.model.data;
+    this._cellListener = DatastoreExt.listenField(
+      datastore,
+      { ...record, field: 'cells' },
+      this._restartQuery,
+      this
+    );
 
     let indexTotal = 0;
     const allMatches: ISearchMatch[] = [];
@@ -129,7 +136,10 @@ export class NotebookSearchProvider implements ISearchProvider<NotebookPanel> {
       queriesEnded.push(provider.endQuery());
       provider.changed.disconnect(this._onCmSearchProviderChanged, this);
     });
-    Signal.disconnectBetween(this._searchTarget.model.cells, this);
+    if (this._cellListener) {
+      this._cellListener.dispose();
+      this._cellListener = null;
+    }
 
     this._cmSearchProviders = [];
     this._unRenderedMarkdownCells.forEach((cell: MarkdownCell) => {
@@ -148,7 +158,10 @@ export class NotebookSearchProvider implements ISearchProvider<NotebookPanel> {
    * @returns A promise that resolves when all state has been cleaned up.
    */
   async endSearch(): Promise<void> {
-    Signal.disconnectBetween(this._searchTarget.model.cells, this);
+    if (this._cellListener) {
+      this._cellListener.dispose();
+      this._cellListener = null;
+    }
 
     const index = this._searchTarget.content.activeCellIndex;
     const searchEnded: Promise<void>[] = [];
@@ -368,4 +381,5 @@ export class NotebookSearchProvider implements ISearchProvider<NotebookPanel> {
   private _currentMatch: ISearchMatch;
   private _unRenderedMarkdownCells: MarkdownCell[] = [];
   private _changed = new Signal<this, void>(this);
+  private _cellListener: IDisposable;
 }
diff --git a/packages/fileeditor-extension/src/index.ts b/packages/fileeditor-extension/src/index.ts
index 2379f659544..90521beb74e 100644
--- a/packages/fileeditor-extension/src/index.ts
+++ b/packages/fileeditor-extension/src/index.ts
@@ -249,6 +249,9 @@ function activate(
    */
   function updateWidget(widget: FileEditor): void {
     const editor = widget.editor;
+    if (!editor) {
+      return;
+    }
     Object.keys(config).forEach((key: keyof CodeEditor.IConfig) => {
       editor.setOption(key, config[key]);
     });
@@ -270,7 +273,7 @@ function activate(
       updateTracker();
     });
 
-  factory.widgetCreated.connect((sender, widget) => {
+  factory.widgetCreated.connect(async (sender, widget) => {
     widget.title.icon = EDITOR_ICON_CLASS;
 
     // Notify the widget tracker if restore data needs to update.
@@ -278,12 +281,14 @@ function activate(
       void tracker.save(widget);
     });
     void tracker.add(widget);
+    await widget.context.ready;
     updateWidget(widget.content);
   });
   app.docRegistry.addWidgetFactory(factory);
 
   // Handle the settings of new widgets.
-  tracker.widgetAdded.connect((sender, widget) => {
+  tracker.widgetAdded.connect(async (sender, widget) => {
+    await widget.context.ready;
     updateWidget(widget.content);
   });
 
@@ -448,9 +453,9 @@ function activate(
         const start = editor.getOffsetAt(selection.start);
         const end = editor.getOffsetAt(selection.end);
 
-        code = editor.model.value.text.substring(start, end);
+        code = editor.model.value.substring(start, end);
       } else if (MarkdownCodeBlocks.isMarkdown(extension)) {
-        const { text } = editor.model.value;
+        const text = editor.model.value;
         const blocks = MarkdownCodeBlocks.findMarkdownCodeBlocks(text);
 
         for (let block of blocks) {
@@ -467,8 +472,8 @@ function activate(
         code = editor.getLine(selection.start.line);
         const cursor = editor.getCursorPosition();
         if (cursor.line + 1 === editor.lineCount) {
-          let text = editor.model.value.text;
-          editor.model.value.text = text + '\n';
+          let text = editor.model.value;
+          editor.model.value = text + '\n';
         }
         editor.setCursorPosition({
           line: cursor.line + 1,
@@ -497,7 +502,7 @@ function activate(
 
       let code = '';
       let editor = widget.editor;
-      let text = editor.model.value.text;
+      let text = editor.model.value;
       let path = widget.context.path;
       let extension = PathExt.extname(path);
 
diff --git a/packages/fileeditor/src/widget.ts b/packages/fileeditor/src/widget.ts
index 84a7de4c906..dbf615b6310 100644
--- a/packages/fileeditor/src/widget.ts
+++ b/packages/fileeditor/src/widget.ts
@@ -1,7 +1,14 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { StackedLayout, Widget } from '@lumino/widgets';
+import {
+  CodeEditor,
+  IEditorServices,
+  IEditorMimeTypeService,
+  CodeEditorWrapper
+} from '@jupyterlab/codeeditor';
+
+import { DatastoreExt } from '@jupyterlab/datastore';
 
 import {
   ABCWidgetFactory,
@@ -10,17 +17,12 @@ import {
   IDocumentWidget
 } from '@jupyterlab/docregistry';
 
-import {
-  CodeEditor,
-  IEditorServices,
-  IEditorMimeTypeService,
-  CodeEditorWrapper
-} from '@jupyterlab/codeeditor';
-
 import { PromiseDelegate } from '@lumino/coreutils';
 
 import { Message } from '@lumino/messaging';
 
+import { StackedLayout, Widget } from '@lumino/widgets';
+
 /**
  * The data attribute added to a widget that can run code.
  */
@@ -45,39 +47,16 @@ export class FileEditorCodeWrapper extends CodeEditorWrapper {
     });
 
     const context = (this._context = options.context);
-    const editor = this.editor;
 
     this.addClass('jp-FileEditorCodeWrapper');
     this.node.dataset[CODE_RUNNER] = 'true';
     this.node.dataset[UNDOER] = 'true';
 
-    editor.model.value.text = context.model.toString();
     void context.ready.then(() => {
       this._onContextReady();
     });
 
-    if (context.model.modelDB.isCollaborative) {
-      let modelDB = context.model.modelDB;
-      void modelDB.connected.then(() => {
-        let collaborators = modelDB.collaborators;
-        if (!collaborators) {
-          return;
-        }
-
-        // Setup the selection style for collaborators
-        let localCollaborator = collaborators.localCollaborator;
-        this.editor.uuid = localCollaborator.sessionId;
-
-        this.editor.selectionStyle = {
-          ...CodeEditor.defaultSelectionStyle,
-          color: localCollaborator.color
-        };
-
-        collaborators.changed.connect(this._onCollaboratorsChanged, this);
-        // Trigger an initial onCollaboratorsChanged event.
-        this._onCollaboratorsChanged();
-      });
-    }
+    // TODO Let collaborators know who we are via a cursor.
   }
 
   /**
@@ -95,58 +74,44 @@ export class FileEditorCodeWrapper extends CodeEditorWrapper {
   }
 
   /**
-   * Handle actions that should be taken when the context is ready.
+   * Dispose of the resources held by the widget.
    */
-  private _onContextReady(): void {
+  dispose(): void {
     if (this.isDisposed) {
       return;
     }
-    const contextModel = this._context.model;
-    const editor = this.editor;
-    const editorModel = editor.model;
-
-    // Set the editor model value.
-    editorModel.value.text = contextModel.toString();
-
-    // Prevent the initial loading from disk from being in the editor history.
-    editor.clearHistory();
-
-    // Wire signal connections.
-    contextModel.contentChanged.connect(this._onContentChanged, this);
-
-    // Resolve the ready promise.
-    this._ready.resolve(undefined);
+    this._trimSelections();
+    super.dispose();
   }
 
   /**
-   * Handle a change in context model content.
+   * Remove selections from inactive cells to avoid
+   * spurious cursors.
    */
-  private _onContentChanged(): void {
-    const editorModel = this.editor.model;
-    const oldValue = editorModel.value.text;
-    const newValue = this._context.model.toString();
-
-    if (oldValue !== newValue) {
-      editorModel.value.text = newValue;
-    }
+  private _trimSelections(): void {
+    const { datastore, record } = this.model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'selections' },
+        { [this.editor.uuid]: null }
+      );
+    });
   }
 
   /**
-   * Handle a change to the collaborators on the model
-   * by updating UI elements associated with them.
+   * Handle actions that should be taken when the context is ready.
    */
-  private _onCollaboratorsChanged(): void {
-    // If there are selections corresponding to non-collaborators,
-    // they are stale and should be removed.
-    let collaborators = this._context.model.modelDB.collaborators;
-    if (!collaborators) {
+  private _onContextReady(): void {
+    if (this.isDisposed) {
       return;
     }
-    for (let key of this.editor.model.selections.keys()) {
-      if (!collaborators.has(key)) {
-        this.editor.model.selections.delete(key);
-      }
-    }
+    this.editor.model.value = this._context.model.toString();
+    // Prevent the initial loading from disk from being in the editor history.
+    this.editor.clearHistory();
+
+    // Resolve the ready promise.
+    this._ready.resolve(undefined);
   }
 
   protected _context: DocumentRegistry.Context;
@@ -167,30 +132,46 @@ export class FileEditor extends Widget {
     const context = (this._context = options.context);
     this._mimeTypeService = options.mimeTypeService;
 
-    let editorWidget = (this.editorWidget = new FileEditorCodeWrapper(options));
-    this.editor = editorWidget.editor;
-    this.model = editorWidget.model;
+    let layout = (this.layout = new StackedLayout());
+
+    context.ready.then(() => {
+      let editorWidget = (this._editorWidget = new FileEditorCodeWrapper(
+        options
+      ));
+      layout.addWidget(editorWidget);
+      this._onPathChanged();
+    });
 
     // Listen for changes to the path.
     context.pathChanged.connect(this._onPathChanged, this);
-    this._onPathChanged();
-
-    let layout = (this.layout = new StackedLayout());
-    layout.addWidget(editorWidget);
   }
 
   /**
    * Get the context for the editor widget.
    */
   get context(): DocumentRegistry.Context {
-    return this.editorWidget.context;
+    return this._context;
+  }
+
+  /**
+   * The code editor model associated with the file.
+   */
+  get model(): CodeEditor.IModel | null {
+    return this._editorWidget ? this._editorWidget.model : null;
+  }
+
+  /**
+   * The code editor widget associated with the file.
+   */
+  get editor(): CodeEditor.IEditor | null {
+    return this._editorWidget ? this._editorWidget.editor : null;
   }
 
   /**
    * A promise that resolves when the file editor is ready.
    */
   get ready(): Promise<void> {
-    return this.editorWidget.ready;
+    return this._editorWidget.ready;
   }
 
   /**
@@ -244,8 +225,8 @@ export class FileEditor extends Widget {
    * Ensure that the widget has focus.
    */
   private _ensureFocus(): void {
-    if (!this.editor.hasFocus()) {
-      this.editor.focus();
+    if (!this._editorWidget.editor.hasFocus()) {
+      this._editorWidget.editor.focus();
     }
   }
 
@@ -253,18 +234,14 @@ export class FileEditor extends Widget {
    * Handle a change to the path.
    */
   private _onPathChanged(): void {
-    const editor = this.editor;
     const localPath = this._context.localPath;
-
-    editor.model.mimeType = this._mimeTypeService.getMimeTypeByFilePath(
+    this.model.mimeType = this._mimeTypeService.getMimeTypeByFilePath(
       localPath
     );
   }
 
-  private editorWidget: FileEditorCodeWrapper;
-  public model: CodeEditor.IModel;
-  public editor: CodeEditor.IEditor;
-  protected _context: DocumentRegistry.Context;
+  private _context: DocumentRegistry.Context;
+  private _editorWidget: FileEditorCodeWrapper | null = null;
   private _mimeTypeService: IEditorMimeTypeService;
 }

diff --git a/packages/inspector/src/handler.ts b/packages/inspector/src/handler.ts
index e3c91aecd77..2eef879978e 100644
--- a/packages/inspector/src/handler.ts
+++ b/packages/inspector/src/handler.ts
@@ -69,8 +69,7 @@ export class InspectionHandler implements IDisposable, IInspector.IInspectable {
       // Call onEditorChange to cover the case where the user changes
       // the active cell
       this.onEditorChange();
-      editor.model.selections.changed.connect(this._onChange, this);
-      editor.model.value.changed.connect(this._onChange, this);
+      editor.model.data.datastore.changed.connect(this._onChange, this);
     }
   }
 
@@ -128,7 +127,7 @@ export class InspectionHandler implements IDisposable, IInspector.IInspectable {
       return;
     }
 
-    const text = editor.model.value.text;
+    const text = editor.model.value;
     const position = editor.getCursorPosition();
     const offset = Text.jsIndexToCharIndex(editor.getOffsetAt(position), text);
     const update: IInspector.IInspectorUpdate = { content: null };
diff --git a/packages/notebook-extension/src/index.ts b/packages/notebook-extension/src/index.ts
index e88150e6230..1d475306910 100644
--- a/packages/notebook-extension/src/index.ts
+++ b/packages/notebook-extension/src/index.ts
@@ -28,6 +28,8 @@ import {
   URLExt
 } from '@jupyterlab/coreutils';
 
+import { DatastoreExt } from '@jupyterlab/datastore';
+
 import { IDocumentManager } from '@jupyterlab/docmanager';
 
 import { ArrayExt } from '@lumino/algorithm';
@@ -956,10 +958,13 @@ function addCommands(
       const { context, content } = current;
 
       let cell = content.activeCell;
-      let metadata = cell.model.metadata.toJSON();
+      let metadata = DatastoreExt.getField(cell.data.datastore, {
+        ...cell.data.record,
+        field: 'metadata'
+      });
       let path = context.path;
       // ignore action in non-code cell
-      if (!cell || cell.model.type !== 'code') {
+      if (!cell || cell.type !== 'code') {
         return;
       }
 
@@ -973,11 +978,11 @@ function addCommands(
         // Get the selected code from the editor.
         const start = editor.getOffsetAt(selection.start);
         const end = editor.getOffsetAt(selection.end);
-        code = editor.model.value.text.substring(start, end);
+        code = editor.model.value.substring(start, end);
       } else {
         // no selection, find the complete statement around the current line
         const cursor = editor.getCursorPosition();
-        let srcLines = editor.model.value.text.split('\n');
+        let srcLines = editor.model.value.split('\n');
         let curLine = selection.start.line;
         while (
           curLine < editor.lineCount &&
@@ -1193,7 +1198,7 @@ function addCommands(
       const { context } = current;
 
       child.opener = null;
-      if (context.model.dirty && !context.model.readOnly) {
+      if (context.dirty && !context.readOnly) {
         return context.save().then(() => {
           child.location.assign(url);
         });
@@ -1626,11 +1631,18 @@ function addCommands(
         mode: 'split-bottom'
       });
 
+      // TODO: this needs some fixing as the model for how cells move
+      // has changed.
       const updateCloned = () => {
         void clonedOutputs.save(widget);
       };
       current.context.pathChanged.connect(updateCloned);
-      current.content.model.cells.changed.connect(updateCloned);
+      const { datastore, record } = current.content.model.data;
+      const cloneListener = DatastoreExt.listenField(
+        datastore,
+        { ...record, field: 'cells' },
+        updateCloned
+      );
 
       // Add the cloned output to the output widget tracker.
       void clonedOutputs.add(widget);
@@ -1638,7 +1650,7 @@ function addCommands(
       // Remove the output view if the parent notebook is closed.
       current.content.disposed.connect(() => {
         current.context.pathChanged.disconnect(updateCloned);
-        current.content.model.cells.changed.disconnect(updateCloned);
+        cloneListener.dispose();
         widget.dispose();
       });
     },
@@ -2238,7 +2250,7 @@ namespace Private {
         if (!this._cell) {
           this._cell = this._notebook.content.widgets[this._index] as CodeCell;
         }
-        if (!this._cell || this._cell.model.type !== 'code') {
+        if (!this._cell || this._cell.type !== 'code') {
           this.dispose();
           return;
         }
diff --git a/packages/notebook/src/actions.tsx b/packages/notebook/src/actions.tsx
index 3c1733ab633..b03605cbf75 100644
--- a/packages/notebook/src/actions.tsx
+++ b/packages/notebook/src/actions.tsx
@@ -1,8 +1,6 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { KernelMessage } from '@jupyterlab/services';
-
 import {
   IClientSession,
   Clipboard,
@@ -13,14 +11,23 @@ import {
 import { nbformat } from '@jupyterlab/coreutils';
 
 import {
-  ICellModel,
-  ICodeCellModel,
-  CodeCell,
   Cell,
-  MarkdownCell
+  CellData,
+  CodeCell,
+  CodeCellData,
+  ICellData,
+  MarkdownCell,
+  MarkdownCellData,
+  RawCellData
 } from '@jupyterlab/cells';
 
-import { ArrayExt, each, toArray } from '@lumino/algorithm';
+import { DatastoreExt } from '@jupyterlab/datastore';
+
+import { OutputAreaData } from '@jupyterlab/outputarea';
+
+import { KernelMessage } from '@jupyterlab/services';
+
+import { ArrayExt, each } from '@lumino/algorithm';
 
 import { JSONObject } from '@lumino/coreutils';
 
@@ -99,6 +106,7 @@ export namespace NotebookActions {
    * The leading whitespace in the second cell will be removed.
    * If there is no content, two empty cells will be created.
    * Both cells will have the same type as the original cell.
+   * If the cells is are markdown cells, they will be unrendered.
    * This action can be undone.
    */
   export function splitCell(notebook: Notebook): void {
@@ -116,33 +124,51 @@ export namespace NotebookActions {
     const editor = child.editor;
     const position = editor.getCursorPosition();
     const offset = editor.getOffsetAt(position);
-    const orig = child.model.value.text;
+    const orig = child.editor.model.value;
 
     // Create new models to preserve history.
-    const clone0 = Private.cloneCell(nbModel, child.model);
-    const clone1 = Private.cloneCell(nbModel, child.model);
+    const clone0 = Private.cloneCell(nbModel, child);
+    const clone1 = Private.cloneCell(nbModel, child);
+
+    if (child.type === 'code') {
+      OutputAreaData.clear(clone0);
+    }
+    const datastore = nbModel.data.datastore;
+    DatastoreExt.withTransaction(datastore, () => {
+      const text0 = orig
+        .slice(0, offset)
+        .replace(/^\n+/, '')
+        .replace(/\n+$/, '');
+      const text1 = orig
+        .slice(offset)
+        .replace(/^\n+/, '')
+        .replace(/\n+$/, '');
+      DatastoreExt.updateField(
+        datastore,
+        { ...clone0.record, field: 'text' },
+        { index: 0, remove: orig.length, text: text0 }
+      );
+      DatastoreExt.updateField(
+        datastore,
+        { ...clone1.record, field: 'text' },
+        { index: 0, remove: orig.length, text: text1 }
+      );
+      DatastoreExt.updateField(
+        datastore,
+        { ...nbModel.data.record, field: 'cells' },
+        {
+          index,
+          remove: 1,
+          values: [clone0.record.record, clone1.record.record]
+        }
+      );
+    });
 
-    if (clone0.type === 'code') {
-      (clone0 as ICodeCellModel).outputs.clear();
+    if (child.type === 'markdown') {
+      (notebook.widgets[index] as MarkdownCell).rendered = false;
+      (notebook.widgets[index + 1] as MarkdownCell).rendered = false;
     }
-    clone0.value.text = orig
-      .slice(0, offset)
-      .replace(/^\n+/, '')
-      .replace(/\n+$/, '');
-    clone1.value.text = orig
-      .slice(offset)
-      .replace(/^\n+/, '')
-      .replace(/\n+$/, '');
-
-    // Make the changes while preserving history.
-    const cells = nbModel.cells;
-
-    cells.beginCompoundOperation();
-    cells.set(index, clone0);
-    cells.insert(index + 1, clone1);
-    cells.endCompoundOperation();
-
-    notebook.activeCellIndex++;
+    notebook.activeCellIndex = index + 1;
     Private.handleState(notebook, state);
   }
 
@@ -166,57 +192,68 @@ export namespace NotebookActions {
 
     const state = Private.getState(notebook);
     const toMerge: string[] = [];
-    const toDelete: ICellModel[] = [];
+    const toDelete: string[] = [];
     const model = notebook.model;
-    const cells = model.cells;
     const primary = notebook.activeCell;
     const active = notebook.activeCellIndex;
+    // The first active cell in the selection range.
+    const first = ArrayExt.findFirstIndex(notebook.widgets, w =>
+      notebook.isSelectedOrActive(w)
+    );
 
     // Get the cells to merge.
     notebook.widgets.forEach((child, index) => {
       if (notebook.isSelectedOrActive(child)) {
-        toMerge.push(child.model.value.text);
-        if (index !== active) {
-          toDelete.push(child.model);
-        }
+        toMerge.push(child.editor.model.value);
+        toDelete.push(child.data.record.record);
       }
     });
 
     // Check for only a single cell selected.
     if (toMerge.length === 1) {
       // Bail if it is the last cell.
-      if (active === cells.length - 1) {
+      if (active === notebook.widgets.length - 1) {
         return;
       }
 
       // Otherwise merge with the next cell.
-      const cellModel = cells.get(active + 1);
+      const next = notebook.widgets[active + 1];
 
-      toMerge.push(cellModel.value.text);
-      toDelete.push(cellModel);
+      toMerge.push(next.editor.model.value);
+      toDelete.push(next.data.record.record);
     }
 
     notebook.deselectAll();
 
     // Create a new cell for the source to preserve history.
-    const newModel = Private.cloneCell(model, primary.model);
-
-    newModel.value.text = toMerge.join('\n\n');
-    if (newModel.type === 'code') {
-      (newModel as ICodeCellModel).outputs.clear();
-    }
+    const clone = Private.cloneCell(model, primary);
+    const datastore = model.data.datastore;
 
-    // Make the changes while preserving history.
-    cells.beginCompoundOperation();
-    cells.set(active, newModel);
-    toDelete.forEach(cell => {
-      cells.removeValue(cell);
+    DatastoreExt.withTransaction(datastore, () => {
+      const text = toMerge.join('\n\n');
+      if (primary.type === 'code') {
+        OutputAreaData.clear(clone);
+      }
+      DatastoreExt.updateField(
+        datastore,
+        { ...clone.record, field: 'text' },
+        { index: 0, remove: primary.editor.model.value.length, text }
+      );
+      DatastoreExt.updateField(
+        datastore,
+        { ...model.data.record, field: 'cells' },
+        {
+          index: first,
+          remove: toDelete.length,
+          values: [clone.record.record]
+        }
+      );
     });
-    cells.endCompoundOperation();
 
     // If the original cell is a markdown cell, make sure
     // the new cell is unrendered.
-    if (primary instanceof MarkdownCell) {
+    notebook.activeCellIndex = first;
+    if (primary.type === 'markdown') {
       (notebook.activeCell as MarkdownCell).rendered = false;
     }
 
@@ -262,13 +299,19 @@ export namespace NotebookActions {
 
     const state = Private.getState(notebook);
     const model = notebook.model;
-    const cell = model.contentFactory.createCell(
-      notebook.notebookConfig.defaultCell,
-      {}
+    const cellId = model.contentFactory.createCell(
+      notebook.notebookConfig.defaultCell
     );
     const active = notebook.activeCellIndex;
 
-    model.cells.insert(active, cell);
+    const { datastore, record } = model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'cells' },
+        { index: active, remove: 0, values: [cellId] }
+      );
+    });
 
     // Make the newly inserted cell active.
     notebook.activeCellIndex = active;
@@ -294,12 +337,19 @@ export namespace NotebookActions {
 
     const state = Private.getState(notebook);
     const model = notebook.model;
-    const cell = model.contentFactory.createCell(
-      notebook.notebookConfig.defaultCell,
-      {}
+    const active = notebook.activeCellIndex;
+    const cellId = model.contentFactory.createCell(
+      notebook.notebookConfig.defaultCell
     );
 
-    model.cells.insert(notebook.activeCellIndex + 1, cell);
+    const { datastore, record } = model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'cells' },
+        { index: active + 1, remove: 0, values: [cellId] }
+      );
+    });
 
     // Make the newly inserted cell active.
     notebook.activeCellIndex++;
@@ -310,7 +360,7 @@ export namespace NotebookActions {
   /**
    * Move the selected cell(s) down.
    *
-   * @param notebook = The target notebook widget.
+   * @param widget - The target notebook widget.
    */
   export function moveDown(notebook: Notebook): void {
     if (!notebook.model || !notebook.activeCell) {
@@ -318,23 +368,47 @@ export namespace NotebookActions {
     }
 
     const state = Private.getState(notebook);
-    const cells = notebook.model.cells;
     const widgets = notebook.widgets;
 
-    cells.beginCompoundOperation();
-    for (let i = cells.length - 2; i > -1; i--) {
-      if (notebook.isSelectedOrActive(widgets[i])) {
-        if (!notebook.isSelectedOrActive(widgets[i + 1])) {
-          cells.move(i, i + 1);
-          if (notebook.activeCellIndex === i) {
-            notebook.activeCellIndex++;
-          }
-          notebook.select(widgets[i + 1]);
-          notebook.deselect(widgets[i]);
-        }
+    const toMove: string[] = [];
+    const indices: number[] = [];
+    const active = notebook.activeCellIndex;
+    widgets.forEach((cell, index) => {
+      if (notebook.isSelectedOrActive(cell)) {
+        toMove.push(cell.data.record.record);
+        indices.push(index);
       }
+    });
+    if (indices.length && indices[indices.length - 1] === widgets.length) {
+      return;
     }
-    cells.endCompoundOperation();
+    const { datastore, record } = notebook.model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      // Proceed through the toMove list in the reverse direction
+      // so we get the final ordering right.
+      toMove.reverse();
+      indices.reverse();
+      toMove.forEach((id, idx) => {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'cells' },
+          { index: indices[idx], remove: 1, values: [] }
+        );
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'cells' },
+          { index: indices[idx] + 1, remove: 0, values: [id] }
+        );
+      });
+    });
+
+    // Reselect the original cells.
+    widgets.forEach((cell, index) => {
+      if (toMove.indexOf(cell.data.record.record) !== -1) {
+        notebook.select(cell);
+      }
+    });
+    notebook.activeCellIndex = active + 1;
     Private.handleState(notebook, state, true);
   }
 
@@ -349,23 +423,44 @@ export namespace NotebookActions {
     }
 
     const state = Private.getState(notebook);
-    const cells = notebook.model.cells;
     const widgets = notebook.widgets;
 
-    cells.beginCompoundOperation();
-    for (let i = 1; i < cells.length; i++) {
-      if (notebook.isSelectedOrActive(widgets[i])) {
-        if (!notebook.isSelectedOrActive(widgets[i - 1])) {
-          cells.move(i, i - 1);
-          if (notebook.activeCellIndex === i) {
-            notebook.activeCellIndex--;
-          }
-          notebook.select(widgets[i - 1]);
-          notebook.deselect(widgets[i]);
-        }
+    const toMove: string[] = [];
+    const indices: number[] = [];
+    const active = notebook.activeCellIndex;
+    widgets.forEach((cell, index) => {
+      if (notebook.isSelectedOrActive(cell)) {
+        toMove.push(cell.data.record.record);
+        indices.push(index);
       }
+    });
+    if (indices.length && indices[0] === 0) {
+      return;
     }
-    cells.endCompoundOperation();
+    const { datastore, record } = notebook.model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      // Proceed through the toMove list in the forward direction
+      // so we get the final ordering right.
+      toMove.forEach((id, idx) => {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'cells' },
+          { index: indices[idx], remove: 1, values: [] }
+        );
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'cells' },
+          { index: indices[idx] - 1, remove: 0, values: [id] }
+        );
+      });
+    });
+    // Reselect the original cells.
+    widgets.forEach((cell, index) => {
+      if (toMove.indexOf(cell.data.record.record) !== -1) {
+        notebook.select(cell);
+      }
+    });
+    notebook.activeCellIndex = active - 1;
     Private.handleState(notebook, state, true);
   }
 
@@ -391,7 +486,6 @@ export namespace NotebookActions {
     }
 
     const state = Private.getState(notebook);
-
     Private.changeCellType(notebook, value);
     Private.handleState(notebook, state);
   }
@@ -452,12 +546,18 @@ export namespace NotebookActions {
     const model = notebook.model;
 
     if (notebook.activeCellIndex === notebook.widgets.length - 1) {
-      const cell = model.contentFactory.createCell(
-        notebook.notebookConfig.defaultCell,
-        {}
+      const cellId = model.contentFactory.createCell(
+        notebook.notebookConfig.defaultCell
       );
 
-      model.cells.push(cell);
+      const { datastore, record } = model.data;
+      DatastoreExt.withTransaction(datastore, () => {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'cells' },
+          { index: notebook.activeCellIndex + 1, remove: 0, values: [cellId] }
+        );
+      });
       notebook.activeCellIndex++;
       notebook.mode = 'edit';
     } else {
@@ -493,12 +593,18 @@ export namespace NotebookActions {
     const state = Private.getState(notebook);
     const promise = Private.runSelected(notebook, session);
     const model = notebook.model;
-    const cell = model.contentFactory.createCell(
-      notebook.notebookConfig.defaultCell,
-      {}
+    const cellId = model.contentFactory.createCell(
+      notebook.notebookConfig.defaultCell
     );
 
-    model.cells.insert(notebook.activeCellIndex + 1, cell);
+    const { datastore, record } = model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'cells' },
+        { index: notebook.activeCellIndex + 1, remove: 0, values: [cellId] }
+      );
+    });
     notebook.activeCellIndex++;
     notebook.mode = 'edit';
     Private.handleRunState(notebook, state, true);
@@ -548,14 +654,14 @@ export namespace NotebookActions {
     const previousIndex = notebook.activeCellIndex;
     const state = Private.getState(notebook);
     notebook.widgets.forEach((child, index) => {
-      if (child.model.type === 'markdown') {
+      if (child.type === 'markdown') {
         notebook.select(child);
         // This is to make sure that the activeCell
         // does not get executed
         notebook.activeCellIndex = index;
       }
     });
-    if (notebook.activeCell.model.type !== 'markdown') {
+    if (notebook.activeCell.type !== 'markdown') {
       return Promise.resolve(true);
     }
     const promise = Private.runSelected(notebook, session);
@@ -851,56 +957,70 @@ export namespace NotebookActions {
     const newCells = values.map(cell => {
       switch (cell.cell_type) {
         case 'code':
-          return model.contentFactory.createCodeCell({ cell });
+          return model.contentFactory.createCodeCell(
+            cell as nbformat.ICodeCell
+          );
         case 'markdown':
-          return model.contentFactory.createMarkdownCell({ cell });
+          return model.contentFactory.createMarkdownCell(
+            cell as nbformat.IMarkdownCell
+          );
         default:
-          return model.contentFactory.createRawCell({ cell });
+          return model.contentFactory.createRawCell(cell as nbformat.IRawCell);
       }
     });
 
-    const cells = notebook.model.cells;
     let index: number;
+    const { datastore, record } = model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      // Set the starting index of the paste operation depending upon the mode.
+      switch (mode) {
+        case 'below':
+          index = notebook.activeCellIndex;
+          break;
+        case 'above':
+          index = notebook.activeCellIndex - 1;
+          break;
+        case 'replace':
+          // Find the cells to delete.
+          const toDelete: number[] = [];
+
+          notebook.widgets.forEach((child, index) => {
+            const metadata = DatastoreExt.getField(child.data.datastore, {
+              ...child.data.record,
+              field: 'metadata'
+            });
+            const deletable = metadata['deletable'] !== false;
 
-    cells.beginCompoundOperation();
-
-    // Set the starting index of the paste operation depending upon the mode.
-    switch (mode) {
-      case 'below':
-        index = notebook.activeCellIndex;
-        break;
-      case 'above':
-        index = notebook.activeCellIndex - 1;
-        break;
-      case 'replace':
-        // Find the cells to delete.
-        const toDelete: number[] = [];
-
-        notebook.widgets.forEach((child, index) => {
-          const deletable = child.model.metadata.get('deletable') !== false;
+            if (notebook.isSelectedOrActive(child) && deletable) {
+              toDelete.push(index);
+            }
+          });
 
-          if (notebook.isSelectedOrActive(child) && deletable) {
-            toDelete.push(index);
+          // If cells are not deletable, we may not have anything to delete.
+          if (toDelete.length > 0) {
+            // Delete the cells as one undo event.
+            toDelete.reverse().forEach(i => {
+              DatastoreExt.updateField(
+                datastore,
+                { ...record, field: 'cells' },
+                { index: i, remove: 1, values: [] }
+              );
+            });
           }
-        });
-
-        // If cells are not deletable, we may not have anything to delete.
-        if (toDelete.length > 0) {
-          // Delete the cells as one undo event.
-          toDelete.reverse().forEach(i => {
-            cells.remove(i);
-          });
-        }
-        index = toDelete[0];
-        break;
-      default:
-        break;
-    }
+          index = toDelete[0]; // Now the last cell.
+          break;
+        default:
+          break;
+      }
 
-    newCells.forEach(cell => {
-      cells.insert(++index, cell);
+      newCells.forEach(cellId => {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'cells' },
+          { index: ++index, remove: 0, values: [cellId] }
+        );
+      });
     });
-    cells.endCompoundOperation();
 
     notebook.activeCellIndex += newCells.length;
     notebook.deselectAll();
@@ -919,13 +1039,7 @@ export namespace NotebookActions {
     if (!notebook.model || !notebook.activeCell) {
       return;
     }
-
-    const state = Private.getState(notebook);
-
-    notebook.mode = 'command';
-    notebook.model.cells.undo();
-    notebook.deselectAll();
-    Private.handleState(notebook, state);
+    // TODO
   }
 
   /**
@@ -940,13 +1054,7 @@ export namespace NotebookActions {
     if (!notebook.model || !notebook.activeCell) {
       return;
     }
-
-    const state = Private.getState(notebook);
-
-    notebook.mode = 'command';
-    notebook.model.cells.redo();
-    notebook.deselectAll();
-    Private.handleState(notebook, state);
+    // TODO
   }
 
   /**
@@ -995,13 +1103,20 @@ export namespace NotebookActions {
 
     const state = Private.getState(notebook);
 
-    each(notebook.model.cells, (cell: ICodeCellModel, index) => {
+    each(notebook.widgets, (cell: Cell, index) => {
       const child = notebook.widgets[index];
 
       if (notebook.isSelectedOrActive(child) && cell.type === 'code') {
-        cell.outputs.clear();
         (child as CodeCell).outputHidden = false;
-        cell.executionCount = null;
+        const { datastore, record } = cell.data;
+        DatastoreExt.withTransaction(datastore, () => {
+          OutputAreaData.clear(cell.data);
+          DatastoreExt.updateField(
+            datastore,
+            { ...record, field: 'executionCount' },
+            null
+          );
+        });
       }
     });
     Private.handleState(notebook, state);
@@ -1022,13 +1137,17 @@ export namespace NotebookActions {
 
     const state = Private.getState(notebook);
 
-    each(notebook.model.cells, (cell: ICodeCellModel, index) => {
-      const child = notebook.widgets[index];
-
+    each(notebook.widgets, (cell: Cell, index) => {
       if (cell.type === 'code') {
-        cell.outputs.clear();
-        cell.executionCount = null;
-        (child as CodeCell).outputHidden = false;
+        const { datastore, record } = cell.data;
+        DatastoreExt.withTransaction(datastore, () => {
+          OutputAreaData.clear(cell.data);
+          DatastoreExt.updateField(
+            datastore,
+            { ...record, field: 'executionCount' },
+            null
+          );
+        });
       }
     });
     Private.handleState(notebook, state);
@@ -1047,7 +1166,7 @@ export namespace NotebookActions {
     const state = Private.getState(notebook);
 
     notebook.widgets.forEach(cell => {
-      if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {
+      if (notebook.isSelectedOrActive(cell) && cell.type === 'code') {
         cell.inputHidden = true;
       }
     });
@@ -1067,7 +1186,7 @@ export namespace NotebookActions {
     const state = Private.getState(notebook);
 
     notebook.widgets.forEach(cell => {
-      if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {
+      if (notebook.isSelectedOrActive(cell) && cell.type === 'code') {
         cell.inputHidden = false;
       }
     });
@@ -1087,7 +1206,7 @@ export namespace NotebookActions {
     const state = Private.getState(notebook);
 
     notebook.widgets.forEach(cell => {
-      if (cell.model.type === 'code') {
+      if (cell.type === 'code') {
         cell.inputHidden = true;
       }
     });
@@ -1107,7 +1226,7 @@ export namespace NotebookActions {
     const state = Private.getState(notebook);
 
     notebook.widgets.forEach(cell => {
-      if (cell.model.type === 'code') {
+      if (cell.type === 'code') {
         cell.inputHidden = false;
       }
     });
@@ -1127,7 +1246,7 @@ export namespace NotebookActions {
     const state = Private.getState(notebook);
 
     notebook.widgets.forEach(cell => {
-      if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {
+      if (notebook.isSelectedOrActive(cell) && cell.type === 'code') {
         (cell as CodeCell).outputHidden = true;
       }
     });
@@ -1147,7 +1266,7 @@ export namespace NotebookActions {
     const state = Private.getState(notebook);
 
     notebook.widgets.forEach(cell => {
-      if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {
+      if (notebook.isSelectedOrActive(cell) && cell.type === 'code') {
         (cell as CodeCell).outputHidden = false;
       }
     });
@@ -1167,7 +1286,7 @@ export namespace NotebookActions {
     const state = Private.getState(notebook);
 
     notebook.widgets.forEach(cell => {
-      if (cell.model.type === 'code') {
+      if (cell.type === 'code') {
         (cell as CodeCell).outputHidden = true;
       }
     });
@@ -1187,7 +1306,7 @@ export namespace NotebookActions {
     const state = Private.getState(notebook);
 
     notebook.widgets.forEach(cell => {
-      if (cell.model.type === 'code') {
+      if (cell.type === 'code') {
         (cell as CodeCell).outputHidden = false;
       }
     });
@@ -1207,7 +1326,7 @@ export namespace NotebookActions {
     const state = Private.getState(notebook);
 
     notebook.widgets.forEach(cell => {
-      if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {
+      if (notebook.isSelectedOrActive(cell) && cell.type === 'code') {
         (cell as CodeCell).outputsScrolled = true;
       }
     });
@@ -1227,7 +1346,7 @@ export namespace NotebookActions {
     const state = Private.getState(notebook);
 
     notebook.widgets.forEach(cell => {
-      if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {
+      if (notebook.isSelectedOrActive(cell) && cell.type === 'code') {
         (cell as CodeCell).outputsScrolled = false;
       }
     });
@@ -1254,12 +1373,11 @@ export namespace NotebookActions {
     }
 
     const state = Private.getState(notebook);
-    const cells = notebook.model.cells;
 
     level = Math.min(Math.max(level, 1), 6);
     notebook.widgets.forEach((child, index) => {
       if (notebook.isSelectedOrActive(child)) {
-        Private.setMarkdownHeader(cells.get(index), level);
+        Private.setMarkdownHeader(child, level);
       }
     });
     Private.changeCellType(notebook, 'markdown');
@@ -1277,14 +1395,17 @@ export namespace NotebookActions {
    * No dialog will be presented if the notebook is already trusted.
    */
   export function trust(notebook: Notebook): Promise<void> {
-    if (!notebook.model) {
+    const model = notebook.model;
+    if (!model) {
       return Promise.resolve();
     }
     // Do nothing if already trusted.
-
-    const cells = toArray(notebook.model.cells);
-    const trusted = cells.every(cell => cell.trusted);
-
+    const trusted = notebook.widgets.every(cell =>
+      DatastoreExt.getField(cell.data.datastore, {
+        ...cell.data.record,
+        field: 'trusted'
+      })
+    );
     if (trusted) {
       return showDialog({
         body: 'Notebook is already trusted',
@@ -1298,8 +1419,15 @@ export namespace NotebookActions {
       buttons: [Dialog.cancelButton(), Dialog.warnButton()]
     }).then(result => {
       if (result.button.accept) {
-        cells.forEach(cell => {
-          cell.trusted = true;
+        DatastoreExt.withTransaction(model.data.datastore, () => {
+          notebook.widgets.forEach(cell => {
+            DatastoreExt.updateField(
+              cell.data.datastore,
+              { ...cell.data.record, field: 'trusted' },
+              true
+            );
+            OutputAreaData.setTrusted(cell.data, true);
+          });
         });
       }
     });
@@ -1385,19 +1513,28 @@ namespace Private {
    */
   export function cloneCell(
     model: INotebookModel,
-    cell: ICellModel
-  ): ICellModel {
-    switch (cell.type) {
+    cell: Cell
+  ): ICellData.DataLocation {
+    let id = '';
+    const { type, data } = cell;
+    switch (type) {
       case 'code':
-        // TODO why isn't modeldb or id passed here?
-        return model.contentFactory.createCodeCell({ cell: cell.toJSON() });
+        id = model.contentFactory.createCodeCell(CodeCellData.toJSON(data));
+        break;
       case 'markdown':
-        // TODO why isn't modeldb or id passed here?
-        return model.contentFactory.createMarkdownCell({ cell: cell.toJSON() });
+        id = model.contentFactory.createMarkdownCell(
+          MarkdownCellData.toJSON(data)
+        );
+        break;
       default:
-        // TODO why isn't modeldb or id passed here?
-        return model.contentFactory.createRawCell({ cell: cell.toJSON() });
+        id = model.contentFactory.createRawCell(RawCellData.toJSON(data));
+        break;
     }
+    return {
+      datastore: data.datastore,
+      record: { ...data.record, record: id },
+      outputs: data.outputs
+    };
   }
 
   /**
@@ -1438,10 +1575,11 @@ namespace Private {
         if (reason.message === 'KernelReplyNotOK') {
           selected.map(cell => {
             // Remove '*' prompt from cells that didn't execute
-            if (
-              cell.model.type === 'code' &&
-              (cell as CodeCell).model.executionCount == null
-            ) {
+            const executionCount = DatastoreExt.getField(cell.data.datastore, {
+              ...cell.data.record,
+              field: 'executionCount'
+            });
+            if (cell.type === 'code' && executionCount == null) {
               cell.setPrompt('');
             }
           });
@@ -1458,12 +1596,12 @@ namespace Private {
   /**
    * Run a cell.
    */
-  function runCell(
+  export function runCell(
     notebook: Notebook,
     cell: Cell,
     session?: IClientSession
   ): Promise<boolean> {
-    switch (cell.model.type) {
+    switch (cell.type) {
       case 'markdown':
         (cell as MarkdownCell).rendered = true;
         cell.inputHidden = false;
@@ -1514,7 +1652,7 @@ namespace Private {
               return ran;
             });
         }
-        (cell.model as ICodeCellModel).executionCount = null;
+        // (cell.model as ICodeCellData).executionCount = null;
         break;
       default:
         break;
@@ -1548,21 +1686,27 @@ namespace Private {
     const replace = (setNextInput as any).replace;
 
     if (replace) {
-      cell.model.value.text = text;
+      cell.editor.model.value = text;
       return;
     }
 
     // Create a new code cell and add as the next cell.
-    const newCell = notebook.model.contentFactory.createCodeCell({});
-    const cells = notebook.model.cells;
-    const index = ArrayExt.firstIndexOf(toArray(cells), cell.model);
-
-    newCell.value.text = text;
-    if (index === -1) {
-      cells.push(newCell);
-    } else {
-      cells.insert(index + 1, newCell);
-    }
+    const newCell = notebook.model.contentFactory.createCodeCell();
+    let index = ArrayExt.firstIndexOf(notebook.widgets, cell);
+    index = index === -1 ? notebook.widgets.length : index;
+    const { datastore, record, cells } = notebook.model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'cells' },
+        { index, remove: 0, values: [newCell] }
+      );
+      DatastoreExt.updateField(
+        datastore,
+        { ...cells, record: newCell, field: 'text' },
+        { index: 0, remove: 0, text }
+      );
+    });
   }
 
   /**
@@ -1585,7 +1729,7 @@ namespace Private {
 
     let data = notebook.widgets
       .filter(cell => notebook.isSelectedOrActive(cell))
-      .map(cell => cell.model.toJSON())
+      .map(cell => CellData.toJSON(cell.data))
       .map(cellJSON => {
         if ((cellJSON.metadata as JSONObject).deletable !== undefined) {
           delete (cellJSON.metadata as JSONObject).deletable;
@@ -1620,43 +1764,50 @@ namespace Private {
     value: nbformat.CellType
   ): void {
     const model = notebook.model;
-    const cells = model.cells;
+    const index = notebook.activeCellIndex;
 
-    cells.beginCompoundOperation();
-    notebook.widgets.forEach((child, index) => {
-      if (!notebook.isSelectedOrActive(child)) {
-        return;
-      }
-      if (child.model.type !== value) {
-        const cell = child.model.toJSON();
-        let newCell: ICellModel;
-
-        switch (value) {
-          case 'code':
-            newCell = model.contentFactory.createCodeCell({ cell });
-            break;
-          case 'markdown':
-            newCell = model.contentFactory.createMarkdownCell({ cell });
-            if (child.model.type === 'code') {
-              newCell.trusted = false;
-            }
-            break;
-          default:
-            newCell = model.contentFactory.createRawCell({ cell });
-            if (child.model.type === 'code') {
-              newCell.trusted = false;
-            }
+    const { datastore, record } = model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      notebook.widgets.forEach((child, index) => {
+        if (!notebook.isSelectedOrActive(child)) {
+          return;
         }
-        cells.set(index, newCell);
-      }
-      if (value === 'markdown') {
-        // Fetch the new widget and unrender it.
-        child = notebook.widgets[index];
-        (child as MarkdownCell).rendered = false;
-      }
+        if (child.type !== value) {
+          let cellId = '';
+          let cell = CellData.toJSON(child.data);
+          if (cell.type === 'code') {
+            // When we convert to another cell type,
+            // make sure it is flagged as untrusted.
+            cell['metadata']['trusted'] = false;
+          }
+          switch (value) {
+            case 'code':
+              cellId = model.contentFactory.createCodeCell(
+                cell as nbformat.ICodeCell
+              );
+              break;
+            case 'markdown':
+              cellId = model.contentFactory.createMarkdownCell(
+                cell as nbformat.IMarkdownCell
+              );
+              break;
+            default:
+              cellId = model.contentFactory.createRawCell(
+                cell as nbformat.IRawCell
+              );
+              break;
+          }
+          DatastoreExt.updateField(
+            datastore,
+            { ...record, field: 'cells' },
+            { index, remove: 1, values: [cellId] }
+          );
+        }
+      });
     });
-    cells.endCompoundOperation();
+    // TODO: unrender the new markdown cells.
     notebook.deselectAll();
+    notebook.activeCellIndex = index;
   }
 
   /**
@@ -1672,41 +1823,51 @@ namespace Private {
    */
   export function deleteCells(notebook: Notebook): void {
     const model = notebook.model;
-    const cells = model.cells;
     const toDelete: number[] = [];
 
     notebook.mode = 'command';
 
     // Find the cells to delete.
     notebook.widgets.forEach((child, index) => {
-      const deletable = child.model.metadata.get('deletable') !== false;
+      const { datastore, record } = child.data;
+      const metadata = DatastoreExt.getField(datastore, {
+        ...record,
+        field: 'metadata'
+      });
+      const deletable = metadata['deletable'] !== false;
 
       if (notebook.isSelectedOrActive(child) && deletable) {
         toDelete.push(index);
-        notebook.model.deletedCells.push(child.model.id);
+        notebook.model.deletedCells.push(child.data.record.record);
       }
     });
 
     // If cells are not deletable, we may not have anything to delete.
     if (toDelete.length > 0) {
-      // Delete the cells as one undo event.
-      cells.beginCompoundOperation();
-      // Delete cells in reverse order to maintain the correct indices.
-      toDelete.reverse().forEach(index => {
-        cells.remove(index);
+      const { datastore, record } = model.data;
+      DatastoreExt.withTransaction(datastore, () => {
+        // Delete cells in reverse order to maintain the correct indices.
+        toDelete.reverse().forEach(index => {
+          DatastoreExt.updateField(
+            datastore,
+            { ...record, field: 'cells' },
+            { index, remove: 1, values: [] }
+          );
+        });
+        // Add a new cell if the notebook is empty. This is done
+        // within the compound operation to make the deletion of
+        // a notebook's last cell undoable.
+        if (toDelete.length === notebook.widgets.length) {
+          const cellId = model.contentFactory.createCell(
+            notebook.notebookConfig.defaultCell
+          );
+          DatastoreExt.updateField(
+            datastore,
+            { ...record, field: 'cells' },
+            { index: 0, remove: 0, values: [cellId] }
+          );
+        }
       });
-      // Add a new cell if the notebook is empty. This is done
-      // within the compound operation to make the deletion of
-      // a notebook's last cell undoable.
-      if (!cells.length) {
-        cells.push(
-          model.contentFactory.createCell(
-            notebook.notebookConfig.defaultCell,
-            {}
-          )
-        );
-      }
-      cells.endCompoundOperation();
 
       // Select the *first* interior cell not deleted or the cell
       // *after* the last selected cell.
@@ -1725,9 +1886,9 @@ namespace Private {
   /**
    * Set the markdown header level of a cell.
    */
-  export function setMarkdownHeader(cell: ICellModel, level: number) {
+  export function setMarkdownHeader(cell: Cell, level: number) {
     // Remove existing header or leading white space.
-    let source = cell.value.text;
+    let source = cell.editor.model.value;
     const regex = /^(#+\s*)|^(\s*)/;
     const newHeader = Array(level + 1).join('#') + ' ';
     const matches = regex.exec(source);
@@ -1735,6 +1896,6 @@ namespace Private {
     if (matches) {
       source = source.slice(matches[0].length);
     }
-    cell.value.text = newHeader + source;
+    cell.editor.model.value = newHeader + source;
   }
 }

diff --git a/packages/notebook/src/default-toolbar.tsx b/packages/notebook/src/default-toolbar.tsx
index 8e1b4e634a5..1651c31555b 100644
--- a/packages/notebook/src/default-toolbar.tsx
+++ b/packages/notebook/src/default-toolbar.tsx
@@ -77,7 +77,7 @@ export namespace ToolbarItems {
    */
   export function createSaveButton(panel: NotebookPanel): Widget {
     function onClick() {
-      if (panel.context.model.readOnly) {
+      if (panel.context.readOnly) {
         return showDialog({
           title: 'Cannot Save',
           body: 'Document is read-only',
@@ -270,11 +270,11 @@ export class CellTypeSwitcher extends ReactWidget {
   render() {
     let value = '-';
     if (this._notebook.activeCell) {
-      value = this._notebook.activeCell.model.type;
+      value = this._notebook.activeCell.type;
     }
     for (let widget of this._notebook.widgets) {
       if (this._notebook.isSelectedOrActive(widget)) {
-        if (widget.model.type !== value) {
+        if (widget.type !== value) {
           value = '-';
           break;
         }
diff --git a/packages/notebook/src/model.ts b/packages/notebook/src/model.ts
index 40206731324..64d1a1aebe5 100644
--- a/packages/notebook/src/model.ts
+++ b/packages/notebook/src/model.ts
@@ -1,42 +1,36 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { DocumentModel, DocumentRegistry } from '@jupyterlab/docregistry';
+import { showDialog, Dialog } from '@jupyterlab/apputils';
+
+import { DatastoreExt } from '@jupyterlab/datastore';
+
+import { DocumentRegistry } from '@jupyterlab/docregistry';
 
 import {
-  ICellModel,
-  ICodeCellModel,
-  IRawCellModel,
-  IMarkdownCellModel,
-  CodeCellModel,
-  RawCellModel,
-  MarkdownCellModel,
-  CellModel
+  CellData,
+  CodeCellData,
+  ICellData,
+  RawCellData,
+  MarkdownCellData
 } from '@jupyterlab/cells';
 
 import { nbformat } from '@jupyterlab/coreutils';
 
-import { UUID } from '@lumino/coreutils';
+import { IOutputData, OutputData } from '@jupyterlab/rendermime';
 
-import {
-  IObservableJSON,
-  IObservableUndoableList,
-  IObservableList,
-  IModelDB
-} from '@jupyterlab/observables';
+import { ReadonlyJSONObject, UUID } from '@lumino/coreutils';
 
-import { CellList } from './celllist';
-import { showDialog, Dialog } from '@jupyterlab/apputils';
+import { Datastore } from '@lumino/datastore';
+
+import { ISignal, Signal } from '@lumino/signaling';
+
+import { INotebookData, NotebookData } from './data';
 
 /**
  * The definition of a model object for a notebook widget.
  */
 export interface INotebookModel extends DocumentRegistry.IModel {
-  /**
-   * The list of cells in the notebook.
-   */
-  readonly cells: IObservableUndoableList<ICellModel>;
-
   /**
    * The cell model factory for the notebook.
    */
@@ -55,7 +49,12 @@ export interface INotebookModel extends DocumentRegistry.IModel {
   /**
    * The metadata associated with the notebook.
    */
-  readonly metadata: IObservableJSON;
+  readonly metadata: ReadonlyJSONObject;
+
+  /**
+   * The location of the notebook data in a datastore.
+   */
+  readonly data: INotebookData.DataLocation;
 
   /**
    * The array of deleted cells since the notebook was last run.
@@ -66,25 +65,51 @@ export interface INotebookModel extends DocumentRegistry.IModel {
 /**
  * An implementation of a notebook Model.
  */
-export class NotebookModel extends DocumentModel implements INotebookModel {
+export class NotebookModel implements INotebookModel {
   /**
    * Construct a new notebook model.
    */
   constructor(options: NotebookModel.IOptions = {}) {
-    super(options.languagePreference, options.modelDB);
     let factory = options.contentFactory || NotebookModel.defaultContentFactory;
-    this.contentFactory = factory.clone(this.modelDB.view('cells'));
-    this._cells = new CellList(this.modelDB, this.contentFactory);
-    this._cells.changed.connect(this._onCellsChanged, this);
-
-    // Handle initial metadata.
-    let metadata = this.modelDB.createMap('metadata');
-    if (!metadata.has('language_info')) {
-      let name = options.languagePreference || '';
-      metadata.set('language_info', { name });
+    if (!options.data) {
+      const datastore = (this._store = NotebookData.createStore());
+      this.data = {
+        datastore,
+        record: {
+          schema: NotebookData.SCHEMA,
+          record: 'data'
+        },
+        cells: {
+          schema: CellData.SCHEMA
+        },
+        outputs: {
+          schema: OutputData.SCHEMA
+        }
+      };
+    } else {
+      this.data = options.data;
     }
-    this._ensureMetadata();
-    metadata.changed.connect(this.triggerContentChange, this);
+    const { datastore, record } = this.data;
+    if (!DatastoreExt.getRecord(datastore, record)) {
+      this.isPrepopulated = false;
+      // Handle initialization of data.
+      DatastoreExt.withTransaction(datastore, () => {
+        DatastoreExt.updateRecord(datastore, record, {
+          nbformat: nbformat.MAJOR_VERSION,
+          nbformatMinor: nbformat.MINOR_VERSION
+        });
+        this._ensureMetadata();
+      });
+    } else {
+      this.isPrepopulated = true;
+    }
+
+    // Get a content factory that will create new content in the notebook
+    // data location.
+    this.contentFactory = factory.clone(this.data);
+
+    // Trigger a content change when appropriate.
+    datastore.changed.connect(this._onGenericChange, this);
     this._deletedCells = [];
   }
 
@@ -94,38 +119,52 @@ export class NotebookModel extends DocumentModel implements INotebookModel {
   readonly contentFactory: NotebookModel.IContentFactory;
 
   /**
-   * The metadata associated with the notebook.
+   * The location of the data in the notebook.
    */
-  get metadata(): IObservableJSON {
-    return this.modelDB.get('metadata') as IObservableJSON;
-  }
+  readonly data: INotebookData.DataLocation;
 
   /**
-   * Get the observable list of notebook cells.
+   * Whether the notebook model is collaborative.
    */
-  get cells(): IObservableUndoableList<ICellModel> {
-    return this._cells;
+  readonly isCollaborative = true;
+
+  /**
+   * Whether the notebook model comes prepopulated.
+   */
+  readonly isPrepopulated: boolean;
+
+  /**
+   * The metadata associated with the notebook.
+   */
+  get metadata(): ReadonlyJSONObject {
+    const { datastore, record } = this.data;
+    return DatastoreExt.getField(datastore, { ...record, field: 'metadata' });
   }
 
   /**
    * The major version number of the nbformat.
    */
   get nbformat(): number {
-    return this._nbformat;
+    const { datastore, record } = this.data;
+    return DatastoreExt.getField(datastore, { ...record, field: 'nbformat' });
   }
 
   /**
    * The minor version number of the nbformat.
    */
   get nbformatMinor(): number {
-    return this._nbformatMinor;
+    const { datastore, record } = this.data;
+    return DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'nbformatMinor'
+    });
   }
 
   /**
    * The default kernel name of the document.
    */
   get defaultKernelName(): string {
-    let spec = this.metadata.get('kernelspec') as nbformat.IKernelspecMetadata;
+    let spec = this.metadata['kernelspec'] as nbformat.IKernelspecMetadata;
     return spec ? spec.name : '';
   }
 
@@ -136,28 +175,47 @@ export class NotebookModel extends DocumentModel implements INotebookModel {
     return this._deletedCells;
   }
 
+  /**
+   * A signal emitted when the document content changes.
+   */
+  get contentChanged(): ISignal<this, void> {
+    return this._contentChanged;
+  }
+
+  /**
+   * The default kernel name of the document.
+   *
+   * #### Notes
+   * This is a read-only property.
+   */
+
   /**
    * The default kernel language of the document.
    */
   get defaultKernelLanguage(): string {
-    let info = this.metadata.get(
-      'language_info'
-    ) as nbformat.ILanguageInfoMetadata;
+    let info = this.metadata['language_info'] as nbformat.ILanguageInfoMetadata;
     return info ? info.name : '';
   }
 
+  /**
+   * Whether the model has been disposed.
+   */
+  get isDisposed(): boolean {
+    return this._isDisposed;
+  }
+
   /**
    * Dispose of the resources held by the model.
    */
   dispose(): void {
     // Do nothing if already disposed.
-    if (this.cells === null) {
+    if (this._isDisposed) {
       return;
     }
-    let cells = this.cells;
-    this._cells = null;
-    cells.dispose();
-    super.dispose();
+    if (this._store) {
+      this._store.dispose();
+      this._store = null;
+    }
   }
 
   /**
@@ -175,27 +233,34 @@ export class NotebookModel extends DocumentModel implements INotebookModel {
    */
   fromString(value: string): void {
     this.fromJSON(JSON.parse(value));
+    this._contentChanged.emit();
   }
 
   /**
    * Serialize the model to JSON.
    */
   toJSON(): nbformat.INotebookContent {
-    let cells: nbformat.ICell[] = [];
-    for (let i = 0; i < this.cells.length; i++) {
-      let cell = this.cells.get(i);
-      cells.push(cell.toJSON());
+    let cellsJSON: nbformat.ICell[] = [];
+    let { datastore, record, cells, outputs } = this.data;
+    let data = DatastoreExt.getRecord(datastore, record);
+    for (let i = 0; i < data.cells.length; i++) {
+      let cell = CellData.toJSON({
+        datastore,
+        record: { ...cells, record: data.cells[i] },
+        outputs
+      });
+      cellsJSON.push(cell);
     }
     this._ensureMetadata();
     let metadata = Object.create(null) as nbformat.INotebookMetadata;
-    for (let key of this.metadata.keys()) {
-      metadata[key] = JSON.parse(JSON.stringify(this.metadata.get(key)));
+    for (let key of Object.keys(this.metadata)) {
+      metadata[key] = JSON.parse(JSON.stringify(this.metadata[key]));
     }
     return {
       metadata,
-      nbformat_minor: this._nbformatMinor,
-      nbformat: this._nbformat,
-      cells
+      nbformat_minor: data.nbformatMinor,
+      nbformat: data.nbformat,
+      cells: cellsJSON
     };
   }
 
@@ -206,131 +271,181 @@ export class NotebookModel extends DocumentModel implements INotebookModel {
    * Should emit a [contentChanged] signal.
    */
   fromJSON(value: nbformat.INotebookContent): void {
-    let cells: ICellModel[] = [];
-    let factory = this.contentFactory;
-    for (let cell of value.cells) {
-      switch (cell.cell_type) {
-        case 'code':
-          cells.push(factory.createCodeCell({ cell }));
-          break;
-        case 'markdown':
-          cells.push(factory.createMarkdownCell({ cell }));
-          break;
-        case 'raw':
-          cells.push(factory.createRawCell({ cell }));
-          break;
-        default:
-          continue;
+    let { datastore, record, cells, outputs } = this.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      const cellIds: string[] = [];
+      for (let cell of value.cells) {
+        const id = UUID.uuid4();
+        cellIds.push(id);
+        const loc = {
+          datastore,
+          record: { ...cells, record: id },
+          outputs
+        };
+        switch (cell.cell_type) {
+          case 'code':
+            CodeCellData.fromJSON(loc, cell as nbformat.ICodeCell);
+            break;
+          case 'markdown':
+            MarkdownCellData.fromJSON(loc, cell as nbformat.IMarkdownCell);
+            break;
+          case 'raw':
+            RawCellData.fromJSON(loc, cell as nbformat.IRawCell);
+            break;
+          default:
+            continue;
+        }
       }
-    }
-    this.cells.beginCompoundOperation();
-    this.cells.clear();
-    this.cells.pushAll(cells);
-    this.cells.endCompoundOperation();
-
-    let oldValue = 0;
-    let newValue = 0;
-    this._nbformatMinor = nbformat.MINOR_VERSION;
-    this._nbformat = nbformat.MAJOR_VERSION;
-    const origNbformat = value.metadata.orig_nbformat;
-
-    if (value.nbformat !== this._nbformat) {
-      oldValue = this._nbformat;
-      this._nbformat = newValue = value.nbformat;
-      this.triggerStateChange({ name: 'nbformat', oldValue, newValue });
-    }
-    if (value.nbformat_minor > this._nbformatMinor) {
-      oldValue = this._nbformatMinor;
-      this._nbformatMinor = newValue = value.nbformat_minor;
-      this.triggerStateChange({ name: 'nbformatMinor', oldValue, newValue });
-    }
-
-    // Alert the user if the format changes.
-    if (origNbformat !== undefined && this._nbformat !== origNbformat) {
-      const newer = this._nbformat > origNbformat;
-      const msg = `This notebook has been converted from ${
-        newer ? 'an older' : 'a newer'
-      } notebook format (v${origNbformat}) to the current notebook format (v${
-        this._nbformat
-      }). The next time you save this notebook, the current notebook format (v${
-        this._nbformat
-      }) will be used. ${
-        newer
-          ? 'Older versions of Jupyter may not be able to read the new format.'
-          : 'Some features of the original notebook may not be available.'
-      }  To preserve the original format version, close the notebook without saving it.`;
-      void showDialog({
-        title: 'Notebook converted',
-        body: msg,
-        buttons: [Dialog.okButton()]
+      const cellLoc: DatastoreExt.FieldLocation<
+        INotebookData.Schema,
+        'cells'
+      > = { ...record, field: 'cells' };
+      const oldCells = DatastoreExt.getField(datastore, cellLoc);
+      DatastoreExt.updateField(datastore, cellLoc, {
+        index: 0,
+        remove: oldCells.length,
+        values: cellIds
       });
-    }
+      oldCells.forEach(cell =>
+        CellData.clear({
+          datastore,
+          outputs: this.data.outputs,
+          record: { ...this.data.cells, record: cell }
+        })
+      );
+
+      let newValue = 0;
+      const origNbformat = value.metadata.orig_nbformat;
+
+      if (value.nbformat !== nbformat.MAJOR_VERSION) {
+        newValue = value.nbformat;
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'nbformat' },
+          newValue
+        );
+      }
+      if (value.nbformat_minor > nbformat.MINOR_VERSION) {
+        newValue = value.nbformat_minor;
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'nbformatMinor' },
+          newValue
+        );
+      }
+
+      // Alert the user if the format changes.
+      if (origNbformat !== undefined && newValue !== origNbformat) {
+        const newer = newValue > origNbformat;
+        const msg = `This notebook has been converted from ${
+          newer ? 'an older' : 'a newer'
+        } notebook format (v${origNbformat}) to the current notebook format (v${newValue}). The next time you save this notebook, the current notebook format (v${newValue}) will be used. ${
+          newer
+            ? 'Older versions of Jupyter may not be able to read the new format.'
+            : 'Some features of the original notebook may not be available.'
+        }  To preserve the original format version, close the notebook without saving it.`;
+        void showDialog({
+          title: 'Notebook converted',
+          body: msg,
+          buttons: [Dialog.okButton()]
+        });
+      }
 
-    // Update the metadata.
-    this.metadata.clear();
-    let metadata = value.metadata;
-    for (let key in metadata) {
+      // Update the metadata.
+      let metadata = { ...value.metadata };
       // orig_nbformat is not intended to be stored per spec.
-      if (key === 'orig_nbformat') {
-        continue;
+      delete metadata['orig_nbformat'];
+      let oldMetadata = { ...this.metadata };
+      for (let key in oldMetadata) {
+        oldMetadata[key] = null;
       }
-      this.metadata.set(key, metadata[key]);
-    }
-    this._ensureMetadata();
-    this.dirty = true;
+      let update = { ...oldMetadata, ...metadata };
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'metadata' },
+        update
+      );
+      this._ensureMetadata();
+    });
   }
 
   /**
    * Initialize the model with its current state.
    */
   initialize(): void {
-    super.initialize();
-    this.cells.clearUndo();
-  }
-
-  /**
-   * Handle a change in the cells list.
-   */
-  private _onCellsChanged(
-    list: IObservableList<ICellModel>,
-    change: IObservableList.IChangedArgs<ICellModel>
-  ): void {
-    switch (change.type) {
-      case 'add':
-        change.newValues.forEach(cell => {
-          cell.contentChanged.connect(this.triggerContentChange, this);
-        });
-        break;
-      case 'remove':
-        break;
-      case 'set':
-        change.newValues.forEach(cell => {
-          cell.contentChanged.connect(this.triggerContentChange, this);
-        });
-        break;
-      default:
-        break;
-    }
-    this.triggerContentChange();
+    /* No-op */
   }
 
   /**
    * Make sure we have the required metadata fields.
    */
   private _ensureMetadata(): void {
-    let metadata = this.metadata;
-    if (!metadata.has('language_info')) {
-      metadata.set('language_info', { name: '' });
+    const { datastore, record } = this.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      let metadata = { ...this.metadata };
+      metadata['language_info'] = metadata['language_info'] || { name: '' };
+      metadata['kernelspec'] = metadata['kernelspec'] || {
+        name: '',
+        display_name: ''
+      };
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'metadata' },
+        metadata
+      );
+    });
+  }
+
+  private _onGenericChange(
+    sender: Datastore,
+    args: Datastore.IChangedArgs
+  ): void {
+    const change = args.change;
+    // Grab the changes for the schemas we are interested in.
+    const recordChange = change[this.data.record.schema.id];
+    const cellChange = change[this.data.cells.schema.id];
+    const outputChange = change[this.data.outputs.schema.id];
+    // If there was a change to any of the top-level items, emit a
+    // contentChanged signal.
+    if (recordChange) {
+      this._contentChanged.emit();
+      return;
     }
-    if (!metadata.has('kernelspec')) {
-      metadata.set('kernelspec', { name: '', display_name: '' });
+    // If there were any changes to the outputs, emit a contentChanged signal.
+    // TODO: maybe filter for outputs that are definitely in a current cell.
+    if (outputChange) {
+      this._contentChanged.emit();
+      return;
+    }
+
+    // Check the cells for changes, ignoring cursors and mimetype.
+    const { datastore, record } = this.data;
+    const cells = DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'cells'
+    });
+    // Check the cell changes to see if some should be considered content.
+    if (
+      Object.keys(cellChange).some(cell => {
+        return (
+          // Only count cells that are currently in the notebook.
+          cells.indexOf(cell) !== -1 &&
+          Object.keys(cellChange[cell]).some(field => {
+            // Only count fields that are content fields.
+            return Private.CELL_CONTENT_FIELDS.indexOf(field) !== -1;
+          })
+        );
+      })
+    ) {
+      this._contentChanged.emit();
+      return;
     }
   }
 
-  private _cells: CellList;
-  private _nbformat = nbformat.MAJOR_VERSION;
-  private _nbformatMinor = nbformat.MINOR_VERSION;
   private _deletedCells: string[];
+  private _store: Datastore | null = null;
+  private _isDisposed = false;
+  private _contentChanged = new Signal<this, void>(this);
 }
 
 /**
@@ -354,25 +469,15 @@ export namespace NotebookModel {
     contentFactory?: IContentFactory;
 
     /**
-     * A modelDB for storing notebook data.
+     * The location for data stored in the notebook model.
      */
-    modelDB?: IModelDB;
+    data?: INotebookData.DataLocation;
   }
 
   /**
    * A factory for creating notebook model content.
    */
   export interface IContentFactory {
-    /**
-     * The factory for output area models.
-     */
-    readonly codeCellContentFactory: CodeCellModel.IContentFactory;
-
-    /**
-     * The IModelDB in which to put data for the notebook model.
-     */
-    modelDB: IModelDB;
-
     /**
      * Create a new cell by cell type.
      *
@@ -384,7 +489,7 @@ export namespace NotebookModel {
      * This method is intended to be a convenience method to programmaticaly
      * call the other cell creation methods in the factory.
      */
-    createCell(type: nbformat.CellType, opts: CellModel.IOptions): ICellModel;
+    createCell(type: nbformat.CellType, cell?: nbformat.IBaseCell): string;
 
     /**
      * Create a new code cell.
@@ -394,7 +499,7 @@ export namespace NotebookModel {
      * @returns A new code cell. If a source cell is provided, the
      *   new cell will be initialized with the data from the source.
      */
-    createCodeCell(options: CodeCellModel.IOptions): ICodeCellModel;
+    createCodeCell(cell?: nbformat.ICodeCell): string;
 
     /**
      * Create a new markdown cell.
@@ -404,7 +509,7 @@ export namespace NotebookModel {
      * @returns A new markdown cell. If a source cell is provided, the
      *   new cell will be initialized with the data from the source.
      */
-    createMarkdownCell(options: CellModel.IOptions): IMarkdownCellModel;
+    createMarkdownCell(cell?: nbformat.IMarkdownCell): string;
 
     /**
      * Create a new raw cell.
@@ -414,12 +519,12 @@ export namespace NotebookModel {
      * @returns A new raw cell. If a source cell is provided, the
      *   new cell will be initialized with the data from the source.
      */
-    createRawCell(options: CellModel.IOptions): IRawCellModel;
+    createRawCell(cell?: nbformat.IRawCell): string;
 
     /**
-     * Clone the content factory with a new IModelDB.
+     * Clone the content factory with a data location.
      */
-    clone(modelDB: IModelDB): IContentFactory;
+    clone(data: ContentFactory.DataLocation): IContentFactory;
   }
 
   /**
@@ -430,21 +535,9 @@ export namespace NotebookModel {
      * Create a new cell model factory.
      */
     constructor(options: ContentFactory.IOptions) {
-      this.codeCellContentFactory =
-        options.codeCellContentFactory || CodeCellModel.defaultContentFactory;
-      this.modelDB = options.modelDB;
+      this._data = options.data;
     }
 
-    /**
-     * The factory for code cell content.
-     */
-    readonly codeCellContentFactory: CodeCellModel.IContentFactory;
-
-    /**
-     * The IModelDB in which to put the notebook data.
-     */
-    readonly modelDB: IModelDB | undefined;
-
     /**
      * Create a new cell by cell type.
      *
@@ -456,17 +549,17 @@ export namespace NotebookModel {
      * This method is intended to be a convenience method to programmaticaly
      * call the other cell creation methods in the factory.
      */
-    createCell(type: nbformat.CellType, opts: CellModel.IOptions): ICellModel {
+    createCell(type: nbformat.CellType, cell?: nbformat.IBaseCell): string {
       switch (type) {
         case 'code':
-          return this.createCodeCell(opts);
+          return this.createCodeCell(cell as nbformat.ICodeCell);
           break;
         case 'markdown':
-          return this.createMarkdownCell(opts);
+          return this.createMarkdownCell(cell as nbformat.IMarkdownCell);
           break;
         case 'raw':
         default:
-          return this.createRawCell(opts);
+          return this.createRawCell(cell as nbformat.IRawCell);
       }
     }
 
@@ -475,22 +568,18 @@ export namespace NotebookModel {
      *
      * @param source - The data to use for the original source data.
      *
-     * @returns A new code cell. If a source cell is provided, the
-     *   new cell will be initialized with the data from the source.
-     *   If the contentFactory is not provided, the instance
-     *   `codeCellContentFactory` will be used.
+     * @returns A cell id.
      */
-    createCodeCell(options: CodeCellModel.IOptions): ICodeCellModel {
-      if (options.contentFactory) {
-        options.contentFactory = this.codeCellContentFactory;
-      }
-      if (this.modelDB) {
-        if (!options.id) {
-          options.id = UUID.uuid4();
-        }
-        options.modelDB = this.modelDB.view(options.id);
-      }
-      return new CodeCellModel(options);
+    createCodeCell(value?: nbformat.ICodeCell): string {
+      const id = UUID.uuid4();
+      const { datastore, cells, outputs } = this._data;
+      const loc = {
+        datastore,
+        record: { ...cells, record: id },
+        outputs
+      };
+      CodeCellData.fromJSON(loc, value);
+      return id;
     }
 
     /**
@@ -501,14 +590,16 @@ export namespace NotebookModel {
      * @returns A new markdown cell. If a source cell is provided, the
      *   new cell will be initialized with the data from the source.
      */
-    createMarkdownCell(options: CellModel.IOptions): IMarkdownCellModel {
-      if (this.modelDB) {
-        if (!options.id) {
-          options.id = UUID.uuid4();
-        }
-        options.modelDB = this.modelDB.view(options.id);
-      }
-      return new MarkdownCellModel(options);
+    createMarkdownCell(value?: nbformat.IMarkdownCell): string {
+      const id = UUID.uuid4();
+      const { datastore, cells, outputs } = this._data;
+      const loc = {
+        datastore,
+        record: { ...cells, record: id },
+        outputs
+      };
+      MarkdownCellData.fromJSON(loc, value);
+      return id;
     }
 
     /**
@@ -519,25 +610,28 @@ export namespace NotebookModel {
      * @returns A new raw cell. If a source cell is provided, the
      *   new cell will be initialized with the data from the source.
      */
-    createRawCell(options: CellModel.IOptions): IRawCellModel {
-      if (this.modelDB) {
-        if (!options.id) {
-          options.id = UUID.uuid4();
-        }
-        options.modelDB = this.modelDB.view(options.id);
-      }
-      return new RawCellModel(options);
+    createRawCell(value?: nbformat.IRawCell): string {
+      const id = UUID.uuid4();
+      const { datastore, cells, outputs } = this._data;
+      const loc = {
+        datastore,
+        record: { ...cells, record: id },
+        outputs
+      };
+      RawCellData.fromJSON(loc, value);
+      return id;
     }
 
     /**
-     * Clone the content factory with a new IModelDB.
+     * Clone the content factory with a new data location.
      */
-    clone(modelDB: IModelDB): ContentFactory {
+    clone(data: ContentFactory.DataLocation): ContentFactory {
       return new ContentFactory({
-        modelDB: modelDB,
-        codeCellContentFactory: this.codeCellContentFactory
+        data
       });
     }
+
+    private _data: ContentFactory.DataLocation;
   }
 
   /**
@@ -549,15 +643,25 @@ export namespace NotebookModel {
      */
     export interface IOptions {
       /**
-       * The factory for code cell model content.
+       * The data in which to place new content.
        */
-      codeCellContentFactory?: CodeCellModel.IContentFactory;
+      data?: DataLocation;
+    }
 
+    /**
+     * Data location for a cell content factory.
+     */
+    export type DataLocation = DatastoreExt.DataLocation & {
       /**
-       * The modelDB in which to place new content.
+       * A cell table.
        */
-      modelDB?: IModelDB;
-    }
+      cells: DatastoreExt.TableLocation<ICellData.Schema>;
+
+      /**
+       * An outputs table.
+       */
+      outputs: DatastoreExt.TableLocation<IOutputData.Schema>;
+    };
   }
 
   /**
@@ -565,3 +669,16 @@ export namespace NotebookModel {
    */
   export const defaultContentFactory = new ContentFactory({});
 }
+
+/**
+ * A namespace for module private functionality.
+ */
+namespace Private {
+  /**
+   * Cell fields for which changes should be considered changes
+   * to the notebook content.
+   */
+  export const CELL_CONTENT_FIELDS = Object.keys(CellData.SCHEMA.fields).filter(
+    key => key !== 'mimeType' && key !== 'selections'
+  );
+}
diff --git a/packages/notebook/src/modelfactory.ts b/packages/notebook/src/modelfactory.ts
index 8f4c395d05f..cffa8d2d7f1 100644
--- a/packages/notebook/src/modelfactory.ts
+++ b/packages/notebook/src/modelfactory.ts
@@ -1,14 +1,18 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { CodeCellModel } from '@jupyterlab/cells';
+import { CellData } from '@jupyterlab/cells';
+
+import { createDatastore } from '@jupyterlab/datastore';
 
 import { DocumentRegistry } from '@jupyterlab/docregistry';
 
-import { IModelDB } from '@jupyterlab/observables';
+import { OutputData } from '@jupyterlab/rendermime';
 
 import { Contents } from '@jupyterlab/services';
 
+import { NotebookData } from './data';
+
 import { INotebookModel, NotebookModel } from './model';
 
 /**
@@ -20,10 +24,8 @@ export class NotebookModelFactory
    * Construct a new notebook model factory.
    */
   constructor(options: NotebookModelFactory.IOptions) {
-    let codeCellContentFactory = options.codeCellContentFactory;
     this.contentFactory =
-      options.contentFactory ||
-      new NotebookModel.ContentFactory({ codeCellContentFactory });
+      options.contentFactory || new NotebookModel.ContentFactory({});
   }
 
   /**
@@ -73,9 +75,26 @@ export class NotebookModelFactory
    *
    * @returns A new document model.
    */
-  createNew(languagePreference?: string, modelDB?: IModelDB): INotebookModel {
-    let contentFactory = this.contentFactory;
-    return new NotebookModel({ languagePreference, contentFactory, modelDB });
+  async createNew(
+    options: DocumentRegistry.IModelFactory.IOptions = {}
+  ): Promise<INotebookModel> {
+    const contentFactory = this.contentFactory;
+    const { languagePreference, path } = options;
+    if (path) {
+      const datastore = await createDatastore(path, [
+        NotebookData.SCHEMA,
+        OutputData.SCHEMA,
+        CellData.SCHEMA
+      ]);
+      const data = {
+        datastore,
+        record: { schema: NotebookData.SCHEMA, record: 'data' },
+        cells: { schema: CellData.SCHEMA },
+        outputs: { schema: OutputData.SCHEMA }
+      };
+      return new NotebookModel({ data, languagePreference, contentFactory });
+    }
+    return new NotebookModel({ languagePreference, contentFactory });
   }
 
   /**
@@ -96,11 +115,6 @@ export namespace NotebookModelFactory {
    * The options used to initialize a NotebookModelFactory.
    */
   export interface IOptions {
-    /**
-     * The factory for code cell content.
-     */
-    codeCellContentFactory?: CodeCellModel.IContentFactory;
-
     /**
      * The content factory used by the NotebookModelFactory.  If
      * given, it will supersede the `codeCellContentFactory`.
diff --git a/packages/notebook/src/notebooktools.ts b/packages/notebook/src/notebooktools.ts
index 421166e002b..36262a3f8d1 100644
--- a/packages/notebook/src/notebooktools.ts
+++ b/packages/notebook/src/notebooktools.ts
@@ -1,19 +1,9 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { ArrayExt, each, chain } from '@lumino/algorithm';
-
-import { JSONObject, JSONValue } from '@lumino/coreutils';
-
-import { ConflatableMessage, Message, MessageLoop } from '@lumino/messaging';
-
-import { h, VirtualDOM, VirtualNode } from '@lumino/virtualdom';
-
-import { PanelLayout, Widget } from '@lumino/widgets';
-
 import { Collapse, Styling } from '@jupyterlab/apputils';
 
-import { Cell, ICellModel } from '@jupyterlab/cells';
+import { Cell, ICellData } from '@jupyterlab/cells';
 
 import {
   CodeEditor,
@@ -23,10 +13,26 @@ import {
 
 import { nbformat } from '@jupyterlab/coreutils';
 
-import { IObservableMap, ObservableJSON } from '@jupyterlab/observables';
+import { DatastoreExt } from '@jupyterlab/datastore';
+
+import { ArrayExt, each, chain } from '@lumino/algorithm';
+
+import { JSONObject, JSONValue, ReadonlyJSONValue } from '@lumino/coreutils';
+
+import { Datastore, MapField } from '@lumino/datastore';
+
+import { IDisposable } from '@lumino/disposable';
+
+import { ConflatableMessage, Message, MessageLoop } from '@lumino/messaging';
+
+import { h, VirtualDOM, VirtualNode } from '@lumino/virtualdom';
+
+import { PanelLayout, Widget } from '@lumino/widgets';
+
+import { INotebookData } from './data';
 
 import { NotebookPanel } from './panel';
-import { INotebookModel } from './model';
+
 import { INotebookTools, INotebookTracker } from './tokens';
 
 class RankedPanel<T extends Widget = Widget> extends Widget {
@@ -148,22 +154,19 @@ export class NotebookTools extends Widget implements INotebookTools {
    * Handle a change to the notebook panel.
    */
   private _onActiveNotebookPanelChanged(): void {
-    if (
-      this._prevActiveNotebookModel &&
-      !this._prevActiveNotebookModel.isDisposed
-    ) {
-      this._prevActiveNotebookModel.metadata.changed.disconnect(
-        this._onActiveNotebookPanelMetadataChanged,
-        this
-      );
+    if (this._nbMetadataListener) {
+      this._nbMetadataListener.dispose();
+      this._nbMetadataListener = null;
     }
     const activeNBModel =
       this.activeNotebookPanel && this.activeNotebookPanel.content
         ? this.activeNotebookPanel.content.model
         : null;
-    this._prevActiveNotebookModel = activeNBModel;
     if (activeNBModel) {
-      activeNBModel.metadata.changed.connect(
+      const { datastore, record } = activeNBModel.data;
+      this._nbMetadataListener = DatastoreExt.listenField(
+        datastore,
+        { ...record, field: 'metadata' },
         this._onActiveNotebookPanelMetadataChanged,
         this
       );
@@ -177,16 +180,17 @@ export class NotebookTools extends Widget implements INotebookTools {
    * Handle a change to the active cell.
    */
   private _onActiveCellChanged(): void {
-    if (this._prevActiveCell && !this._prevActiveCell.isDisposed) {
-      this._prevActiveCell.metadata.changed.disconnect(
-        this._onActiveCellMetadataChanged,
-        this
-      );
+    if (this._cellListener) {
+      this._cellListener.dispose();
+      this._cellListener = null;
     }
-    const activeCell = this.activeCell ? this.activeCell.model : null;
+    const activeCell = this.activeCell ? this.activeCell.data : null;
     this._prevActiveCell = activeCell;
     if (activeCell) {
-      activeCell.metadata.changed.connect(
+      const { datastore, record } = this._prevActiveCell;
+      DatastoreExt.listenField(
+        datastore,
+        { ...record, field: 'metadata' },
         this._onActiveCellMetadataChanged,
         this
       );
@@ -209,10 +213,10 @@ export class NotebookTools extends Widget implements INotebookTools {
    * Handle a change in the active cell metadata.
    */
   private _onActiveNotebookPanelMetadataChanged(
-    sender: IObservableMap<JSONValue>,
-    args: IObservableMap.IChangedArgs<JSONValue>
+    sender: Datastore,
+    args: MapField.Change<JSONValue>
   ): void {
-    let message = new ObservableJSON.ChangeMessage(
+    let message = new NotebookTools.MetadataChangeMessage(
       'activenotebookpanel-metadata-changed',
       args
     );
@@ -225,10 +229,10 @@ export class NotebookTools extends Widget implements INotebookTools {
    * Handle a change in the notebook model metadata.
    */
   private _onActiveCellMetadataChanged(
-    sender: IObservableMap<JSONValue>,
-    args: IObservableMap.IChangedArgs<JSONValue>
+    sender: Datastore,
+    args: MapField.Change<JSONValue>
   ): void {
-    let message = new ObservableJSON.ChangeMessage(
+    let message = new NotebookTools.MetadataChangeMessage(
       'activecell-metadata-changed',
       args
     );
@@ -241,11 +245,12 @@ export class NotebookTools extends Widget implements INotebookTools {
     return chain(this._commonTools.children(), this._advancedTools.children());
   }
 
+  private _cellListener: IDisposable;
   private _commonTools: RankedPanel<NotebookTools.Tool>;
   private _advancedTools: RankedPanel<NotebookTools.Tool>;
   private _tracker: INotebookTracker;
-  private _prevActiveCell: ICellModel | null;
-  private _prevActiveNotebookModel: INotebookModel | null;
+  private _prevActiveCell: ICellData.DataLocation | null;
+  private _nbMetadataListener: IDisposable | null = null;
 }
 
 /**
@@ -262,6 +267,24 @@ export namespace NotebookTools {
     tracker: INotebookTracker;
   }
 
+  /**
+   * An JSON field change message.
+   */
+  export class MetadataChangeMessage extends Message {
+    /**
+     * Create a new metadata changed message.
+     */
+    constructor(type: string, args: MapField.Change<JSONValue>) {
+      super(type);
+      this.args = args;
+    }
+
+    /**
+     * The arguments of the change.
+     */
+    readonly args: MapField.Change<JSONValue>;
+  }
+
   /**
    * The options used to add an item to the notebook tools.
    */
@@ -331,11 +354,13 @@ export namespace NotebookTools {
           this.onSelectionChanged(msg);
           break;
         case 'activecell-metadata-changed':
-          this.onActiveCellMetadataChanged(msg as ObservableJSON.ChangeMessage);
+          this.onActiveCellMetadataChanged(
+            msg as NotebookTools.MetadataChangeMessage
+          );
           break;
         case 'activenotebookpanel-metadata-changed':
           this.onActiveNotebookPanelMetadataChanged(
-            msg as ObservableJSON.ChangeMessage
+            msg as NotebookTools.MetadataChangeMessage
           );
           break;
         default:
@@ -380,7 +405,7 @@ export namespace NotebookTools {
      * The default implementation is a no-op.
      */
     protected onActiveCellMetadataChanged(
-      msg: ObservableJSON.ChangeMessage
+      msg: NotebookTools.MetadataChangeMessage
     ): void {
       /* no-op */
     }
@@ -392,7 +417,7 @@ export namespace NotebookTools {
      * The default implementation is a no-op.
      */
     protected onActiveNotebookPanelMetadataChanged(
-      msg: ObservableJSON.ChangeMessage
+      msg: NotebookTools.MetadataChangeMessage
     ): void {
       /* no-op */
     }
@@ -434,12 +459,13 @@ export namespace NotebookTools {
       for (let i = 0; i < count; i++) {
         layout.widgets[0].dispose();
       }
-      if (this._cellModel && !this._cellModel.isDisposed) {
-        this._cellModel.value.changed.disconnect(this._onValueChanged, this);
-        this._cellModel.mimeTypeChanged.disconnect(
-          this._onMimeTypeChanged,
-          this
-        );
+      if (this._mimeTypeListener) {
+        this._mimeTypeListener.dispose();
+        this._mimeTypeListener = null;
+      }
+      if (this._valueListener) {
+        this._valueListener.dispose();
+        this._valueListener = null;
       }
       if (!activeCell) {
         let cell = new Widget();
@@ -455,11 +481,21 @@ export namespace NotebookTools {
       let prompt = new Widget({ node: promptNode });
       let factory = activeCell.contentFactory.editorFactory;
 
-      let cellModel = (this._cellModel = activeCell.model);
-      cellModel.value.changed.connect(this._onValueChanged, this);
-      cellModel.mimeTypeChanged.connect(this._onMimeTypeChanged, this);
-      this._model.value.text = cellModel.value.text.split('\n')[0];
-      this._model.mimeType = cellModel.mimeType;
+      let cellLoc = (this._cellModel = activeCell.editor.model);
+      this._valueListener = DatastoreExt.listenField(
+        cellLoc.data.datastore,
+        { ...cellLoc.data.record, field: 'text' },
+        this._onValueChanged,
+        this
+      );
+      this._mimeTypeListener = DatastoreExt.listenField(
+        cellLoc.data.datastore,
+        { ...cellLoc.data.record, field: 'mimeType' },
+        this._onMimeTypeChanged,
+        this
+      );
+      this._model.value = activeCell.editor.model.value.split('\n')[0];
+      this._model.mimeType = activeCell.editor.model.mimeType;
 
       let model = this._model;
       let editorWidget = new CodeEditorWrapper({ model, factory });
@@ -474,7 +510,7 @@ export namespace NotebookTools {
      * Handle a change to the current editor value.
      */
     private _onValueChanged(): void {
-      this._model.value.text = this._cellModel.value.text.split('\n')[0];
+      this._model.value = this._cellModel.value.split('\n')[0];
     }
 
     /**
@@ -486,6 +522,8 @@ export namespace NotebookTools {
 
     private _model = new CodeEditor.Model();
     private _cellModel: CodeEditor.IModel;
+    private _mimeTypeListener: IDisposable | null = null;
+    private _valueListener: IDisposable | null = null;
   }
 
   /**
@@ -500,7 +538,10 @@ export namespace NotebookTools {
       const { editorFactory } = options;
       this.addClass('jp-MetadataEditorTool');
       let layout = (this.layout = new PanelLayout());
-      this.editor = new JSONEditor({
+      this.editor = new JSONEditor<
+        INotebookData.Schema | ICellData.Schema,
+        'metadata'
+      >({
         editorFactory
       });
       this.editor.title.label = options.label || 'Edit Metadata';
@@ -513,7 +554,10 @@ export namespace NotebookTools {
     /**
      * The editor used by the tool.
      */
-    readonly editor: JSONEditor;
+    readonly editor: JSONEditor<
+      ICellData.Schema | INotebookData.Schema,
+      'metadata'
+    >;
   }
 
   /**
@@ -568,7 +612,15 @@ export namespace NotebookTools {
       const nb =
         this.notebookTools.activeNotebookPanel &&
         this.notebookTools.activeNotebookPanel.content;
-      this.editor.source = nb ? nb.model.metadata : null;
+      if (!nb || !nb.model) {
+        return;
+      }
+      this.editor.source = nb
+        ? {
+            datastore: nb.model.data.datastore,
+            field: { ...nb.model.data.record, field: 'metadata' }
+          }
+        : null;
     }
   }
 
@@ -591,13 +643,20 @@ export namespace NotebookTools {
     /**
      * Handle a change to the active cell metadata.
      */
-    protected onActiveCellMetadataChanged(msg: Message): void {
+    protected onActiveCellMetadataChanged(
+      msg: NotebookTools.MetadataChangeMessage
+    ): void {
       this._update();
     }
 
     private _update() {
       let cell = this.notebookTools.activeCell;
-      this.editor.source = cell ? cell.model.metadata : null;
+      this.editor.source = cell
+        ? {
+            datastore: cell.data.datastore,
+            field: { ...cell.data.record, field: 'metadata' }
+          }
+        : null;
     }
   }
 
@@ -678,7 +737,7 @@ export namespace NotebookTools {
         select.value = '';
         return;
       }
-      let cellType = activeCell.model.type;
+      let cellType = activeCell.type;
       if (
         this._validCellTypes.length &&
         this._validCellTypes.indexOf(cellType) === -1
@@ -697,13 +756,15 @@ export namespace NotebookTools {
     /**
      * Handle a change to the metadata of the active cell.
      */
-    protected onActiveCellMetadataChanged(msg: ObservableJSON.ChangeMessage) {
+    protected onActiveCellMetadataChanged(
+      msg: NotebookTools.MetadataChangeMessage
+    ) {
       if (this._changeGuard) {
         return;
       }
       let select = this.selectNode;
       let cell = this.notebookTools.activeCell;
-      if (msg.args.key === this.key && cell) {
+      if (cell && msg.args.current[this.key]) {
         this._changeGuard = true;
         let getter = this._getter;
         select.value = JSON.stringify(getter(cell));
@@ -730,7 +791,12 @@ export namespace NotebookTools {
      * Get the value for the data.
      */
     private _getValue = (cell: Cell) => {
-      let value = cell.model.metadata.get(this.key);
+      const { datastore, record } = cell.data;
+      const metadata = DatastoreExt.getField(datastore, {
+        ...record,
+        field: 'metadata'
+      });
+      let value = metadata[this.key];
       if (value === undefined) {
         value = this._default;
       }
@@ -741,17 +807,28 @@ export namespace NotebookTools {
      * Set the value for the data.
      */
     private _setValue = (cell: Cell, value: JSONValue) => {
-      if (value === this._default) {
-        cell.model.metadata.delete(this.key);
-      } else {
-        cell.model.metadata.set(this.key, value);
-      }
+      const { datastore, record } = cell.data;
+      DatastoreExt.withTransaction(datastore, () => {
+        if (value === this._default) {
+          DatastoreExt.updateField(
+            datastore,
+            { ...record, field: 'metadata' },
+            { [this.key]: null }
+          );
+        } else {
+          DatastoreExt.updateField(
+            datastore,
+            { ...record, field: 'metadata' },
+            { [this.key]: value }
+          );
+        }
+      });
     };
 
     private _changeGuard = false;
     private _validCellTypes: string[];
-    private _getter: (cell: Cell) => JSONValue;
-    private _setter: (cell: Cell, value: JSONValue) => void;
+    private _getter: (cell: Cell) => ReadonlyJSONValue;
+    private _setter: (cell: Cell, value: ReadonlyJSONValue) => void;
     private _default: JSONValue;
   }
 
@@ -832,11 +909,21 @@ export namespace NotebookTools {
         Notes: 'notes'
       },
       getter: cell => {
-        let value = cell.model.metadata.get('slideshow');
+        let { datastore, record } = cell.data;
+        let metadata = DatastoreExt.getField(datastore, {
+          ...record,
+          field: 'metadata'
+        });
+        let value = metadata['slideshow'];
         return value && (value as JSONObject)['slide_type'];
       },
       setter: (cell, value) => {
-        let data = cell.model.metadata.get('slideshow') || Object.create(null);
+        let { datastore, record } = cell.data;
+        let metadata = DatastoreExt.getField(datastore, {
+          ...record,
+          field: 'metadata'
+        });
+        let data = metadata['slideshow'] || Object.create(null);
         if (value === null) {
           // Make a shallow copy so we aren't modifying the original metadata.
           data = { ...data };
@@ -844,11 +931,13 @@ export namespace NotebookTools {
         } else {
           data = { ...data, slide_type: value };
         }
-        if (Object.keys(data).length > 0) {
-          cell.model.metadata.set('slideshow', data);
-        } else {
-          cell.model.metadata.delete('slideshow');
-        }
+        DatastoreExt.withTransaction(datastore, () => {
+          DatastoreExt.updateField(
+            datastore,
+            { ...record, field: 'metadata' },
+            { slideshow: Object.keys(data).length > 0 ? data : null }
+          );
+        });
       }
     };
     return new KeySelector(options);
diff --git a/packages/notebook/src/panel.ts b/packages/notebook/src/panel.ts
index d9405ab73ff..7d48b8b7d22 100644
--- a/packages/notebook/src/panel.ts
+++ b/packages/notebook/src/panel.ts
@@ -16,6 +16,8 @@ import {
   Dialog
 } from '@jupyterlab/apputils';
 
+import { DatastoreExt } from '@jupyterlab/datastore';
+
 import { DocumentWidget } from '@jupyterlab/docregistry';
 
 import { INotebookModel } from './model';
@@ -52,7 +54,9 @@ export class NotebookPanel extends DocumentWidget<Notebook, INotebookModel> {
     this.content.addClass(NOTEBOOK_PANEL_NOTEBOOK_CLASS);
 
     // Set up things related to the context
-    this.content.model = this.context.model;
+    this.context.ready.then(() => {
+      this.content.model = this.context.model;
+    });
     this.context.session.kernelChanged.connect(this._onKernelChanged, this);
     this.context.session.statusChanged.connect(
       this._onSessionStatusChanged,
@@ -62,8 +66,8 @@ export class NotebookPanel extends DocumentWidget<Notebook, INotebookModel> {
     void this.revealed.then(() => {
       // Set the document edit mode on initial open if it looks like a new document.
       if (this.content.widgets.length === 1) {
-        let cellModel = this.content.widgets[0].model;
-        if (cellModel.type === 'code' && cellModel.value.text === '') {
+        let cell = this.content.widgets[0];
+        if (cell.type === 'code' && cell.editor.model.value === '') {
           this.content.mode = 'edit';
         }
       }
@@ -145,7 +149,7 @@ export class NotebookPanel extends DocumentWidget<Notebook, INotebookModel> {
   [Printing.symbol]() {
     return async () => {
       // Save before generating HTML
-      if (this.context.model.dirty && !this.context.model.readOnly) {
+      if (this.context.dirty && !this.context.readOnly) {
         await this.context.save();
       }
 
@@ -207,7 +211,14 @@ export class NotebookPanel extends DocumentWidget<Notebook, INotebookModel> {
    * Update the kernel language.
    */
   private _updateLanguage(language: KernelMessage.ILanguageInfo): void {
-    this.model.metadata.set('language_info', language);
+    const { datastore, record } = this.model.data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateField(
+        datastore,
+        { ...record, field: 'metadata' },
+        { language_info: language }
+      );
+    });
   }
 
   /**
@@ -218,10 +229,19 @@ export class NotebookPanel extends DocumentWidget<Notebook, INotebookModel> {
       if (this.isDisposed) {
         return;
       }
-      this.model.metadata.set('kernelspec', {
-        name: kernel.name,
-        display_name: spec.display_name,
-        language: spec.language
+      const { datastore, record } = this.model.data;
+      DatastoreExt.withTransaction(datastore, () => {
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'metadata' },
+          {
+            kernelspec: {
+              name: kernel.name,
+              display_name: spec.display_name,
+              language: spec.language
+            }
+          }
+        );
       });
     });
   }
diff --git a/packages/notebook/src/truststatus.tsx b/packages/notebook/src/truststatus.tsx
index 99d7b0d0e24..17fbdc3b476 100644
--- a/packages/notebook/src/truststatus.tsx
+++ b/packages/notebook/src/truststatus.tsx
@@ -2,7 +2,7 @@ import React from 'react';
 
 import { VDomRenderer, VDomModel } from '@jupyterlab/apputils';
 
-import { INotebookModel, Notebook } from '.';
+import { DatastoreExt } from '@jupyterlab/datastore';
 
 import { Cell } from '@jupyterlab/cells';
 
@@ -10,6 +10,8 @@ import { IconItem } from '@jupyterlab/statusbar';
 
 import { toArray } from '@lumino/algorithm';
 
+import { Notebook } from '.';
+
 /**
  * Determine the notebook trust status message.
  */
@@ -174,15 +176,18 @@ export namespace NotebookTrustStatus {
         this._notebook.modelContentChanged.connect(this._onModelChanged, this);
 
         // Derive values
-        if (this._notebook.activeCell !== undefined) {
-          this._activeCellTrusted = this._notebook!.activeCell!.model.trusted;
+        if (this._notebook.activeCell) {
+          const { datastore, record } = this._notebook.activeCell.data;
+          let trusted = DatastoreExt.getField(datastore, {
+            ...record,
+            field: 'trusted'
+          });
+          this._activeCellTrusted = trusted;
         } else {
           this._activeCellTrusted = false;
         }
 
-        const { total, trusted } = this._deriveCellTrustState(
-          this._notebook.model
-        );
+        const { total, trusted } = this._deriveCellTrustState(this._notebook);
 
         this._totalCells = total;
         this._trustedCells = trusted;
@@ -196,7 +201,7 @@ export namespace NotebookTrustStatus {
      */
     private _onModelChanged(notebook: Notebook): void {
       const oldState = this._getAllState();
-      const { total, trusted } = this._deriveCellTrustState(notebook.model);
+      const { total, trusted } = this._deriveCellTrustState(notebook);
 
       this._totalCells = total;
       this._trustedCells = trusted;
@@ -209,7 +214,11 @@ export namespace NotebookTrustStatus {
     private _onActiveCellChanged(model: Notebook, cell: Cell | null): void {
       const oldState = this._getAllState();
       if (cell) {
-        this._activeCellTrusted = cell.model.trusted;
+        let trusted = DatastoreExt.getField(cell.data.datastore, {
+          ...cell.data.record,
+          field: 'trusted'
+        });
+        this._activeCellTrusted = trusted;
       } else {
         this._activeCellTrusted = false;
       }
@@ -220,12 +229,16 @@ export namespace NotebookTrustStatus {
      * Given a notebook model, figure out how many of the cells are trusted.
      */
     private _deriveCellTrustState(
-      model: INotebookModel
+      notebook: Notebook
     ): { total: number; trusted: number } {
-      let cells = toArray(model.cells);
+      let cells = toArray(notebook.widgets);
 
       let trusted = cells.reduce((accum, current) => {
-        if (current.trusted) {
+        let trusted = DatastoreExt.getField(current.data.datastore, {
+          ...current.data.record,
+          field: 'trusted'
+        });
+        if (trusted) {
           return accum + 1;
         } else {
           return accum;
diff --git a/packages/notebook/src/widget.ts b/packages/notebook/src/widget.ts
index 94bffc3b031..2b15af4adf4 100644
--- a/packages/notebook/src/widget.ts
+++ b/packages/notebook/src/widget.ts
@@ -3,38 +3,38 @@
 
 import { ArrayExt, each } from '@lumino/algorithm';
 
-import { JSONValue } from '@lumino/coreutils';
+import { JSONValue, MimeData } from '@lumino/coreutils';
 
-import { Message } from '@lumino/messaging';
+import { Datastore, ListField, MapField } from '@lumino/datastore';
+
+import { IDisposable } from '@lumino/disposable';
 
-import { MimeData } from '@lumino/coreutils';
+import { IDragEvent, Drag } from '@lumino/dragdrop';
+
+import { Message } from '@lumino/messaging';
 
 import { AttachedProperty } from '@lumino/properties';
 
 import { ISignal, Signal } from '@lumino/signaling';
 
-import { Drag, IDragEvent } from '@lumino/dragdrop';
-
 import { PanelLayout, Widget } from '@lumino/widgets';
 
 import { h, VirtualDOM } from '@lumino/virtualdom';
 
 import {
-  ICellModel,
   Cell,
-  IMarkdownCellModel,
+  CellData,
   CodeCell,
+  ICellData,
   MarkdownCell,
-  ICodeCellModel,
-  RawCell,
-  IRawCellModel
+  RawCell
 } from '@jupyterlab/cells';
 
 import { IEditorMimeTypeService, CodeEditor } from '@jupyterlab/codeeditor';
 
 import { IChangedArgs, nbformat } from '@jupyterlab/coreutils';
 
-import { IObservableMap, IObservableList } from '@jupyterlab/observables';
+import { DatastoreExt } from '@jupyterlab/datastore';
 
 import { IRenderMimeRegistry } from '@jupyterlab/rendermime';
 
@@ -215,23 +215,6 @@ export class StaticNotebook extends Widget {
     let oldValue = this._model;
     this._model = newValue;
 
-    if (oldValue && oldValue.modelDB.isCollaborative) {
-      void oldValue.modelDB.connected.then(() => {
-        oldValue.modelDB.collaborators.changed.disconnect(
-          this._onCollaboratorsChanged,
-          this
-        );
-      });
-    }
-    if (newValue && newValue.modelDB.isCollaborative) {
-      void newValue.modelDB.connected.then(() => {
-        newValue.modelDB.collaborators.changed.connect(
-          this._onCollaboratorsChanged,
-          this
-        );
-      });
-    }
-
     // Trigger private, protected, and public changes.
     this._onModelChanged(oldValue, newValue);
     this.onModelChanged(oldValue, newValue);
@@ -319,15 +302,11 @@ export class StaticNotebook extends Widget {
    * when the `language_info` metadata changes.
    */
   protected onMetadataChanged(
-    sender: IObservableMap<JSONValue>,
-    args: IObservableMap.IChangedArgs<JSONValue>
+    sender: Datastore,
+    args: MapField.Change<JSONValue>
   ): void {
-    switch (args.key) {
-      case 'language_info':
-        this._updateMimetype();
-        break;
-      default:
-        break;
+    if (args.current['language_info']) {
+      this._updateMimetype();
     }
   }
 
@@ -367,8 +346,14 @@ export class StaticNotebook extends Widget {
   ): void {
     let layout = this.layout as PanelLayout;
     if (oldValue) {
-      oldValue.cells.changed.disconnect(this._onCellsChanged, this);
-      oldValue.metadata.changed.disconnect(this.onMetadataChanged, this);
+      if (this._cellListener) {
+        this._cellListener.dispose();
+        this._cellListener = null;
+      }
+      if (this._metadataListener) {
+        this._metadataListener.dispose();
+        this._metadataListener = null;
+      }
       oldValue.contentChanged.disconnect(this.onModelContentChanged, this);
       // TODO: reuse existing cell widgets if possible. Remember to initially
       // clear the history of each cell if we do this.
@@ -381,94 +366,109 @@ export class StaticNotebook extends Widget {
       return;
     }
     this._updateMimetype();
-    let cells = newValue.cells;
-    if (!cells.length) {
-      cells.push(
-        newValue.contentFactory.createCell(this.notebookConfig.defaultCell, {})
-      );
-    }
-    each(cells, (cell: ICellModel, i: number) => {
-      this._insertCell(i, cell);
+    const { datastore, record, cells, outputs } = newValue.data;
+    let cellIds = DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'cells'
+    });
+    cellIds.forEach((id: string, i: number) => {
+      this._insertCell(i, {
+        datastore,
+        record: { ...cells, record: id },
+        outputs
+      });
     });
-    cells.changed.connect(this._onCellsChanged, this);
-    newValue.contentChanged.connect(this.onModelContentChanged, this);
-    newValue.metadata.changed.connect(this.onMetadataChanged, this);
+    this._cellListener = DatastoreExt.listenField(
+      datastore,
+      {
+        ...record,
+        field: 'cells'
+      },
+      this._onCellsChanged,
+      this
+    );
+    this._metadataListener = DatastoreExt.listenField(
+      datastore,
+      { ...record, field: 'metadata' },
+      this.onMetadataChanged,
+      this
+    );
+    if (!cellIds.length) {
+      DatastoreExt.withTransaction(datastore, () => {
+        const cellId = newValue.contentFactory.createCell(
+          this.notebookConfig.defaultCell
+        );
+        DatastoreExt.updateField(
+          datastore,
+          { ...record, field: 'cells' },
+          { index: 0, remove: 0, values: [cellId] }
+        );
+      });
+    }
   }
 
   /**
    * Handle a change cells event.
    */
-  private _onCellsChanged(
-    sender: IObservableList<ICellModel>,
-    args: IObservableList.IChangedArgs<ICellModel>
-  ) {
-    let index = 0;
-    switch (args.type) {
-      case 'add':
-        index = args.newIndex;
-        each(args.newValues, value => {
-          this._insertCell(index++, value);
-        });
-        break;
-      case 'move':
-        this._moveCell(args.oldIndex, args.newIndex);
-        break;
-      case 'remove':
-        each(args.oldValues, value => {
-          this._removeCell(args.oldIndex);
-        });
-        // Add default cell if there are no cells remaining.
-        if (!sender.length) {
-          const model = this.model;
-          // Add the cell in a new context to avoid triggering another
-          // cell changed event during the handling of this signal.
-          requestAnimationFrame(() => {
-            if (!model.isDisposed && !model.cells.length) {
-              model.cells.push(
-                model.contentFactory.createCell(
-                  this.notebookConfig.defaultCell,
-                  {}
-                )
-              );
-            }
+  private _onCellsChanged(sender: Datastore, args: ListField.Change<string>) {
+    const { datastore, record, cells, outputs } = this.model.data;
+    args.forEach(change => {
+      for (let i = 0; i < change.removed.length; i++) {
+        this._removeCell(change.index);
+      }
+      for (let i = 0; i < change.inserted.length; i++) {
+        const loc = {
+          datastore,
+          record: {
+            ...cells,
+            record: change.inserted[i]
+          },
+          outputs
+        };
+        this._insertCell(change.index + i, loc);
+      }
+      const cellIds = DatastoreExt.getField(datastore, {
+        ...record,
+        field: 'cells'
+      });
+      if (!cellIds.length) {
+        requestAnimationFrame(() => {
+          // Add a new cell in a new frame so we don't trigger the
+          // same change listener in this one.
+          DatastoreExt.withTransaction(datastore, () => {
+            const cellId = this.model.contentFactory.createCell(
+              this.notebookConfig.defaultCell
+            );
+            DatastoreExt.updateField(
+              datastore,
+              { ...record, field: 'cells' },
+              { index: 0, remove: 0, values: [cellId] }
+            );
           });
-        }
-        break;
-      case 'set':
-        // TODO: reuse existing widgets if possible.
-        index = args.newIndex;
-        each(args.newValues, value => {
-          // Note: this ordering (insert then remove)
-          // is important for getting the active cell
-          // index for the editable notebook correct.
-          this._insertCell(index, value);
-          this._removeCell(index + 1);
-          index++;
         });
-        break;
-      default:
-        return;
-    }
+      }
+    });
   }
 
   /**
    * Create a cell widget and insert into the notebook.
    */
-  private _insertCell(index: number, cell: ICellModel): void {
+  private _insertCell(index: number, cell: ICellData.DataLocation): void {
     let widget: Cell;
-    switch (cell.type) {
+    const cellData = DatastoreExt.getRecord(cell.datastore, cell.record);
+    switch (cellData.type) {
       case 'code':
-        widget = this._createCodeCell(cell as ICodeCellModel);
-        widget.model.mimeType = this._mimetype;
+        widget = this._createCodeCell(cell);
+        widget.editor.model.mimeType = this._mimetype;
         break;
       case 'markdown':
-        widget = this._createMarkdownCell(cell as IMarkdownCellModel);
-        if (cell.value.text === '') {
+        widget = this._createMarkdownCell(cell);
+        if (widget.editor.model.value === '') {
           (widget as MarkdownCell).rendered = false;
         }
         break;
       default:
-        widget = this._createRawCell(cell as IRawCellModel);
+        widget = this._createRawCell(cell);
     }
     widget.addClass(NB_CELL_CLASS);
     let layout = this.layout as PanelLayout;
@@ -479,13 +479,13 @@ export class StaticNotebook extends Widget {
   /**
    * Create a code cell widget from a code cell model.
    */
-  private _createCodeCell(model: ICodeCellModel): CodeCell {
+  private _createCodeCell(data: ICellData.DataLocation): CodeCell {
     let rendermime = this.rendermime;
     let contentFactory = this.contentFactory;
     const editorConfig = this.editorConfig.code;
     let options = {
       editorConfig,
-      model,
+      data,
       rendermime,
       contentFactory,
       updateEditorOnShow: false
@@ -500,13 +500,13 @@ export class StaticNotebook extends Widget {
   /**
    * Create a markdown cell widget from a markdown cell model.
    */
-  private _createMarkdownCell(model: IMarkdownCellModel): MarkdownCell {
+  private _createMarkdownCell(data: ICellData.DataLocation): MarkdownCell {
     let rendermime = this.rendermime;
     let contentFactory = this.contentFactory;
     const editorConfig = this.editorConfig.markdown;
     let options = {
       editorConfig,
-      model,
+      data,
       rendermime,
       contentFactory,
       updateEditorOnShow: false
@@ -520,12 +520,12 @@ export class StaticNotebook extends Widget {
   /**
    * Create a raw cell widget from a raw cell model.
    */
-  private _createRawCell(model: IRawCellModel): RawCell {
+  private _createRawCell(data: ICellData.DataLocation): RawCell {
     let contentFactory = this.contentFactory;
     const editorConfig = this.editorConfig.raw;
     let options = {
       editorConfig,
-      model,
+      data,
       contentFactory,
       updateEditorOnShow: false
     };
@@ -535,15 +535,6 @@ export class StaticNotebook extends Widget {
     return cell;
   }
 
-  /**
-   * Move a cell widget.
-   */
-  private _moveCell(fromIndex: number, toIndex: number): void {
-    let layout = this.layout as PanelLayout;
-    layout.insertWidget(toIndex, layout.widgets[fromIndex]);
-    this.onCellMoved(fromIndex, toIndex);
-  }
-
   /**
    * Remove a cell widget.
    */
@@ -559,36 +550,25 @@ export class StaticNotebook extends Widget {
    * Update the mimetype of the notebook.
    */
   private _updateMimetype(): void {
-    let info = this._model.metadata.get(
+    let info = this._model.metadata[
       'language_info'
-    ) as nbformat.ILanguageInfoMetadata;
+    ] as nbformat.ILanguageInfoMetadata;
     if (!info) {
       return;
     }
     this._mimetype = this._mimetypeService.getMimeTypeByLanguage(info);
     each(this.widgets, widget => {
-      if (widget.model.type === 'code') {
-        widget.model.mimeType = this._mimetype;
+      const { datastore, record } = widget.data;
+      const cellType = DatastoreExt.getField(datastore, {
+        ...record,
+        field: 'type'
+      });
+      if (cellType === 'code') {
+        widget.editor.model.mimeType = this._mimetype;
       }
     });
   }
 
-  /**
-   * Handle an update to the collaborators.
-   */
-  private _onCollaboratorsChanged(): void {
-    // If there are selections corresponding to non-collaborators,
-    // they are stale and should be removed.
-    for (let i = 0; i < this.widgets.length; i++) {
-      let cell = this.widgets[i];
-      for (let key of cell.model.selections.keys()) {
-        if (!this._model.modelDB.collaborators.has(key)) {
-          cell.model.selections.delete(key);
-        }
-      }
-    }
-  }
-
   /**
    * Update editor settings for notebook cells.
    */
@@ -596,7 +576,7 @@ export class StaticNotebook extends Widget {
     for (let i = 0; i < this.widgets.length; i++) {
       const cell = this.widgets[i];
       let config: Partial<CodeEditor.IConfig>;
-      switch (cell.model.type) {
+      switch (cell.type) {
         case 'code':
           config = this._editorConfig.code;
           break;
@@ -627,6 +607,8 @@ export class StaticNotebook extends Widget {
 
   private _editorConfig = StaticNotebook.defaultEditorConfig;
   private _notebookConfig = StaticNotebook.defaultNotebookConfig;
+  private _metadataListener: IDisposable | null = null;
+  private _cellListener: IDisposable | null = null;
   private _mimetype = 'text/plain';
   private _model: INotebookModel = null;
   private _mimetypeService: IEditorMimeTypeService;
@@ -925,15 +907,15 @@ export class Notebook extends StaticNotebook {
     if (!this.model) {
       return -1;
     }
-    return this.model.cells.length ? this._activeCellIndex : -1;
+    return this.widgets.length ? this._activeCellIndex : -1;
   }
   set activeCellIndex(newValue: number) {
     let oldValue = this._activeCellIndex;
-    if (!this.model || !this.model.cells.length) {
+    if (!this.model || !this.widgets.length) {
       newValue = -1;
     } else {
       newValue = Math.max(newValue, 0);
-      newValue = Math.min(newValue, this.model.cells.length - 1);
+      newValue = Math.min(newValue, this.widgets.length - 1);
     }
 
     this._activeCellIndex = newValue;
@@ -973,6 +955,8 @@ export class Notebook extends StaticNotebook {
       return;
     }
     this._activeCell = null;
+    this._activeCellIndex = -1;
+    this._trimSelections();
     super.dispose();
   }
 
@@ -1432,20 +1416,7 @@ export class Notebook extends StaticNotebook {
    * Handle a cell being inserted.
    */
   protected onCellInserted(index: number, cell: Cell): void {
-    if (this.model && this.model.modelDB.isCollaborative) {
-      let modelDB = this.model.modelDB;
-      void modelDB.connected.then(() => {
-        if (!cell.isDisposed) {
-          // Setup the selection style for collaborators.
-          let localCollaborator = modelDB.collaborators.localCollaborator;
-          cell.editor.uuid = localCollaborator.sessionId;
-          cell.editor.selectionStyle = {
-            ...CodeEditor.defaultSelectionStyle,
-            color: localCollaborator.color
-          };
-        }
-      });
-    }
+    // TODO: let collaborators know who you are based on cursor!
     cell.editor.edgeRequested.connect(this._onEdgeRequest, this);
     // If the insertion happened above, increment the active cell
     // index, otherwise it stays the same.
@@ -1917,17 +1888,44 @@ export class Notebook extends StaticNotebook {
       }
 
       // Move the cells one by one
-      this.model.cells.beginCompoundOperation();
-      if (fromIndex < toIndex) {
-        each(toMove, cellWidget => {
-          this.model.cells.move(fromIndex, toIndex);
-        });
-      } else if (fromIndex > toIndex) {
-        each(toMove, cellWidget => {
-          this.model.cells.move(fromIndex++, toIndex++);
-        });
-      }
-      this.model.cells.endCompoundOperation();
+      const { datastore, record } = this.model.data;
+      DatastoreExt.withTransaction(datastore, () => {
+        if (fromIndex < toIndex) {
+          each(toMove, cellWidget => {
+            DatastoreExt.updateField(
+              datastore,
+              { ...record, field: 'cells' },
+              { index: fromIndex, remove: 1, values: [] }
+            );
+            DatastoreExt.updateField(
+              datastore,
+              { ...record, field: 'cells' },
+              {
+                index: toIndex,
+                remove: 0,
+                values: [cellWidget.data.record.record]
+              }
+            );
+          });
+        } else if (fromIndex > toIndex) {
+          each(toMove, cellWidget => {
+            DatastoreExt.updateField(
+              datastore,
+              { ...record, field: 'cells' },
+              { index: fromIndex++, remove: 1, values: [] }
+            );
+            DatastoreExt.updateField(
+              datastore,
+              { ...record, field: 'cells' },
+              {
+                index: toIndex++,
+                remove: 0,
+                values: [cellWidget.data.record.record]
+              }
+            );
+          });
+        }
+      });
     } else {
       // Handle the case where we are copying cells between
       // notebooks.
@@ -1943,23 +1941,30 @@ export class Notebook extends StaticNotebook {
       let factory = model.contentFactory;
 
       // Insert the copies of the original cells.
-      model.cells.beginCompoundOperation();
-      each(values, (cell: nbformat.ICell) => {
-        let value: ICellModel;
-        switch (cell.cell_type) {
-          case 'code':
-            value = factory.createCodeCell({ cell });
-            break;
-          case 'markdown':
-            value = factory.createMarkdownCell({ cell });
-            break;
-          default:
-            value = factory.createRawCell({ cell });
-            break;
-        }
-        model.cells.insert(index++, value);
+      const { datastore, record } = this.model.data;
+      DatastoreExt.withTransaction(datastore, () => {
+        each(values, (cell: nbformat.ICell) => {
+          let value: string;
+          switch (cell.cell_type) {
+            case 'code':
+              value = factory.createCodeCell(cell as nbformat.ICodeCell);
+              break;
+            case 'markdown':
+              value = factory.createMarkdownCell(
+                cell as nbformat.IMarkdownCell
+              );
+              break;
+            default:
+              value = factory.createRawCell(cell as nbformat.IRawCell);
+              break;
+          }
+          DatastoreExt.updateField(
+            datastore,
+            { ...record, field: 'cells' },
+            { index: index++, remove: 0, values: [value] }
+          );
+        });
       });
-      model.cells.endCompoundOperation();
       // Select the inserted cells.
       this.deselectAll();
       this.activeCellIndex = start;
@@ -1971,23 +1976,24 @@ export class Notebook extends StaticNotebook {
    * Start a drag event.
    */
   private _startDrag(index: number, clientX: number, clientY: number): void {
-    let cells = this.model.cells;
     let selected: nbformat.ICell[] = [];
     let toMove: Cell[] = [];
 
     each(this.widgets, (widget, i) => {
-      let cell = cells.get(i);
       if (this.isSelectedOrActive(widget)) {
         widget.addClass(DROP_SOURCE_CLASS);
-        selected.push(cell.toJSON());
+        selected.push(CellData.toJSON(widget.data));
         toMove.push(widget);
       }
     });
     let activeCell = this.activeCell;
     let dragImage: HTMLElement = null;
     let countString: string;
-    if (activeCell.model.type === 'code') {
-      let executionCount = (activeCell.model as ICodeCellModel).executionCount;
+    if (activeCell.type === 'code') {
+      let executionCount = DatastoreExt.getField(activeCell.data.datastore, {
+        ...activeCell.data.record,
+        field: 'executionCount'
+      });
       countString = ' ';
       if (executionCount) {
         countString = executionCount.toString();
@@ -2000,7 +2006,7 @@ export class Notebook extends StaticNotebook {
     dragImage = Private.createDragImage(
       selected.length,
       countString,
-      activeCell.model.value.text.split('\n')[0].slice(0, 26)
+      activeCell.editor.model.value.split('\n')[0].slice(0, 26)
     );
 
     // Set up the drag event.
@@ -2018,7 +2024,7 @@ export class Notebook extends StaticNotebook {
     this._drag.mimeData.setData('internal:cells', toMove);
     // Add mimeData for the text content of the selected cells,
     // allowing for drag/drop into plain text fields.
-    const textContent = toMove.map(cell => cell.model.value.text).join('\n');
+    const textContent = toMove.map(cell => cell.editor.model.value).join('\n');
     this._drag.mimeData.setData('text/plain', textContent);
 
     // Remove mousemove and mouseup listeners and start the drag.
@@ -2128,7 +2134,17 @@ export class Notebook extends StaticNotebook {
       return;
     }
     this.activeCellIndex = i;
-    if (model.cells.get(i).type === 'markdown') {
+    const { datastore, record, cells } = model.data;
+    const cellIds = DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'cells'
+    });
+    const cellType = DatastoreExt.getField(datastore, {
+      ...cells,
+      record: cellIds[i],
+      field: 'type'
+    });
+    if (cellType === 'markdown') {
       let widget = this.widgets[i] as MarkdownCell;
       widget.rendered = false;
     } else if (target.localName === 'img') {
@@ -2144,7 +2160,14 @@ export class Notebook extends StaticNotebook {
     for (let i = 0; i < this.widgets.length; i++) {
       if (i !== this._activeCellIndex) {
         let cell = this.widgets[i];
-        cell.model.selections.delete(cell.editor.uuid);
+        let { datastore, record } = cell.data;
+        DatastoreExt.withTransaction(datastore, () => {
+          DatastoreExt.updateField(
+            datastore,
+            { ...record, field: 'selections' },
+            { [cell.editor.uuid]: null }
+          );
+        });
       }
     }
   }
diff --git a/packages/notebook/style/index.css b/packages/notebook/style/index.css
index 9927f8adda6..2b3cd8bed50 100644
--- a/packages/notebook/style/index.css
+++ b/packages/notebook/style/index.css
@@ -11,6 +11,7 @@
 @import url('~@jupyterlab/codeeditor/style/index.css');
 @import url('~@jupyterlab/statusbar/style/index.css');
 @import url('~@jupyterlab/rendermime/style/index.css');
+@import url('~@jupyterlab/outputarea/style/index.css');
 @import url('~@jupyterlab/cells/style/index.css');
 @import url('~@jupyterlab/docregistry/style/index.css');
 
diff --git a/packages/outputarea/src/index.ts b/packages/outputarea/src/index.ts
index dba46488e23..02a73b2e475 100644
--- a/packages/outputarea/src/index.ts
+++ b/packages/outputarea/src/index.ts
@@ -1,5 +1,5 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-export * from './model';
+export * from './data';
 export * from './widget';

diff --git a/packages/outputarea/src/widget.ts b/packages/outputarea/src/widget.ts
index 13e13411f82..c118a92c52c 100644
--- a/packages/outputarea/src/widget.ts
+++ b/packages/outputarea/src/widget.ts
@@ -1,31 +1,38 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
+import { IClientSession } from '@jupyterlab/apputils';
+
+import { nbformat } from '@jupyterlab/coreutils';
+
+import { DatastoreExt } from '@jupyterlab/datastore';
+
+import {
+  IOutputData,
+  IRenderMimeRegistry,
+  OutputData,
+  OutputModel
+} from '@jupyterlab/rendermime';
+
+import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
+
+import { Kernel, KernelMessage } from '@jupyterlab/services';
+
 import {
   JSONObject,
   PromiseDelegate,
   ReadonlyJSONObject
 } from '@lumino/coreutils';
 
+import { Datastore, ListField } from '@lumino/datastore';
+
 import { Message } from '@lumino/messaging';
 
 import { Signal } from '@lumino/signaling';
 
-import { Panel, PanelLayout } from '@lumino/widgets';
-
-import { Widget } from '@lumino/widgets';
-
-import { IClientSession } from '@jupyterlab/apputils';
-
-import { nbformat } from '@jupyterlab/coreutils';
+import { Panel, PanelLayout, Widget } from '@lumino/widgets';
 
-import { IOutputModel, IRenderMimeRegistry } from '@jupyterlab/rendermime';
-
-import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
-
-import { Kernel, KernelMessage } from '@jupyterlab/services';
-
-import { IOutputAreaModel } from './model';
+import { IOutputAreaData, OutputAreaData } from './data';
 
 /**
  * The class name added to an output area widget.
@@ -83,12 +90,6 @@ const STDIN_INPUT_CLASS = 'jp-Stdin-input';
 
 /**
  * An output area widget.
- *
- * #### Notes
- * The widget model must be set separately and can be changed
- * at any time.  Consumers of the widget must account for a
- * `null` model, and may want to listen to the `modelChanged`
- * signal.
  */
 export class OutputArea extends Widget {
   /**
@@ -96,24 +97,42 @@ export class OutputArea extends Widget {
    */
   constructor(options: OutputArea.IOptions) {
     super();
-    let model = (this.model = options.model);
+    let data: IOutputAreaData.DataLocation;
+    if (options.data) {
+      data = this.data = options.data;
+    } else {
+      const datastore = (this._datastore = OutputAreaData.createStore());
+      data = this.data = {
+        datastore,
+        record: {
+          schema: OutputAreaData.SCHEMA,
+          record: 'data'
+        },
+        outputs: {
+          schema: OutputData.SCHEMA
+        }
+      };
+    }
     this.addClass(OUTPUT_AREA_CLASS);
     this.rendermime = options.rendermime;
     this.contentFactory =
       options.contentFactory || OutputArea.defaultContentFactory;
     this.layout = new PanelLayout();
-    for (let i = 0; i < model.length; i++) {
-      let output = model.get(i);
-      this._insertOutput(i, output);
+    const list = DatastoreExt.getField(data.datastore, {
+      ...data.record,
+      field: 'outputs'
+    });
+    for (let i = 0; i < list.length; i++) {
+      this._insertOutput(i, { ...data.outputs, record: list[i] });
     }
-    model.changed.connect(this.onModelChanged, this);
-    model.stateChanged.connect(this.onStateChanged, this);
+
+    data.datastore.changed.connect(this.onChange, this);
   }
 
   /**
-   * The model used by the widget.
+   * The data rendered by the widget.
    */
-  readonly model: IOutputAreaModel;
+  readonly data: IOutputAreaData.DataLocation;
 
   /**
    * The content factory used by the widget.
@@ -157,10 +176,6 @@ export class OutputArea extends Widget {
       KernelMessage.IExecuteReplyMsg
     > | null
   ) {
-    // Bail if the model is disposed.
-    if (this.model.isDisposed) {
-      throw Error('Model is disposed');
-    }
     if (this._future === value) {
       return;
     }
@@ -169,12 +184,12 @@ export class OutputArea extends Widget {
     }
     this._future = value;
 
-    this.model.clear();
+    OutputAreaData.clear(this.data);
 
     // Make sure there were no input widgets.
     if (this.widgets.length) {
       this._clear();
-      this.outputLengthChanged.emit(this.model.length);
+      this.outputLengthChanged.emit(0);
     }
 
     // Handle published messages.
@@ -195,50 +210,76 @@ export class OutputArea extends Widget {
    * Dispose of the resources used by the output area.
    */
   dispose(): void {
+    if (this.isDisposed) {
+      return;
+    }
+    if (this._datastore) {
+      this._datastore.dispose();
+      this._datastore = null;
+    }
+
     if (this._future) {
       this._future.dispose();
     }
     this._future = null;
     this._displayIdMap.clear();
+    Signal.clearData(this);
     super.dispose();
   }
-
   /**
-   * Follow changes on the model state.
-   */
-  protected onModelChanged(
-    sender: IOutputAreaModel,
-    args: IOutputAreaModel.ChangedArgs
-  ): void {
-    switch (args.type) {
-      case 'add':
-        this._insertOutput(args.newIndex, args.newValues[0]);
-        this.outputLengthChanged.emit(this.model.length);
-        break;
-      case 'remove':
-        // Only clear is supported by the model.
-        if (this.widgets.length) {
-          this._clear();
-          this.outputLengthChanged.emit(this.model.length);
+   * Follow changes to the datastore.
+   */
+  protected onChange(sender: Datastore, args: Datastore.IChangedArgs) {
+    // Keep track of the items that have been rendered.
+    const handled = new Set<string>();
+
+    // First, handle list removals and inserts.
+    const { schema, record } = this.data.record;
+    const listChange =
+      args.change[schema.id] &&
+      args.change[schema.id][record] &&
+      (args.change[schema.id][record]['outputs'] as ListField.Change<string>);
+    if (listChange) {
+      listChange.forEach(change => {
+        // Remove any disposed values
+        for (let i = 0; i < change.removed.length; i++) {
+          this.widgets[change.index].dispose();
         }
-        break;
-      case 'set':
-        this._setOutput(args.newIndex, args.newValues[0]);
-        this.outputLengthChanged.emit(this.model.length);
-        break;
-      default:
-        break;
+        // Insert new values
+        for (let i = 0; i < change.inserted.length; i++) {
+          const id = change.inserted[i];
+          const record = {
+            ...this.data.outputs,
+            record: id
+          };
+          this._insertOutput(change.index + i, record);
+          // Mark this item as having been rendered.
+          handled.add(id);
+        }
+      });
     }
-  }
-
-  /**
-   * Follow changes on the output model state.
-   */
-  protected onStateChanged(sender: IOutputAreaModel): void {
-    for (let i = 0; i < this.model.length; i++) {
-      this._setOutput(i, this.model.get(i));
+    // Check for changes to individual outputs.
+    const outputChanges = args.change[this.data.outputs.schema.id];
+    if (!outputChanges) {
+      return;
     }
-    this.outputLengthChanged.emit(this.model.length);
+    const outputs = DatastoreExt.getField(this.data.datastore, {
+      ...this.data.record,
+      field: 'outputs'
+    });
+    Object.keys(outputChanges).forEach(output => {
+      const index = outputs.indexOf(output);
+      // If this output belongs to us, and we have not rerendered it already,
+      // then rerender it in-place. This can happen when an output is updated
+      // or a stream is consolidated.
+      if (index !== -1 && !handled.has(output)) {
+        const record = {
+          ...this.data.outputs,
+          record: output
+        };
+        this._setOutput(index, record);
+      }
+    });
   }
 
   /**
@@ -312,7 +353,7 @@ export class OutputArea extends Widget {
      */
     void input.value.then(value => {
       // Use stdin as the stream so it does not get combined with stdout.
-      this.model.add({
+      this._appendItem({
         output_type: 'stream',
         name: 'stdin',
         text: value + '\n'
@@ -324,27 +365,44 @@ export class OutputArea extends Widget {
   /**
    * Update an output in the layout in place.
    */
-  private _setOutput(index: number, model: IOutputModel): void {
+  private _setOutput(
+    index: number,
+    loc: DatastoreExt.RecordLocation<IOutputData.Schema>
+  ): void {
     let layout = this.layout as PanelLayout;
     let panel = layout.widgets[index] as Panel;
     let renderer = (panel.widgets
       ? panel.widgets[1]
       : panel) as IRenderMime.IRenderer;
     if (renderer.renderModel) {
+      // Create a temporary output model view to pass of to the renderer.
+      let model = new OutputModel({
+        data: {
+          datastore: this.data.datastore,
+          record: loc
+        }
+      });
       void renderer.renderModel(model);
     } else {
       layout.widgets[index].dispose();
-      this._insertOutput(index, model);
+      this._insertOutput(index, loc);
     }
   }
 
   /**
    * Render and insert a single output into the layout.
    */
-  private _insertOutput(index: number, model: IOutputModel): void {
-    let output = this.createOutputItem(model);
+  private _insertOutput(
+    index: number,
+    loc: DatastoreExt.RecordLocation<IOutputData.Schema>
+  ): void {
+    let output = this.createOutputItem(loc);
+    let executionCount = DatastoreExt.getField(this.data.datastore, {
+      ...loc,
+      field: 'executionCount'
+    });
     if (output) {
-      output.toggleClass(EXECUTE_CLASS, model.executionCount !== null);
+      output.toggleClass(EXECUTE_CLASS, executionCount !== null);
     } else {
       output = new Widget();
     }
@@ -355,19 +413,26 @@ export class OutputArea extends Widget {
   /**
    * Create an output item with a prompt and actual output
    */
-  protected createOutputItem(model: IOutputModel): Widget | null {
-    let output = this.createRenderedMimetype(model);
+  protected createOutputItem(
+    loc: DatastoreExt.RecordLocation<IOutputData.Schema>
+  ): Widget | null {
+    let output = this.createRenderedMimetype(loc);
 
     if (!output) {
       return null;
     }
 
+    let executionCount = DatastoreExt.getField(this.data.datastore, {
+      ...loc,
+      field: 'executionCount'
+    });
+
     let panel = new Panel();
 
     panel.addClass(OUTPUT_AREA_ITEM_CLASS);
 
     let prompt = this.contentFactory.createOutputPrompt();
-    prompt.executionCount = model.executionCount;
+    prompt.executionCount = executionCount;
     prompt.addClass(OUTPUT_AREA_PROMPT_CLASS);
     panel.addWidget(prompt);
 
@@ -379,7 +444,16 @@ export class OutputArea extends Widget {
   /**
    * Render a mimetype
    */
-  protected createRenderedMimetype(model: IOutputModel): Widget | null {
+  protected createRenderedMimetype(
+    loc: DatastoreExt.RecordLocation<IOutputData.Schema>
+  ): Widget | null {
+    // Create a temporary output model view to pass of to the renderer.
+    let model = new OutputModel({
+      data: {
+        datastore: this.data.datastore,
+        record: loc
+      }
+    });
     let mimeType = this.rendermime.preferredMimeType(
       model.data,
       model.trusted ? 'any' : 'ensure'
@@ -423,7 +497,6 @@ export class OutputArea extends Widget {
    * Handle an iopub message.
    */
   private _onIOPub = (msg: KernelMessage.IIOPubMessage) => {
-    let model = this.model;
     let msgType = msg.header.msg_type;
     let output: nbformat.IOutput;
     let transient = ((msg.content as any).transient || {}) as JSONObject;
@@ -437,11 +510,17 @@ export class OutputArea extends Widget {
       case 'error':
         output = msg.content as nbformat.IOutput;
         output.output_type = msgType as nbformat.OutputType;
-        model.add(output);
+        this._appendItem(output);
         break;
       case 'clear_output':
+        // If a wait signal is recieved, mark the `_clearNext` flag so
+        // we can clear the output area after the next output.
         let wait = (msg as KernelMessage.IClearOutputMsg).content.wait;
-        model.clear(wait);
+        if (wait) {
+          this._clearNext = true;
+        } else {
+          OutputAreaData.clear(this.data);
+        }
         break;
       case 'update_display_data':
         output = msg.content as nbformat.IOutput;
@@ -449,7 +528,7 @@ export class OutputArea extends Widget {
         targets = this._displayIdMap.get(displayId);
         if (targets) {
           for (let index of targets) {
-            model.set(index, output);
+            OutputAreaData.setItem(this.data, index, output);
           }
         }
         break;
@@ -457,8 +536,12 @@ export class OutputArea extends Widget {
         break;
     }
     if (displayId && msgType === 'display_data') {
+      let list = DatastoreExt.getField(this.data.datastore, {
+        ...this.data.record,
+        field: 'outputs'
+      });
       targets = this._displayIdMap.get(displayId) || [];
-      targets.push(model.length - 1);
+      targets.push(list.length - 1);
       this._displayIdMap.set(displayId, targets);
     }
   };
@@ -470,7 +553,6 @@ export class OutputArea extends Widget {
     // API responses that contain a pager are special cased and their type
     // is overridden from 'execute_reply' to 'display_data' in order to
     // render output.
-    let model = this.model;
     let content = msg.content;
     if (content.status !== 'ok') {
       return;
@@ -489,15 +571,26 @@ export class OutputArea extends Widget {
       data: (page as any).data as nbformat.IMimeBundle,
       metadata: {}
     };
-    model.add(output);
+    this._appendItem(output);
   };
 
+  private _appendItem(output: nbformat.IOutput): void {
+    if (this._clearNext) {
+      OutputAreaData.clear(this.data);
+      this._clearNext = false;
+      return;
+    }
+    OutputAreaData.appendItem(this.data, output);
+  }
+
   private _minHeightTimeout: number = null;
   private _future: Kernel.IShellFuture<
     KernelMessage.IExecuteRequestMsg,
     KernelMessage.IExecuteReplyMsg
   > | null = null;
   private _displayIdMap = new Map<string, number[]>();
+  private _datastore: Datastore | null = null;
+  private _clearNext = false;
 }
 
 export class SimplifiedOutputArea extends OutputArea {
@@ -514,8 +607,10 @@ export class SimplifiedOutputArea extends OutputArea {
   /**
    * Create an output item without a prompt, just the output widgets
    */
-  protected createOutputItem(model: IOutputModel): Widget | null {
-    let output = this.createRenderedMimetype(model);
+  protected createOutputItem(
+    loc: DatastoreExt.RecordLocation<IOutputData.Schema>
+  ): Widget | null {
+    let output = this.createRenderedMimetype(loc);
     if (output) {
       output.addClass(OUTPUT_AREA_OUTPUT_CLASS);
     }
@@ -534,7 +629,7 @@ export namespace OutputArea {
     /**
      * The model used by the widget.
      */
-    model: IOutputAreaModel;
+    data?: IOutputAreaData.DataLocation;
 
     /**
      * The content factory used by the widget to create children.
diff --git a/packages/rendermime/src/index.ts b/packages/rendermime/src/index.ts
index e21201ea14d..949dfef41bb 100644
--- a/packages/rendermime/src/index.ts
+++ b/packages/rendermime/src/index.ts
@@ -4,7 +4,6 @@
 |----------------------------------------------------------------------------*/
 
 export * from '@jupyterlab/rendermime-interfaces';
-export * from './attachmentmodel';
 export * from './factories';
 export * from './latex';
 export * from './mimemodel';
diff --git a/packages/rendermime/src/outputmodel.ts b/packages/rendermime/src/outputmodel.ts
index 0624057d172..42efebd665a 100644
--- a/packages/rendermime/src/outputmodel.ts
+++ b/packages/rendermime/src/outputmodel.ts
@@ -2,6 +2,12 @@
 | Copyright (c) Jupyter Development Team.
 | Distributed under the terms of the Modified BSD License.
 |----------------------------------------------------------------------------*/
+import { nbformat } from '@jupyterlab/coreutils';
+
+import { DatastoreExt } from '@jupyterlab/datastore';
+
+import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
+
 import {
   JSONExt,
   JSONObject,
@@ -9,25 +15,105 @@ import {
   ReadonlyJSONObject
 } from '@lumino/coreutils';
 
-import { ISignal, Signal } from '@lumino/signaling';
+import { Datastore, Fields, Record, RegisterField } from '@lumino/datastore';
 
-import { nbformat } from '@jupyterlab/coreutils';
+import { MimeModel } from './mimemodel';
 
-import { IObservableJSON, ObservableJSON } from '@jupyterlab/observables';
+/**
+ * A namespace for interfaces describing where an IOutputModel
+ * holds its data.
+ */
+export namespace IOutputData {
+  /**
+   * A type alias for the ouput model schema.
+   */
+  export type Schema = {
+    /**
+     * The id for the schema.
+     */
+    id: string;
 
-import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
+    /**
+     * The fields for a single output.
+     */
+    fields: {
+      /**
+       * Whether the output model is trusted.
+       */
+      trusted: RegisterField<boolean>;
+
+      /**
+       * The type of the output model.
+       */
+      type: RegisterField<string>;
+
+      /**
+       * The execution count of the model.
+       */
+      executionCount: RegisterField<nbformat.ExecutionCount>;
+
+      /**
+       * The data for the model.
+       */
+      data: RegisterField<ReadonlyJSONObject>;
+
+      /**
+       * The metadata for the model.
+       */
+      metadata: RegisterField<ReadonlyJSONObject>;
+
+      /**
+       * Raw data passed in that is not in the data or metadata fields.
+       */
+      raw: RegisterField<ReadonlyJSONObject>;
+    };
+  };
 
-import { MimeModel } from './mimemodel';
+  /**
+   * A description of where data is stored in a code editor.
+   */
+  export type DataLocation = DatastoreExt.DataLocation & {
+    /**
+     * The record in which the data is located.
+     */
+    record: DatastoreExt.RecordLocation<Schema>;
+  };
+}
 
 /**
- * The interface for an output model.
+ * A namespace for default implementation of the IOutputData functionality.
  */
-export interface IOutputModel extends IRenderMime.IMimeModel {
+export namespace OutputData {
   /**
-   * A signal emitted when the output model changes.
+   * A concrete realization of the schema, available at runtime.
    */
-  readonly changed: ISignal<this, void>;
+  export const SCHEMA: IOutputData.Schema = {
+    id: '@jupyterlab/rendermime:outputmodel.v1',
+    fields: {
+      trusted: Fields.Boolean(),
+      type: Fields.String(),
+      executionCount: Fields.Register<nbformat.ExecutionCount>({ value: null }),
+      data: Fields.Register<ReadonlyJSONObject>({ value: {} }),
+      metadata: Fields.Register<ReadonlyJSONObject>({ value: {} }),
+      raw: Fields.Register<ReadonlyJSONObject>({ value: {} })
+    }
+  };
 
+  /**
+   * Create an in-memory datastore capable of holding the data for an output.
+   */
+  export function createStore(id: number = 1): Datastore {
+    return Datastore.create({
+      id,
+      schemas: [SCHEMA]
+    });
+  }
+}
+
+/**
+ * The interface for an output model.
+ */
+export interface IOutputModel extends IRenderMime.IMimeModel {
   /**
    * The output type.
    */
@@ -55,7 +141,7 @@ export interface IOutputModel extends IRenderMime.IMimeModel {
 }
 
 /**
- * The namespace for IOutputModel sub-interfaces.
+ * A namespace for IOutputModel statics.
  */
 export namespace IOutputModel {
   /**
@@ -65,12 +151,17 @@ export namespace IOutputModel {
     /**
      * The raw output value.
      */
-    value: nbformat.IOutput;
+    value?: nbformat.IOutput;
 
     /**
      * Whether the output is trusted.  The default is false.
      */
     trusted?: boolean;
+
+    /**
+     * A location in which to store the data.
+     */
+    data?: IOutputData.DataLocation;
   }
 }
 
@@ -82,75 +173,85 @@ export class OutputModel implements IOutputModel {
    * Construct a new output model.
    */
   constructor(options: IOutputModel.IOptions) {
-    let { data, metadata, trusted } = Private.getBundleOptions(options);
-    this._data = new ObservableJSON({ values: data as JSONObject });
-    this._rawData = data;
-    this._metadata = new ObservableJSON({ values: metadata as JSONObject });
-    this._rawMetadata = metadata;
-    this.trusted = trusted;
-    // Make a copy of the data.
-    let value = options.value;
-    for (let key in value) {
-      // Ignore data and metadata that were stripped.
-      switch (key) {
-        case 'data':
-        case 'metadata':
-          break;
-        default:
-          this._raw[key] = Private.extract(value, key);
-      }
-    }
-    this.type = value.output_type;
-    if (nbformat.isExecuteResult(value)) {
-      this.executionCount = value.execution_count;
+    if (options.data) {
+      this._data = options.data;
     } else {
-      this.executionCount = null;
+      this._datastore = OutputData.createStore();
+      this._data = {
+        datastore: this._datastore,
+        record: {
+          schema: OutputData.SCHEMA,
+          record: 'data'
+        }
+      };
+      if (options.value) {
+        OutputModel.fromJSON(this._data, options.value, options.trusted);
+      }
     }
   }
 
-  /**
-   * A signal emitted when the output model changes.
-   */
-  get changed(): ISignal<this, void> {
-    return this._changed;
-  }
-
   /**
    * The output type.
    */
-  readonly type: string;
+  get type(): string {
+    return DatastoreExt.getField(this._data.datastore, {
+      ...this._data.record,
+      field: 'type'
+    });
+  }
 
   /**
    * The execution count.
    */
-  readonly executionCount: nbformat.ExecutionCount;
+  get executionCount(): nbformat.ExecutionCount {
+    return DatastoreExt.getField(this._data.datastore, {
+      ...this._data.record,
+      field: 'executionCount'
+    });
+  }
 
   /**
    * Whether the model is trusted.
    */
-  readonly trusted: boolean;
+  get trusted(): boolean {
+    return DatastoreExt.getField(this._data.datastore, {
+      ...this._data.record,
+      field: 'trusted'
+    });
+  }
 
   /**
    * Dispose of the resources used by the output model.
    */
   dispose(): void {
-    this._data.dispose();
-    this._metadata.dispose();
-    Signal.clearData(this);
+    if (this._isDisposed) {
+      return;
+    }
+    this._isDisposed = true;
+    if (this._datastore) {
+      this._datastore.dispose();
+      this._datastore = null;
+    }
   }
 
   /**
    * The data associated with the model.
    */
   get data(): ReadonlyJSONObject {
-    return this._rawData;
+    return DatastoreExt.getField(this._data.datastore, {
+      ...this._data.record,
+      field: 'data'
+    });
   }
 
   /**
    * The metadata associated with the model.
    */
   get metadata(): ReadonlyJSONObject {
-    return this._rawMetadata;
+    return DatastoreExt.getField(this._data.datastore, {
+      ...this._data.record,
+      field: 'metadata'
+    });
   }
 
   /**
@@ -161,73 +262,36 @@ export class OutputModel implements IOutputModel {
    * this call may or may not have deferred effects,
    */
   setData(options: IRenderMime.IMimeModel.ISetDataOptions): void {
+    let metadataUpdate: Record.Update<IOutputData.Schema> = {};
+    let dataUpdate: Record.Update<IOutputData.Schema> = {};
     if (options.data) {
-      this._updateObservable(this._data, options.data);
-      this._rawData = options.data;
+      dataUpdate = { data: options.data };
     }
     if (options.metadata) {
-      this._updateObservable(this._metadata, options.metadata);
-      this._rawMetadata = options.metadata;
+      metadataUpdate = { metadata: options.metadata };
     }
-    this._changed.emit(void 0);
+    const { datastore, record } = this._data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateRecord(datastore, record, {
+        ...dataUpdate,
+        ...metadataUpdate
+      });
+    });
   }
 
   /**
    * Serialize the model to JSON.
    */
   toJSON(): nbformat.IOutput {
-    let output: JSONValue = {};
-    for (let key in this._raw) {
-      output[key] = Private.extract(this._raw, key);
-    }
-    switch (this.type) {
-      case 'display_data':
-      case 'execute_result':
-      case 'update_display_data':
-        output['data'] = this.data as JSONObject;
-        output['metadata'] = this.metadata as JSONObject;
-        break;
-      default:
-        break;
-    }
-    // Remove transient data.
-    delete output['transient'];
-    return output as nbformat.IOutput;
+    return OutputModel.toJSON(this._data);
   }
 
   /**
-   * Update an observable JSON object using a readonly JSON object.
+   * The record in which the output model is stored.
    */
-  private _updateObservable(
-    observable: IObservableJSON,
-    data: ReadonlyJSONObject
-  ) {
-    let oldKeys = observable.keys();
-    let newKeys = Object.keys(data);
-
-    // Handle removed keys.
-    for (let key of oldKeys) {
-      if (newKeys.indexOf(key) === -1) {
-        observable.delete(key);
-      }
-    }
-
-    // Handle changed data.
-    for (let key of newKeys) {
-      let oldValue = observable.get(key);
-      let newValue = data[key];
-      if (oldValue !== newValue) {
-        observable.set(key, newValue as JSONValue);
-      }
-    }
-  }
-
-  private _changed = new Signal<this, void>(this);
-  private _raw: JSONObject = {};
-  private _rawMetadata: ReadonlyJSONObject;
-  private _rawData: ReadonlyJSONObject;
-  private _data: IObservableJSON;
-  private _metadata: IObservableJSON;
+  private readonly _data: IOutputData.DataLocation;
+  private _datastore: Datastore | null = null;
+  private _isDisposed = false;
 }
 
 /**
@@ -255,6 +319,91 @@ export namespace OutputModel {
   export function getMetadata(output: nbformat.IOutput): JSONObject {
     return Private.getMetadata(output);
   }
+
+  /**
+   * Serialize an output record to JSON.
+   */
+  export function toJSON(loc: IOutputData.DataLocation): nbformat.IOutput {
+    let { datastore, record } = loc;
+    let output: JSONObject = DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'raw'
+    }) as JSONObject;
+    const type = DatastoreExt.getField(datastore, { ...record, field: 'type' });
+    const data = DatastoreExt.getField(datastore, { ...record, field: 'data' });
+    const metadata = DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'metadata'
+    });
+    switch (type) {
+      case 'display_data':
+      case 'execute_result':
+      case 'update_display_data':
+        output['data'] = data as JSONValue;
+        output['metadata'] = metadata as JSONValue;
+        break;
+      default:
+        break;
+    }
+    // Remove transient data.
+    delete output['transient'];
+    return output as nbformat.IOutput;
+  }
+
+  export function fromJSON(
+    loc: IOutputData.DataLocation,
+    value: nbformat.IOutput,
+    trusted: boolean = false
+  ): void {
+    const { datastore, record } = loc;
+    let data = Private.getData(value);
+    let metadata = Private.getData(value);
+    trusted = !!trusted;
+
+    let raw: { [x: string]: JSONValue } = {};
+    for (let key in value) {
+      // Ignore data and metadata that were stripped.
+      switch (key) {
+        case 'data':
+        case 'metadata':
+          break;
+        default:
+          raw[key] = Private.extract(value, key);
+      }
+    }
+    const type = value.output_type;
+    const executionCount = nbformat.isExecuteResult(value)
+      ? value.execution_count
+      : null;
+
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateRecord(datastore, record, {
+        data,
+        executionCount,
+        metadata,
+        raw,
+        trusted,
+        type
+      });
+    });
+  }
+
+  /**
+   * Clear an output record from a table.
+   */
+  export function clear(loc: IOutputData.DataLocation): void {
+    const { datastore, record } = loc;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateRecord(datastore, record, {
+        data: {},
+        executionCount: null,
+        metadata: {},
+        raw: {},
+        trusted: false,
+        type: ''
+      });
+    });
+  }
 }
 
 /**
diff --git a/packages/services/src/contents/index.ts b/packages/services/src/contents/index.ts
index 79be3a6c5f2..905b161e742 100644
--- a/packages/services/src/contents/index.ts
+++ b/packages/services/src/contents/index.ts
@@ -3,8 +3,6 @@
 
 import { URLExt, PathExt } from '@jupyterlab/coreutils';
 
-import { ModelDB } from '@jupyterlab/observables';
-
 import { JSONObject } from '@lumino/coreutils';
 
 import { each } from '@lumino/algorithm';
@@ -253,13 +251,6 @@ export namespace Contents {
      */
     driveName(path: string): string;
 
-    /**
-     * Given a path, get a ModelDB.IFactory from the
-     * relevant backend. Returns `null` if the backend
-     * does not provide one.
-     */
-    getModelDBFactory(path: string): ModelDB.IFactory | null;
-
     /**
      * Get a file or directory.
      *
@@ -393,12 +384,6 @@ export namespace Contents {
      */
     readonly serverSettings: ServerConnection.ISettings;
 
-    /**
-     * An optional ModelDB.IFactory instance for the
-     * drive.
-     */
-    readonly modelDBFactory?: ModelDB.IFactory;
-
     /**
      * A signal emitted when a file operation takes place.
      */
@@ -581,16 +566,6 @@ export class ContentsManager implements Contents.IManager {
     drive.fileChanged.connect(this._onFileChanged, this);
   }
 
-  /**
-   * Given a path, get a ModelDB.IFactory from the
-   * relevant backend. Returns `null` if the backend
-   * does not provide one.
-   */
-  getModelDBFactory(path: string): ModelDB.IFactory | null {
-    let [drive] = this._driveForPath(path);
-    return (drive && drive.modelDBFactory) || null;
-  }
-
   /**
    * Given a path of the form `drive:local/portion/of/it.txt`
    * get the local part of it.
diff --git a/packages/services/src/index.ts b/packages/services/src/index.ts
index fc86490bf28..a78a8595407 100644
--- a/packages/services/src/index.ts
+++ b/packages/services/src/index.ts
@@ -10,6 +10,7 @@ export * from './session';
 export * from './setting';
 export * from './terminal';
 export * from './workspace';
+export * from './wsconnection';
 export * from './nbconvert';
 
 export { Builder } from './builder';

diff --git a/packages/settingeditor/src/raweditor.ts b/packages/settingeditor/src/raweditor.ts
index d88ea31c264..40e85646cb5 100644
--- a/packages/settingeditor/src/raweditor.ts
+++ b/packages/settingeditor/src/raweditor.ts
@@ -7,6 +7,8 @@ import { CodeEditor, CodeEditorWrapper } from '@jupyterlab/codeeditor';
 
 import { ISettingRegistry } from '@jupyterlab/coreutils';
 
+import { DatastoreExt } from '@jupyterlab/datastore';
+
 import { IRenderMimeRegistry } from '@jupyterlab/rendermime';
 
 import { CommandRegistry } from '@lumino/commands';
@@ -71,7 +73,7 @@ export class RawEditor extends SplitPanel {
       factory: editorFactory
     }));
 
-    defaults.editor.model.value.text = '';
+    defaults.editor.model.value = '';
     defaults.editor.model.mimeType = 'text/javascript';
     defaults.editor.setOption('readOnly', true);
 
@@ -84,7 +86,12 @@ export class RawEditor extends SplitPanel {
 
     user.addClass(USER_CLASS);
     user.editor.model.mimeType = 'text/javascript';
-    user.editor.model.value.changed.connect(this._onTextChanged, this);
+    DatastoreExt.listenField(
+      user.editor.model.data.datastore,
+      { ...user.editor.model.data.record, field: 'text' },
+      this._onTextChanged,
+      this
+    );
 
     // Create and set up an inspector.
     this._inspector = createInspector(this, options.rendermime);
@@ -125,7 +132,7 @@ export class RawEditor extends SplitPanel {
    * Tests whether the settings have been modified and need saving.
    */
   get isDirty(): boolean {
-    return this._user.editor.model.value.text !== this._settings.raw;
+    return this._user.editor.model.value !== this._settings.raw;
   }
 
   /**
@@ -160,8 +167,8 @@ export class RawEditor extends SplitPanel {
       this._onSettingsChanged();
     } else {
       this._settings = null;
-      defaults.editor.model.value.text = '';
-      user.editor.model.value.text = '';
+      defaults.editor.model.value = '';
+      user.editor.model.value = '';
     }
 
     this.update();
@@ -201,7 +208,7 @@ export class RawEditor extends SplitPanel {
    * Revert the editor back to original settings.
    */
   revert(): void {
-    this._user.editor.model.value.text = this.settings.raw;
+    this._user.editor.model.value = this.settings.raw;
     this._updateToolbar(false, false);
   }
 
@@ -214,7 +221,7 @@ export class RawEditor extends SplitPanel {
     }
 
     const settings = this._settings;
-    const source = this._user.editor.model.value.text;
+    const source = this._user.editor.model.value;
 
     return settings
       .save(source)
@@ -253,7 +260,7 @@ export class RawEditor extends SplitPanel {
    * Handle text changes in the underlying editor.
    */
   private _onTextChanged(): void {
-    const raw = this._user.editor.model.value.text;
+    const raw = this._user.editor.model.value;
     const settings = this._settings;
 
     this.removeClass(ERROR_CLASS);
@@ -283,8 +290,8 @@ export class RawEditor extends SplitPanel {
     const defaults = this._defaults;
     const user = this._user;
 
-    defaults.editor.model.value.text = settings.annotatedDefaults();
-    user.editor.model.value.text = settings.raw;
+    defaults.editor.model.value = settings.annotatedDefaults();
+    user.editor.model.value = settings.raw;
   }
 
   private _updateToolbar(revert = this._canRevert, save = this._canSave): void {
diff --git a/packages/statusbar-extension/src/index.ts b/packages/statusbar-extension/src/index.ts
index 0628a1b6173..fa8138a226c 100644
--- a/packages/statusbar-extension/src/index.ts
+++ b/packages/statusbar-extension/src/index.ts
@@ -253,7 +253,11 @@ export const lineColItem: JupyterFrontEndPlugin<void> = {
         );
         const cell = (newValue as NotebookPanel).content.activeCell;
         item.model!.editor = cell && cell.editor;
-      } else if (newValue && editorTracker.has(newValue)) {
+      } else if (
+        newValue &&
+        editorTracker.has(newValue) &&
+        (newValue as IDocumentWidget<FileEditor>).content.editor
+      ) {
         item.model!.editor = (newValue as IDocumentWidget<
           FileEditor
         >).content.editor;
diff --git a/packages/statusbar/src/defaults/lineCol.tsx b/packages/statusbar/src/defaults/lineCol.tsx
index 2240c2da940..653626d95c3 100644
--- a/packages/statusbar/src/defaults/lineCol.tsx
+++ b/packages/statusbar/src/defaults/lineCol.tsx
@@ -7,6 +7,10 @@ import { VDomRenderer, VDomModel, ReactWidget } from '@jupyterlab/apputils';
 
 import { CodeEditor } from '@jupyterlab/codeeditor';
 
+import { DatastoreExt } from '@jupyterlab/datastore';
+
+import { IDisposable } from '@lumino/disposable';
+
 import { interactiveItem, showPopup, Popup, TextItem } from '..';
 
 import {
@@ -290,9 +294,9 @@ export namespace LineCol {
       return this._editor;
     }
     set editor(editor: CodeEditor.IEditor | null) {
-      const oldEditor = this._editor;
-      if (oldEditor) {
-        oldEditor.model.selections.changed.disconnect(this._onSelectionChanged);
+      if (this._selectionListener) {
+        this._selectionListener.dispose();
+        this._selectionListener = null;
       }
 
       const oldState = this._getAllState();
@@ -301,7 +305,11 @@ export namespace LineCol {
         this._column = 1;
         this._line = 1;
       } else {
-        this._editor.model.selections.changed.connect(this._onSelectionChanged);
+        DatastoreExt.listenField(
+          editor.model.data.datastore,
+          { ...editor.model.data.record, field: 'selections' },
+          this._onSelectionChanged
+        );
 
         const pos = this._editor.getCursorPosition();
         this._column = pos.column + 1;
@@ -353,5 +361,6 @@ export namespace LineCol {
     private _line: number = 1;
     private _column: number = 1;
     private _editor: CodeEditor.IEditor | null = null;
+    private _selectionListener: IDisposable | null = null;
   }
 }
diff --git a/packages/tooltip-extension/src/index.ts b/packages/tooltip-extension/src/index.ts
index e1360b310b7..e69dde42ddb 100644
--- a/packages/tooltip-extension/src/index.ts
+++ b/packages/tooltip-extension/src/index.ts
@@ -292,7 +292,7 @@ namespace Private {
    */
   export function fetch(options: IFetchOptions): Promise<JSONObject> {
     let { detail, editor, kernel } = options;
-    let code = editor.model.value.text;
+    let code = editor.model.value;
     let position = editor.getCursorPosition();
     let offset = Text.jsIndexToCharIndex(editor.getOffsetAt(position), code);
