diff --git a/packages/outputarea/src/index.ts b/packages/outputarea/src/index.ts
index dba46488e23..02a73b2e475 100644
--- a/packages/outputarea/src/index.ts
+++ b/packages/outputarea/src/index.ts
@@ -1,5 +1,5 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-export * from './model';
+export * from './data';
 export * from './widget';

diff --git a/packages/outputarea/src/widget.ts b/packages/outputarea/src/widget.ts
index 13e13411f82..c118a92c52c 100644
--- a/packages/outputarea/src/widget.ts
+++ b/packages/outputarea/src/widget.ts
@@ -1,31 +1,38 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
+import { IClientSession } from '@jupyterlab/apputils';
+
+import { nbformat } from '@jupyterlab/coreutils';
+
+import { DatastoreExt } from '@jupyterlab/datastore';
+
+import {
+  IOutputData,
+  IRenderMimeRegistry,
+  OutputData,
+  OutputModel
+} from '@jupyterlab/rendermime';
+
+import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
+
+import { Kernel, KernelMessage } from '@jupyterlab/services';
+
 import {
   JSONObject,
   PromiseDelegate,
   ReadonlyJSONObject
 } from '@lumino/coreutils';
 
+import { Datastore, ListField } from '@lumino/datastore';
+
 import { Message } from '@lumino/messaging';
 
 import { Signal } from '@lumino/signaling';
 
-import { Panel, PanelLayout } from '@lumino/widgets';
-
-import { Widget } from '@lumino/widgets';
-
-import { IClientSession } from '@jupyterlab/apputils';
-
-import { nbformat } from '@jupyterlab/coreutils';
+import { Panel, PanelLayout, Widget } from '@lumino/widgets';
 
-import { IOutputModel, IRenderMimeRegistry } from '@jupyterlab/rendermime';
-
-import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
-
-import { Kernel, KernelMessage } from '@jupyterlab/services';
-
-import { IOutputAreaModel } from './model';
+import { IOutputAreaData, OutputAreaData } from './data';
 
 /**
  * The class name added to an output area widget.
@@ -83,12 +90,6 @@ const STDIN_INPUT_CLASS = 'jp-Stdin-input';
 
 /**
  * An output area widget.
- *
- * #### Notes
- * The widget model must be set separately and can be changed
- * at any time.  Consumers of the widget must account for a
- * `null` model, and may want to listen to the `modelChanged`
- * signal.
  */
 export class OutputArea extends Widget {
   /**
@@ -96,24 +97,42 @@ export class OutputArea extends Widget {
    */
   constructor(options: OutputArea.IOptions) {
     super();
-    let model = (this.model = options.model);
+    let data: IOutputAreaData.DataLocation;
+    if (options.data) {
+      data = this.data = options.data;
+    } else {
+      const datastore = (this._datastore = OutputAreaData.createStore());
+      data = this.data = {
+        datastore,
+        record: {
+          schema: OutputAreaData.SCHEMA,
+          record: 'data'
+        },
+        outputs: {
+          schema: OutputData.SCHEMA
+        }
+      };
+    }
     this.addClass(OUTPUT_AREA_CLASS);
     this.rendermime = options.rendermime;
     this.contentFactory =
       options.contentFactory || OutputArea.defaultContentFactory;
     this.layout = new PanelLayout();
-    for (let i = 0; i < model.length; i++) {
-      let output = model.get(i);
-      this._insertOutput(i, output);
+    const list = DatastoreExt.getField(data.datastore, {
+      ...data.record,
+      field: 'outputs'
+    });
+    for (let i = 0; i < list.length; i++) {
+      this._insertOutput(i, { ...data.outputs, record: list[i] });
     }
-    model.changed.connect(this.onModelChanged, this);
-    model.stateChanged.connect(this.onStateChanged, this);
+
+    data.datastore.changed.connect(this.onChange, this);
   }
 
   /**
-   * The model used by the widget.
+   * The data rendered by the widget.
    */
-  readonly model: IOutputAreaModel;
+  readonly data: IOutputAreaData.DataLocation;
 
   /**
    * The content factory used by the widget.
@@ -157,10 +176,6 @@ export class OutputArea extends Widget {
       KernelMessage.IExecuteReplyMsg
     > | null
   ) {
-    // Bail if the model is disposed.
-    if (this.model.isDisposed) {
-      throw Error('Model is disposed');
-    }
     if (this._future === value) {
       return;
     }
@@ -169,12 +184,12 @@ export class OutputArea extends Widget {
     }
     this._future = value;
 
-    this.model.clear();
+    OutputAreaData.clear(this.data);
 
     // Make sure there were no input widgets.
     if (this.widgets.length) {
       this._clear();
-      this.outputLengthChanged.emit(this.model.length);
+      this.outputLengthChanged.emit(0);
     }
 
     // Handle published messages.
@@ -195,50 +210,76 @@ export class OutputArea extends Widget {
    * Dispose of the resources used by the output area.
    */
   dispose(): void {
+    if (this.isDisposed) {
+      return;
+    }
+    if (this._datastore) {
+      this._datastore.dispose();
+      this._datastore = null;
+    }
+
     if (this._future) {
       this._future.dispose();
     }
     this._future = null;
     this._displayIdMap.clear();
+    Signal.clearData(this);
     super.dispose();
   }
-
   /**
-   * Follow changes on the model state.
-   */
-  protected onModelChanged(
-    sender: IOutputAreaModel,
-    args: IOutputAreaModel.ChangedArgs
-  ): void {
-    switch (args.type) {
-      case 'add':
-        this._insertOutput(args.newIndex, args.newValues[0]);
-        this.outputLengthChanged.emit(this.model.length);
-        break;
-      case 'remove':
-        // Only clear is supported by the model.
-        if (this.widgets.length) {
-          this._clear();
-          this.outputLengthChanged.emit(this.model.length);
+   * Follow changes to the datastore.
+   */
+  protected onChange(sender: Datastore, args: Datastore.IChangedArgs) {
+    // Keep track of the items that have been rendered.
+    const handled = new Set<string>();
+
+    // First, handle list removals and inserts.
+    const { schema, record } = this.data.record;
+    const listChange =
+      args.change[schema.id] &&
+      args.change[schema.id][record] &&
+      (args.change[schema.id][record]['outputs'] as ListField.Change<string>);
+    if (listChange) {
+      listChange.forEach(change => {
+        // Remove any disposed values
+        for (let i = 0; i < change.removed.length; i++) {
+          this.widgets[change.index].dispose();
         }
-        break;
-      case 'set':
-        this._setOutput(args.newIndex, args.newValues[0]);
-        this.outputLengthChanged.emit(this.model.length);
-        break;
-      default:
-        break;
+        // Insert new values
+        for (let i = 0; i < change.inserted.length; i++) {
+          const id = change.inserted[i];
+          const record = {
+            ...this.data.outputs,
+            record: id
+          };
+          this._insertOutput(change.index + i, record);
+          // Mark this item as having been rendered.
+          handled.add(id);
+        }
+      });
     }
-  }
-
-  /**
-   * Follow changes on the output model state.
-   */
-  protected onStateChanged(sender: IOutputAreaModel): void {
-    for (let i = 0; i < this.model.length; i++) {
-      this._setOutput(i, this.model.get(i));
+    // Check for changes to individual outputs.
+    const outputChanges = args.change[this.data.outputs.schema.id];
+    if (!outputChanges) {
+      return;
     }
-    this.outputLengthChanged.emit(this.model.length);
+    const outputs = DatastoreExt.getField(this.data.datastore, {
+      ...this.data.record,
+      field: 'outputs'
+    });
+    Object.keys(outputChanges).forEach(output => {
+      const index = outputs.indexOf(output);
+      // If this output belongs to us, and we have not rerendered it already,
+      // then rerender it in-place. This can happen when an output is updated
+      // or a stream is consolidated.
+      if (index !== -1 && !handled.has(output)) {
+        const record = {
+          ...this.data.outputs,
+          record: output
+        };
+        this._setOutput(index, record);
+      }
+    });
   }
 
   /**
@@ -312,7 +353,7 @@ export class OutputArea extends Widget {
      */
     void input.value.then(value => {
       // Use stdin as the stream so it does not get combined with stdout.
-      this.model.add({
+      this._appendItem({
         output_type: 'stream',
         name: 'stdin',
         text: value + '\n'
@@ -324,27 +365,44 @@ export class OutputArea extends Widget {
   /**
    * Update an output in the layout in place.
    */
-  private _setOutput(index: number, model: IOutputModel): void {
+  private _setOutput(
+    index: number,
+    loc: DatastoreExt.RecordLocation<IOutputData.Schema>
+  ): void {
     let layout = this.layout as PanelLayout;
     let panel = layout.widgets[index] as Panel;
     let renderer = (panel.widgets
       ? panel.widgets[1]
       : panel) as IRenderMime.IRenderer;
     if (renderer.renderModel) {
+      // Create a temporary output model view to pass of to the renderer.
+      let model = new OutputModel({
+        data: {
+          datastore: this.data.datastore,
+          record: loc
+        }
+      });
       void renderer.renderModel(model);
     } else {
       layout.widgets[index].dispose();
-      this._insertOutput(index, model);
+      this._insertOutput(index, loc);
     }
   }
 
   /**
    * Render and insert a single output into the layout.
    */
-  private _insertOutput(index: number, model: IOutputModel): void {
-    let output = this.createOutputItem(model);
+  private _insertOutput(
+    index: number,
+    loc: DatastoreExt.RecordLocation<IOutputData.Schema>
+  ): void {
+    let output = this.createOutputItem(loc);
+    let executionCount = DatastoreExt.getField(this.data.datastore, {
+      ...loc,
+      field: 'executionCount'
+    });
     if (output) {
-      output.toggleClass(EXECUTE_CLASS, model.executionCount !== null);
+      output.toggleClass(EXECUTE_CLASS, executionCount !== null);
     } else {
       output = new Widget();
     }
@@ -355,19 +413,26 @@ export class OutputArea extends Widget {
   /**
    * Create an output item with a prompt and actual output
    */
-  protected createOutputItem(model: IOutputModel): Widget | null {
-    let output = this.createRenderedMimetype(model);
+  protected createOutputItem(
+    loc: DatastoreExt.RecordLocation<IOutputData.Schema>
+  ): Widget | null {
+    let output = this.createRenderedMimetype(loc);
 
     if (!output) {
       return null;
     }
 
+    let executionCount = DatastoreExt.getField(this.data.datastore, {
+      ...loc,
+      field: 'executionCount'
+    });
+
     let panel = new Panel();
 
     panel.addClass(OUTPUT_AREA_ITEM_CLASS);
 
     let prompt = this.contentFactory.createOutputPrompt();
-    prompt.executionCount = model.executionCount;
+    prompt.executionCount = executionCount;
     prompt.addClass(OUTPUT_AREA_PROMPT_CLASS);
     panel.addWidget(prompt);
 
@@ -379,7 +444,16 @@ export class OutputArea extends Widget {
   /**
    * Render a mimetype
    */
-  protected createRenderedMimetype(model: IOutputModel): Widget | null {
+  protected createRenderedMimetype(
+    loc: DatastoreExt.RecordLocation<IOutputData.Schema>
+  ): Widget | null {
+    // Create a temporary output model view to pass of to the renderer.
+    let model = new OutputModel({
+      data: {
+        datastore: this.data.datastore,
+        record: loc
+      }
+    });
     let mimeType = this.rendermime.preferredMimeType(
       model.data,
       model.trusted ? 'any' : 'ensure'
@@ -423,7 +497,6 @@ export class OutputArea extends Widget {
    * Handle an iopub message.
    */
   private _onIOPub = (msg: KernelMessage.IIOPubMessage) => {
-    let model = this.model;
     let msgType = msg.header.msg_type;
     let output: nbformat.IOutput;
     let transient = ((msg.content as any).transient || {}) as JSONObject;
@@ -437,11 +510,17 @@ export class OutputArea extends Widget {
       case 'error':
         output = msg.content as nbformat.IOutput;
         output.output_type = msgType as nbformat.OutputType;
-        model.add(output);
+        this._appendItem(output);
         break;
       case 'clear_output':
+        // If a wait signal is recieved, mark the `_clearNext` flag so
+        // we can clear the output area after the next output.
         let wait = (msg as KernelMessage.IClearOutputMsg).content.wait;
-        model.clear(wait);
+        if (wait) {
+          this._clearNext = true;
+        } else {
+          OutputAreaData.clear(this.data);
+        }
         break;
       case 'update_display_data':
         output = msg.content as nbformat.IOutput;
@@ -449,7 +528,7 @@ export class OutputArea extends Widget {
         targets = this._displayIdMap.get(displayId);
         if (targets) {
           for (let index of targets) {
-            model.set(index, output);
+            OutputAreaData.setItem(this.data, index, output);
           }
         }
         break;
@@ -457,8 +536,12 @@ export class OutputArea extends Widget {
         break;
     }
     if (displayId && msgType === 'display_data') {
+      let list = DatastoreExt.getField(this.data.datastore, {
+        ...this.data.record,
+        field: 'outputs'
+      });
       targets = this._displayIdMap.get(displayId) || [];
-      targets.push(model.length - 1);
+      targets.push(list.length - 1);
       this._displayIdMap.set(displayId, targets);
     }
   };
@@ -470,7 +553,6 @@ export class OutputArea extends Widget {
     // API responses that contain a pager are special cased and their type
     // is overridden from 'execute_reply' to 'display_data' in order to
     // render output.
-    let model = this.model;
     let content = msg.content;
     if (content.status !== 'ok') {
       return;
@@ -489,15 +571,26 @@ export class OutputArea extends Widget {
       data: (page as any).data as nbformat.IMimeBundle,
       metadata: {}
     };
-    model.add(output);
+    this._appendItem(output);
   };
 
+  private _appendItem(output: nbformat.IOutput): void {
+    if (this._clearNext) {
+      OutputAreaData.clear(this.data);
+      this._clearNext = false;
+      return;
+    }
+    OutputAreaData.appendItem(this.data, output);
+  }
+
   private _minHeightTimeout: number = null;
   private _future: Kernel.IShellFuture<
     KernelMessage.IExecuteRequestMsg,
     KernelMessage.IExecuteReplyMsg
   > | null = null;
   private _displayIdMap = new Map<string, number[]>();
+  private _datastore: Datastore | null = null;
+  private _clearNext = false;
 }
 
 export class SimplifiedOutputArea extends OutputArea {
@@ -514,8 +607,10 @@ export class SimplifiedOutputArea extends OutputArea {
   /**
    * Create an output item without a prompt, just the output widgets
    */
-  protected createOutputItem(model: IOutputModel): Widget | null {
-    let output = this.createRenderedMimetype(model);
+  protected createOutputItem(
+    loc: DatastoreExt.RecordLocation<IOutputData.Schema>
+  ): Widget | null {
+    let output = this.createRenderedMimetype(loc);
     if (output) {
       output.addClass(OUTPUT_AREA_OUTPUT_CLASS);
     }
@@ -534,7 +629,7 @@ export namespace OutputArea {
     /**
      * The model used by the widget.
      */
-    model: IOutputAreaModel;
+    data?: IOutputAreaData.DataLocation;
 
     /**
      * The content factory used by the widget to create children.
diff --git a/packages/rendermime/src/index.ts b/packages/rendermime/src/index.ts
index e21201ea14d..949dfef41bb 100644
--- a/packages/rendermime/src/index.ts
+++ b/packages/rendermime/src/index.ts
@@ -4,7 +4,6 @@
 |----------------------------------------------------------------------------*/
 
 export * from '@jupyterlab/rendermime-interfaces';
-export * from './attachmentmodel';
 export * from './factories';
 export * from './latex';
 export * from './mimemodel';
diff --git a/packages/rendermime/src/outputmodel.ts b/packages/rendermime/src/outputmodel.ts
index 0624057d172..42efebd665a 100644
--- a/packages/rendermime/src/outputmodel.ts
+++ b/packages/rendermime/src/outputmodel.ts
@@ -2,6 +2,12 @@
 | Copyright (c) Jupyter Development Team.
 | Distributed under the terms of the Modified BSD License.
 |----------------------------------------------------------------------------*/
+import { nbformat } from '@jupyterlab/coreutils';
+
+import { DatastoreExt } from '@jupyterlab/datastore';
+
+import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
+
 import {
   JSONExt,
   JSONObject,
@@ -9,25 +15,105 @@ import {
   ReadonlyJSONObject
 } from '@lumino/coreutils';
 
-import { ISignal, Signal } from '@lumino/signaling';
+import { Datastore, Fields, Record, RegisterField } from '@lumino/datastore';
 
-import { nbformat } from '@jupyterlab/coreutils';
+import { MimeModel } from './mimemodel';
 
-import { IObservableJSON, ObservableJSON } from '@jupyterlab/observables';
+/**
+ * A namespace for interfaces describing where an IOutputModel
+ * holds its data.
+ */
+export namespace IOutputData {
+  /**
+   * A type alias for the ouput model schema.
+   */
+  export type Schema = {
+    /**
+     * The id for the schema.
+     */
+    id: string;
 
-import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
+    /**
+     * The fields for a single output.
+     */
+    fields: {
+      /**
+       * Whether the output model is trusted.
+       */
+      trusted: RegisterField<boolean>;
+
+      /**
+       * The type of the output model.
+       */
+      type: RegisterField<string>;
+
+      /**
+       * The execution count of the model.
+       */
+      executionCount: RegisterField<nbformat.ExecutionCount>;
+
+      /**
+       * The data for the model.
+       */
+      data: RegisterField<ReadonlyJSONObject>;
+
+      /**
+       * The metadata for the model.
+       */
+      metadata: RegisterField<ReadonlyJSONObject>;
+
+      /**
+       * Raw data passed in that is not in the data or metadata fields.
+       */
+      raw: RegisterField<ReadonlyJSONObject>;
+    };
+  };
 
-import { MimeModel } from './mimemodel';
+  /**
+   * A description of where data is stored in a code editor.
+   */
+  export type DataLocation = DatastoreExt.DataLocation & {
+    /**
+     * The record in which the data is located.
+     */
+    record: DatastoreExt.RecordLocation<Schema>;
+  };
+}
 
 /**
- * The interface for an output model.
+ * A namespace for default implementation of the IOutputData functionality.
  */
-export interface IOutputModel extends IRenderMime.IMimeModel {
+export namespace OutputData {
   /**
-   * A signal emitted when the output model changes.
+   * A concrete realization of the schema, available at runtime.
    */
-  readonly changed: ISignal<this, void>;
+  export const SCHEMA: IOutputData.Schema = {
+    id: '@jupyterlab/rendermime:outputmodel.v1',
+    fields: {
+      trusted: Fields.Boolean(),
+      type: Fields.String(),
+      executionCount: Fields.Register<nbformat.ExecutionCount>({ value: null }),
+      data: Fields.Register<ReadonlyJSONObject>({ value: {} }),
+      metadata: Fields.Register<ReadonlyJSONObject>({ value: {} }),
+      raw: Fields.Register<ReadonlyJSONObject>({ value: {} })
+    }
+  };
 
+  /**
+   * Create an in-memory datastore capable of holding the data for an output.
+   */
+  export function createStore(id: number = 1): Datastore {
+    return Datastore.create({
+      id,
+      schemas: [SCHEMA]
+    });
+  }
+}
+
+/**
+ * The interface for an output model.
+ */
+export interface IOutputModel extends IRenderMime.IMimeModel {
   /**
    * The output type.
    */
@@ -55,7 +141,7 @@ export interface IOutputModel extends IRenderMime.IMimeModel {
 }
 
 /**
- * The namespace for IOutputModel sub-interfaces.
+ * A namespace for IOutputModel statics.
  */
 export namespace IOutputModel {
   /**
@@ -65,12 +151,17 @@ export namespace IOutputModel {
     /**
      * The raw output value.
      */
-    value: nbformat.IOutput;
+    value?: nbformat.IOutput;
 
     /**
      * Whether the output is trusted.  The default is false.
      */
     trusted?: boolean;
+
+    /**
+     * A location in which to store the data.
+     */
+    data?: IOutputData.DataLocation;
   }
 }
 
@@ -82,75 +173,85 @@ export class OutputModel implements IOutputModel {
    * Construct a new output model.
    */
   constructor(options: IOutputModel.IOptions) {
-    let { data, metadata, trusted } = Private.getBundleOptions(options);
-    this._data = new ObservableJSON({ values: data as JSONObject });
-    this._rawData = data;
-    this._metadata = new ObservableJSON({ values: metadata as JSONObject });
-    this._rawMetadata = metadata;
-    this.trusted = trusted;
-    // Make a copy of the data.
-    let value = options.value;
-    for (let key in value) {
-      // Ignore data and metadata that were stripped.
-      switch (key) {
-        case 'data':
-        case 'metadata':
-          break;
-        default:
-          this._raw[key] = Private.extract(value, key);
-      }
-    }
-    this.type = value.output_type;
-    if (nbformat.isExecuteResult(value)) {
-      this.executionCount = value.execution_count;
+    if (options.data) {
+      this._data = options.data;
     } else {
-      this.executionCount = null;
+      this._datastore = OutputData.createStore();
+      this._data = {
+        datastore: this._datastore,
+        record: {
+          schema: OutputData.SCHEMA,
+          record: 'data'
+        }
+      };
+      if (options.value) {
+        OutputModel.fromJSON(this._data, options.value, options.trusted);
+      }
     }
   }
 
-  /**
-   * A signal emitted when the output model changes.
-   */
-  get changed(): ISignal<this, void> {
-    return this._changed;
-  }
-
   /**
    * The output type.
    */
-  readonly type: string;
+  get type(): string {
+    return DatastoreExt.getField(this._data.datastore, {
+      ...this._data.record,
+      field: 'type'
+    });
+  }
 
   /**
    * The execution count.
    */
-  readonly executionCount: nbformat.ExecutionCount;
+  get executionCount(): nbformat.ExecutionCount {
+    return DatastoreExt.getField(this._data.datastore, {
+      ...this._data.record,
+      field: 'executionCount'
+    });
+  }
 
   /**
    * Whether the model is trusted.
    */
-  readonly trusted: boolean;
+  get trusted(): boolean {
+    return DatastoreExt.getField(this._data.datastore, {
+      ...this._data.record,
+      field: 'trusted'
+    });
+  }
 
   /**
    * Dispose of the resources used by the output model.
    */
   dispose(): void {
-    this._data.dispose();
-    this._metadata.dispose();
-    Signal.clearData(this);
+    if (this._isDisposed) {
+      return;
+    }
+    this._isDisposed = true;
+    if (this._datastore) {
+      this._datastore.dispose();
+      this._datastore = null;
+    }
   }
 
   /**
    * The data associated with the model.
    */
   get data(): ReadonlyJSONObject {
-    return this._rawData;
+    return DatastoreExt.getField(this._data.datastore, {
+      ...this._data.record,
+      field: 'data'
+    });
   }
 
   /**
    * The metadata associated with the model.
    */
   get metadata(): ReadonlyJSONObject {
-    return this._rawMetadata;
+    return DatastoreExt.getField(this._data.datastore, {
+      ...this._data.record,
+      field: 'metadata'
+    });
   }
 
   /**
@@ -161,73 +262,36 @@ export class OutputModel implements IOutputModel {
    * this call may or may not have deferred effects,
    */
   setData(options: IRenderMime.IMimeModel.ISetDataOptions): void {
+    let metadataUpdate: Record.Update<IOutputData.Schema> = {};
+    let dataUpdate: Record.Update<IOutputData.Schema> = {};
     if (options.data) {
-      this._updateObservable(this._data, options.data);
-      this._rawData = options.data;
+      dataUpdate = { data: options.data };
     }
     if (options.metadata) {
-      this._updateObservable(this._metadata, options.metadata);
-      this._rawMetadata = options.metadata;
+      metadataUpdate = { metadata: options.metadata };
     }
-    this._changed.emit(void 0);
+    const { datastore, record } = this._data;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateRecord(datastore, record, {
+        ...dataUpdate,
+        ...metadataUpdate
+      });
+    });
   }
 
   /**
    * Serialize the model to JSON.
    */
   toJSON(): nbformat.IOutput {
-    let output: JSONValue = {};
-    for (let key in this._raw) {
-      output[key] = Private.extract(this._raw, key);
-    }
-    switch (this.type) {
-      case 'display_data':
-      case 'execute_result':
-      case 'update_display_data':
-        output['data'] = this.data as JSONObject;
-        output['metadata'] = this.metadata as JSONObject;
-        break;
-      default:
-        break;
-    }
-    // Remove transient data.
-    delete output['transient'];
-    return output as nbformat.IOutput;
+    return OutputModel.toJSON(this._data);
   }
 
   /**
-   * Update an observable JSON object using a readonly JSON object.
+   * The record in which the output model is stored.
    */
-  private _updateObservable(
-    observable: IObservableJSON,
-    data: ReadonlyJSONObject
-  ) {
-    let oldKeys = observable.keys();
-    let newKeys = Object.keys(data);
-
-    // Handle removed keys.
-    for (let key of oldKeys) {
-      if (newKeys.indexOf(key) === -1) {
-        observable.delete(key);
-      }
-    }
-
-    // Handle changed data.
-    for (let key of newKeys) {
-      let oldValue = observable.get(key);
-      let newValue = data[key];
-      if (oldValue !== newValue) {
-        observable.set(key, newValue as JSONValue);
-      }
-    }
-  }
-
-  private _changed = new Signal<this, void>(this);
-  private _raw: JSONObject = {};
-  private _rawMetadata: ReadonlyJSONObject;
-  private _rawData: ReadonlyJSONObject;
-  private _data: IObservableJSON;
-  private _metadata: IObservableJSON;
+  private readonly _data: IOutputData.DataLocation;
+  private _datastore: Datastore | null = null;
+  private _isDisposed = false;
 }
 
 /**
@@ -255,6 +319,91 @@ export namespace OutputModel {
   export function getMetadata(output: nbformat.IOutput): JSONObject {
     return Private.getMetadata(output);
   }
+
+  /**
+   * Serialize an output record to JSON.
+   */
+  export function toJSON(loc: IOutputData.DataLocation): nbformat.IOutput {
+    let { datastore, record } = loc;
+    let output: JSONObject = DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'raw'
+    }) as JSONObject;
+    const type = DatastoreExt.getField(datastore, { ...record, field: 'type' });
+    const data = DatastoreExt.getField(datastore, { ...record, field: 'data' });
+    const metadata = DatastoreExt.getField(datastore, {
+      ...record,
+      field: 'metadata'
+    });
+    switch (type) {
+      case 'display_data':
+      case 'execute_result':
+      case 'update_display_data':
+        output['data'] = data as JSONValue;
+        output['metadata'] = metadata as JSONValue;
+        break;
+      default:
+        break;
+    }
+    // Remove transient data.
+    delete output['transient'];
+    return output as nbformat.IOutput;
+  }
+
+  export function fromJSON(
+    loc: IOutputData.DataLocation,
+    value: nbformat.IOutput,
+    trusted: boolean = false
+  ): void {
+    const { datastore, record } = loc;
+    let data = Private.getData(value);
+    let metadata = Private.getData(value);
+    trusted = !!trusted;
+
+    let raw: { [x: string]: JSONValue } = {};
+    for (let key in value) {
+      // Ignore data and metadata that were stripped.
+      switch (key) {
+        case 'data':
+        case 'metadata':
+          break;
+        default:
+          raw[key] = Private.extract(value, key);
+      }
+    }
+    const type = value.output_type;
+    const executionCount = nbformat.isExecuteResult(value)
+      ? value.execution_count
+      : null;
+
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateRecord(datastore, record, {
+        data,
+        executionCount,
+        metadata,
+        raw,
+        trusted,
+        type
+      });
+    });
+  }
+
+  /**
+   * Clear an output record from a table.
+   */
+  export function clear(loc: IOutputData.DataLocation): void {
+    const { datastore, record } = loc;
+    DatastoreExt.withTransaction(datastore, () => {
+      DatastoreExt.updateRecord(datastore, record, {
+        data: {},
+        executionCount: null,
+        metadata: {},
+        raw: {},
+        trusted: false,
+        type: ''
+      });
+    });
+  }
 }
 
 /**
diff --git a/packages/services/src/contents/index.ts b/packages/services/src/contents/index.ts
index 79be3a6c5f2..905b161e742 100644
--- a/packages/services/src/contents/index.ts
+++ b/packages/services/src/contents/index.ts
@@ -3,8 +3,6 @@
 
 import { URLExt, PathExt } from '@jupyterlab/coreutils';
 
-import { ModelDB } from '@jupyterlab/observables';
-
 import { JSONObject } from '@lumino/coreutils';
 
 import { each } from '@lumino/algorithm';
@@ -253,13 +251,6 @@ export namespace Contents {
      */
     driveName(path: string): string;
 
-    /**
-     * Given a path, get a ModelDB.IFactory from the
-     * relevant backend. Returns `null` if the backend
-     * does not provide one.
-     */
-    getModelDBFactory(path: string): ModelDB.IFactory | null;
-
     /**
      * Get a file or directory.
      *
@@ -393,12 +384,6 @@ export namespace Contents {
      */
     readonly serverSettings: ServerConnection.ISettings;
 
-    /**
-     * An optional ModelDB.IFactory instance for the
-     * drive.
-     */
-    readonly modelDBFactory?: ModelDB.IFactory;
-
     /**
      * A signal emitted when a file operation takes place.
      */
@@ -581,16 +566,6 @@ export class ContentsManager implements Contents.IManager {
     drive.fileChanged.connect(this._onFileChanged, this);
   }
 
-  /**
-   * Given a path, get a ModelDB.IFactory from the
-   * relevant backend. Returns `null` if the backend
-   * does not provide one.
-   */
-  getModelDBFactory(path: string): ModelDB.IFactory | null {
-    let [drive] = this._driveForPath(path);
-    return (drive && drive.modelDBFactory) || null;
-  }
-
   /**
    * Given a path of the form `drive:local/portion/of/it.txt`
    * get the local part of it.
diff --git a/packages/services/src/index.ts b/packages/services/src/index.ts
index fc86490bf28..a78a8595407 100644
--- a/packages/services/src/index.ts
+++ b/packages/services/src/index.ts
@@ -10,6 +10,7 @@ export * from './session';
 export * from './setting';
 export * from './terminal';
 export * from './workspace';
+export * from './wsconnection';
 export * from './nbconvert';
 
 export { Builder } from './builder';

diff --git a/packages/settingeditor/src/raweditor.ts b/packages/settingeditor/src/raweditor.ts
index d88ea31c264..40e85646cb5 100644
--- a/packages/settingeditor/src/raweditor.ts
+++ b/packages/settingeditor/src/raweditor.ts
@@ -7,6 +7,8 @@ import { CodeEditor, CodeEditorWrapper } from '@jupyterlab/codeeditor';
 
 import { ISettingRegistry } from '@jupyterlab/coreutils';
 
+import { DatastoreExt } from '@jupyterlab/datastore';
+
 import { IRenderMimeRegistry } from '@jupyterlab/rendermime';
 
 import { CommandRegistry } from '@lumino/commands';
@@ -71,7 +73,7 @@ export class RawEditor extends SplitPanel {
       factory: editorFactory
     }));
 
-    defaults.editor.model.value.text = '';
+    defaults.editor.model.value = '';
     defaults.editor.model.mimeType = 'text/javascript';
     defaults.editor.setOption('readOnly', true);
 
@@ -84,7 +86,12 @@ export class RawEditor extends SplitPanel {
 
     user.addClass(USER_CLASS);
     user.editor.model.mimeType = 'text/javascript';
-    user.editor.model.value.changed.connect(this._onTextChanged, this);
+    DatastoreExt.listenField(
+      user.editor.model.data.datastore,
+      { ...user.editor.model.data.record, field: 'text' },
+      this._onTextChanged,
+      this
+    );
 
     // Create and set up an inspector.
     this._inspector = createInspector(this, options.rendermime);
@@ -125,7 +132,7 @@ export class RawEditor extends SplitPanel {
    * Tests whether the settings have been modified and need saving.
    */
   get isDirty(): boolean {
-    return this._user.editor.model.value.text !== this._settings.raw;
+    return this._user.editor.model.value !== this._settings.raw;
   }
 
   /**
@@ -160,8 +167,8 @@ export class RawEditor extends SplitPanel {
       this._onSettingsChanged();
     } else {
       this._settings = null;
-      defaults.editor.model.value.text = '';
-      user.editor.model.value.text = '';
+      defaults.editor.model.value = '';
+      user.editor.model.value = '';
     }
 
     this.update();
@@ -201,7 +208,7 @@ export class RawEditor extends SplitPanel {
    * Revert the editor back to original settings.
    */
   revert(): void {
-    this._user.editor.model.value.text = this.settings.raw;
+    this._user.editor.model.value = this.settings.raw;
     this._updateToolbar(false, false);
   }
 
@@ -214,7 +221,7 @@ export class RawEditor extends SplitPanel {
     }
 
     const settings = this._settings;
-    const source = this._user.editor.model.value.text;
+    const source = this._user.editor.model.value;
 
     return settings
       .save(source)
@@ -253,7 +260,7 @@ export class RawEditor extends SplitPanel {
    * Handle text changes in the underlying editor.
    */
   private _onTextChanged(): void {
-    const raw = this._user.editor.model.value.text;
+    const raw = this._user.editor.model.value;
     const settings = this._settings;
 
     this.removeClass(ERROR_CLASS);
@@ -283,8 +290,8 @@ export class RawEditor extends SplitPanel {
     const defaults = this._defaults;
     const user = this._user;
 
-    defaults.editor.model.value.text = settings.annotatedDefaults();
-    user.editor.model.value.text = settings.raw;
+    defaults.editor.model.value = settings.annotatedDefaults();
+    user.editor.model.value = settings.raw;
   }
 
   private _updateToolbar(revert = this._canRevert, save = this._canSave): void {
diff --git a/packages/statusbar-extension/src/index.ts b/packages/statusbar-extension/src/index.ts
index 0628a1b6173..fa8138a226c 100644
--- a/packages/statusbar-extension/src/index.ts
+++ b/packages/statusbar-extension/src/index.ts
@@ -253,7 +253,11 @@ export const lineColItem: JupyterFrontEndPlugin<void> = {
         );
         const cell = (newValue as NotebookPanel).content.activeCell;
         item.model!.editor = cell && cell.editor;
-      } else if (newValue && editorTracker.has(newValue)) {
+      } else if (
+        newValue &&
+        editorTracker.has(newValue) &&
+        (newValue as IDocumentWidget<FileEditor>).content.editor
+      ) {
         item.model!.editor = (newValue as IDocumentWidget<
           FileEditor
         >).content.editor;
diff --git a/packages/statusbar/src/defaults/lineCol.tsx b/packages/statusbar/src/defaults/lineCol.tsx
index 2240c2da940..653626d95c3 100644
--- a/packages/statusbar/src/defaults/lineCol.tsx
+++ b/packages/statusbar/src/defaults/lineCol.tsx
@@ -7,6 +7,10 @@ import { VDomRenderer, VDomModel, ReactWidget } from '@jupyterlab/apputils';
 
 import { CodeEditor } from '@jupyterlab/codeeditor';
 
+import { DatastoreExt } from '@jupyterlab/datastore';
+
+import { IDisposable } from '@lumino/disposable';
+
 import { interactiveItem, showPopup, Popup, TextItem } from '..';
 
 import {
@@ -290,9 +294,9 @@ export namespace LineCol {
       return this._editor;
     }
     set editor(editor: CodeEditor.IEditor | null) {
-      const oldEditor = this._editor;
-      if (oldEditor) {
-        oldEditor.model.selections.changed.disconnect(this._onSelectionChanged);
+      if (this._selectionListener) {
+        this._selectionListener.dispose();
+        this._selectionListener = null;
       }
 
       const oldState = this._getAllState();
@@ -301,7 +305,11 @@ export namespace LineCol {
         this._column = 1;
         this._line = 1;
       } else {
-        this._editor.model.selections.changed.connect(this._onSelectionChanged);
+        DatastoreExt.listenField(
+          editor.model.data.datastore,
+          { ...editor.model.data.record, field: 'selections' },
+          this._onSelectionChanged
+        );
 
         const pos = this._editor.getCursorPosition();
         this._column = pos.column + 1;
@@ -353,5 +361,6 @@ export namespace LineCol {
     private _line: number = 1;
     private _column: number = 1;
     private _editor: CodeEditor.IEditor | null = null;
+    private _selectionListener: IDisposable | null = null;
   }
 }
diff --git a/packages/tooltip-extension/src/index.ts b/packages/tooltip-extension/src/index.ts
index e1360b310b7..e69dde42ddb 100644
--- a/packages/tooltip-extension/src/index.ts
+++ b/packages/tooltip-extension/src/index.ts
@@ -292,7 +292,7 @@ namespace Private {
    */
   export function fetch(options: IFetchOptions): Promise<JSONObject> {
     let { detail, editor, kernel } = options;
-    let code = editor.model.value.text;
+    let code = editor.model.value;
     let position = editor.getCursorPosition();
     let offset = Text.jsIndexToCharIndex(editor.getOffsetAt(position), code);
